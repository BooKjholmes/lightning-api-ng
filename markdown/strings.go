package markdown

import (
	"regexp"
	"strings"
)

var (
	// snakeSplitRegex is used to split a string into words by capital
	// letters.
	snakeSplitRegex = regexp.MustCompile("([A-Z])")

	// htmlSpecialChars is a map of special HTML characters that need to be
	// escaped.
	htmlSpecialChars = map[string]string{
		"<": "&lt;",
		">": "&gt;",
		`"`: "&quot;",
		"'": "&#x27;",
		"`": "&#x60;",
		"=": "&#x3D;",
	}

	// markdownChars is a map of special markdown characters that need to be
	// escaped.
	markdownSpecialChars = map[string]string{
		"\n": " ",
		"|":  "\\|",
	}
)

// ToKebabCase converts a string to kebab case. This is used to keep the method
// urls consistent with the values previously generated by the Typescript
// generator. Doing so would break deep links.
//
// Using strcase.KebabCase would result in "TrackPaymentV2" being
// converted to "track-payment-v-2" instead of "track-payment-v2".
func ToKebabCase(s string) string {
	matches := snakeSplitRegex.FindAllStringIndex(s, -1)
	if len(matches) == 0 {
		return strings.ToLower(s)
	}
	for i, match := range matches {
		s = s[:match[0]+i] + "-" + s[match[0]+i:]
	}
	return strings.TrimLeft(strings.ToLower(s), "-")
}

// CleanDescription removes newlines and escapes pipes from the description.
func CleanDescription(description string, escapeMarkdown bool) string {
	// Always replace the & character first to avoid double escaping.
	desc := strings.ReplaceAll(description, "&", "&amp;")
	for k, v := range htmlSpecialChars {
		desc = strings.ReplaceAll(desc, k, v)
	}
	if escapeMarkdown {
		for k, v := range markdownSpecialChars {
			desc = strings.ReplaceAll(desc, k, v)
		}
	}
	return desc
}
