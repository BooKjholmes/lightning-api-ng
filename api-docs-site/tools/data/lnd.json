{
  "files": [
    {
      "name": "signrpc/signer.proto",
      "description": "",
      "package": "signrpc",
      "hasEnums": true,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [
        {
          "name": "SignMethod",
          "longName": "SignMethod",
          "fullName": "signrpc.SignMethod",
          "description": "",
          "values": [
            {
              "name": "SIGN_METHOD_WITNESS_V0",
              "number": "0",
              "description": "Specifies that a SegWit v0 (p2wkh, np2wkh, p2wsh) input script should be\nsigned."
            },
            {
              "name": "SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086",
              "number": "1",
              "description": "Specifies that a SegWit v1 (p2tr) input should be signed by using the\nBIP0086 method (commit to internal key only)."
            },
            {
              "name": "SIGN_METHOD_TAPROOT_KEY_SPEND",
              "number": "2",
              "description": "Specifies that a SegWit v1 (p2tr) input should be signed by using a given\ntaproot hash to commit to in addition to the internal key."
            },
            {
              "name": "SIGN_METHOD_TAPROOT_SCRIPT_SPEND",
              "number": "3",
              "description": "Specifies that a SegWit v1 (p2tr) input should be spent using the script\npath and that a specific leaf script should be signed for."
            }
          ]
        }
      ],
      "extensions": [],
      "messages": [
        {
          "name": "InputScript",
          "longName": "InputScript",
          "fullName": "signrpc.InputScript",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "witness",
              "description": "The serializes witness stack for the specified input.",
              "label": "repeated",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sig_script",
              "description": "The optional sig script for the specified witness that will only be set if\nthe input specified is a nested p2sh witness program.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "InputScriptResp",
          "longName": "InputScriptResp",
          "fullName": "signrpc.InputScriptResp",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "input_scripts",
              "description": "The set of fully valid input scripts requested.",
              "label": "repeated",
              "type": "InputScript",
              "longType": "InputScript",
              "fullType": "signrpc.InputScript",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "KeyDescriptor",
          "longName": "KeyDescriptor",
          "fullName": "signrpc.KeyDescriptor",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "raw_key_bytes",
              "description": "The raw bytes of the public key in the key pair being identified. Either\nthis or the KeyLocator must be specified.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "key_loc",
              "description": "The key locator that identifies which private key to use for signing.\nEither this or the raw bytes of the target public key must be specified.",
              "label": "",
              "type": "KeyLocator",
              "longType": "KeyLocator",
              "fullType": "signrpc.KeyLocator",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "KeyLocator",
          "longName": "KeyLocator",
          "fullName": "signrpc.KeyLocator",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key_family",
              "description": "The family of key being identified.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "key_index",
              "description": "The precise index of the key being identified.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MuSig2CleanupRequest",
          "longName": "MuSig2CleanupRequest",
          "fullName": "signrpc.MuSig2CleanupRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "session_id",
              "description": "The unique ID of the signing session that should be removed/cleaned up.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MuSig2CleanupResponse",
          "longName": "MuSig2CleanupResponse",
          "fullName": "signrpc.MuSig2CleanupResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "MuSig2CombineKeysRequest",
          "longName": "MuSig2CombineKeysRequest",
          "fullName": "signrpc.MuSig2CombineKeysRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "all_signer_pubkeys",
              "description": "A list of all public keys (serialized in 32-byte x-only format!)\nparticipating in the signing session. The list will always be sorted\nlexicographically internally. This must include the local key which is\ndescribed by the above key_loc.",
              "label": "repeated",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "tweaks",
              "description": "A series of optional generic tweaks to be applied to the the aggregated\npublic key.",
              "label": "repeated",
              "type": "TweakDesc",
              "longType": "TweakDesc",
              "fullType": "signrpc.TweakDesc",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "taproot_tweak",
              "description": "An optional taproot specific tweak that must be specified if the MuSig2\ncombined key will be used as the main taproot key of a taproot output\non-chain.",
              "label": "",
              "type": "TaprootTweakDesc",
              "longType": "TaprootTweakDesc",
              "fullType": "signrpc.TaprootTweakDesc",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MuSig2CombineKeysResponse",
          "longName": "MuSig2CombineKeysResponse",
          "fullName": "signrpc.MuSig2CombineKeysResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "combined_key",
              "description": "The combined public key (in the 32-byte x-only format) with all tweaks\napplied to it. If a taproot tweak is specified, this corresponds to the\ntaproot key that can be put into the on-chain output.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "taproot_internal_key",
              "description": "The raw combined public key (in the 32-byte x-only format) before any tweaks\nare applied to it. If a taproot tweak is specified, this corresponds to the\ninternal key that needs to be put into the witness if the script spend path\nis used.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MuSig2CombineSigRequest",
          "longName": "MuSig2CombineSigRequest",
          "fullName": "signrpc.MuSig2CombineSigRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "session_id",
              "description": "The unique ID of the signing session to combine the signatures for.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "other_partial_signatures",
              "description": "The list of all other participants' partial signatures to add to the current\nsession.",
              "label": "repeated",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MuSig2CombineSigResponse",
          "longName": "MuSig2CombineSigResponse",
          "fullName": "signrpc.MuSig2CombineSigResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "have_all_signatures",
              "description": "Indicates whether all partial signatures required to create a final, full\nsignature are known yet. If this is true, then the final_signature field is\nset, otherwise it is empty.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "final_signature",
              "description": "The final, full signature that is valid for the combined public key.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MuSig2RegisterNoncesRequest",
          "longName": "MuSig2RegisterNoncesRequest",
          "fullName": "signrpc.MuSig2RegisterNoncesRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "session_id",
              "description": "The unique ID of the signing session those nonces should be registered with.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "other_signer_public_nonces",
              "description": "A list of all public nonces of other signing participants that should be\nregistered.",
              "label": "repeated",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MuSig2RegisterNoncesResponse",
          "longName": "MuSig2RegisterNoncesResponse",
          "fullName": "signrpc.MuSig2RegisterNoncesResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "have_all_nonces",
              "description": "Indicates whether all nonces required to start the signing process are known\nnow.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MuSig2SessionRequest",
          "longName": "MuSig2SessionRequest",
          "fullName": "signrpc.MuSig2SessionRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key_loc",
              "description": "The key locator that identifies which key to use for signing.",
              "label": "",
              "type": "KeyLocator",
              "longType": "KeyLocator",
              "fullType": "signrpc.KeyLocator",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "all_signer_pubkeys",
              "description": "A list of all public keys (serialized in 32-byte x-only format!)\nparticipating in the signing session. The list will always be sorted\nlexicographically internally. This must include the local key which is\ndescribed by the above key_loc.",
              "label": "repeated",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "other_signer_public_nonces",
              "description": "An optional list of all public nonces of other signing participants that\nmight already be known.",
              "label": "repeated",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "tweaks",
              "description": "A series of optional generic tweaks to be applied to the the aggregated\npublic key.",
              "label": "repeated",
              "type": "TweakDesc",
              "longType": "TweakDesc",
              "fullType": "signrpc.TweakDesc",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "taproot_tweak",
              "description": "An optional taproot specific tweak that must be specified if the MuSig2\ncombined key will be used as the main taproot key of a taproot output\non-chain.",
              "label": "",
              "type": "TaprootTweakDesc",
              "longType": "TaprootTweakDesc",
              "fullType": "signrpc.TaprootTweakDesc",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MuSig2SessionResponse",
          "longName": "MuSig2SessionResponse",
          "fullName": "signrpc.MuSig2SessionResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "session_id",
              "description": "The unique ID that represents this signing session. A session can be used\nfor producing a signature a single time. If the signing fails for any\nreason, a new session with the same participants needs to be created.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "combined_key",
              "description": "The combined public key (in the 32-byte x-only format) with all tweaks\napplied to it. If a taproot tweak is specified, this corresponds to the\ntaproot key that can be put into the on-chain output.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "taproot_internal_key",
              "description": "The raw combined public key (in the 32-byte x-only format) before any tweaks\nare applied to it. If a taproot tweak is specified, this corresponds to the\ninternal key that needs to be put into the witness if the script spend path\nis used.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "local_public_nonces",
              "description": "The two public nonces the local signer uses, combined into a single value\nof 66 bytes. Can be split into the two 33-byte points to get the individual\nnonces.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "have_all_nonces",
              "description": "Indicates whether all nonces required to start the signing process are known\nnow.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MuSig2SignRequest",
          "longName": "MuSig2SignRequest",
          "fullName": "signrpc.MuSig2SignRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "session_id",
              "description": "The unique ID of the signing session to use for signing.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "message_digest",
              "description": "The 32-byte SHA256 digest of the message to sign.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "cleanup",
              "description": "Cleanup indicates that after signing, the session state can be cleaned up,\nsince another participant is going to be responsible for combining the\npartial signatures.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MuSig2SignResponse",
          "longName": "MuSig2SignResponse",
          "fullName": "signrpc.MuSig2SignResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "local_partial_signature",
              "description": "The partial signature created by the local signer.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SharedKeyRequest",
          "longName": "SharedKeyRequest",
          "fullName": "signrpc.SharedKeyRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "ephemeral_pubkey",
              "description": "The ephemeral public key to use for the DH key derivation.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "key_loc",
              "description": "Deprecated. The optional key locator of the local key that should be used.\nIf this parameter is not set then the node's identity private key will be\nused.",
              "label": "",
              "type": "KeyLocator",
              "longType": "KeyLocator",
              "fullType": "signrpc.KeyLocator",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "key_desc",
              "description": "A key descriptor describes the key used for performing ECDH. Either a key\nlocator or a raw public key is expected, if neither is supplied, defaults to\nthe node's identity private key.",
              "label": "",
              "type": "KeyDescriptor",
              "longType": "KeyDescriptor",
              "fullType": "signrpc.KeyDescriptor",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SharedKeyResponse",
          "longName": "SharedKeyResponse",
          "fullName": "signrpc.SharedKeyResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "shared_key",
              "description": "The shared public key, hashed with sha256.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SignDescriptor",
          "longName": "SignDescriptor",
          "fullName": "signrpc.SignDescriptor",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key_desc",
              "description": "A descriptor that precisely describes *which* key to use for signing. This\nmay provide the raw public key directly, or require the Signer to re-derive\nthe key according to the populated derivation path.\n\nNote that if the key descriptor was obtained through walletrpc.DeriveKey,\nthen the key locator MUST always be provided, since the derived keys are not\npersisted unlike with DeriveNextKey.",
              "label": "",
              "type": "KeyDescriptor",
              "longType": "KeyDescriptor",
              "fullType": "signrpc.KeyDescriptor",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "single_tweak",
              "description": "A scalar value that will be added to the private key corresponding to the\nabove public key to obtain the private key to be used to sign this input.\nThis value is typically derived via the following computation:\n\nderivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "double_tweak",
              "description": "A private key that will be used in combination with its corresponding\nprivate key to derive the private key that is to be used to sign the target\ninput. Within the Lightning protocol, this value is typically the\ncommitment secret from a previously revoked commitment transaction. This\nvalue is in combination with two hash values, and the original private key\nto derive the private key to be used when signing.\n\nk = (privKey*sha256(pubKey || tweakPub) +\ntweakPriv*sha256(tweakPub || pubKey)) mod N",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "tap_tweak",
              "description": "The 32 byte input to the taproot tweak derivation that is used to derive\nthe output key from an internal key: outputKey = internalKey +\ntagged_hash(\"tapTweak\", internalKey || tapTweak).\n\nWhen doing a BIP 86 spend, this field can be an empty byte slice.\n\nWhen doing a normal key path spend, with the output key committing to an\nactual script root, then this field should be: the tapscript root hash.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "witness_script",
              "description": "The full script required to properly redeem the output. This field will\nonly be populated if a p2tr, p2wsh or a p2sh output is being signed. If a\ntaproot script path spend is being attempted, then this should be the raw\nleaf script.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "output",
              "description": "A description of the output being spent. The value and script MUST be\nprovided.",
              "label": "",
              "type": "TxOut",
              "longType": "TxOut",
              "fullType": "signrpc.TxOut",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sighash",
              "description": "The target sighash type that should be used when generating the final\nsighash, and signature.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "input_index",
              "description": "The target input within the transaction that should be signed.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sign_method",
              "description": "The sign method specifies how the input should be signed. Depending on the\nmethod, either the tap_tweak, witness_script or both need to be specified.\nDefaults to SegWit v0 signing to be backward compatible with older RPC\nclients.",
              "label": "",
              "type": "SignMethod",
              "longType": "SignMethod",
              "fullType": "signrpc.SignMethod",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SignMessageReq",
          "longName": "SignMessageReq",
          "fullName": "signrpc.SignMessageReq",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "msg",
              "description": "The message to be signed. When using REST, this field must be encoded as\nbase64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "key_loc",
              "description": "The key locator that identifies which key to use for signing.",
              "label": "",
              "type": "KeyLocator",
              "longType": "KeyLocator",
              "fullType": "signrpc.KeyLocator",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "double_hash",
              "description": "Double-SHA256 hash instead of just the default single round.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "compact_sig",
              "description": "Use the compact (pubkey recoverable) format instead of the raw lnwire\nformat. This option cannot be used with Schnorr signatures.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "schnorr_sig",
              "description": "Use Schnorr signature. This option cannot be used with compact format.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "schnorr_sig_tap_tweak",
              "description": "The optional Taproot tweak bytes to apply to the private key before creating\na Schnorr signature. The private key is tweaked as described in BIP-341:\nprivKey + h_tapTweak(internalKey || tapTweak)",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SignMessageResp",
          "longName": "SignMessageResp",
          "fullName": "signrpc.SignMessageResp",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "signature",
              "description": "The signature for the given message in the fixed-size LN wire format.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SignReq",
          "longName": "SignReq",
          "fullName": "signrpc.SignReq",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "raw_tx_bytes",
              "description": "The raw bytes of the transaction to be signed.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sign_descs",
              "description": "A set of sign descriptors, for each input to be signed.",
              "label": "repeated",
              "type": "SignDescriptor",
              "longType": "SignDescriptor",
              "fullType": "signrpc.SignDescriptor",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "prev_outputs",
              "description": "The full list of UTXO information for each of the inputs being spent. This\nis required when spending one or more taproot (SegWit v1) outputs.",
              "label": "repeated",
              "type": "TxOut",
              "longType": "TxOut",
              "fullType": "signrpc.TxOut",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SignResp",
          "longName": "SignResp",
          "fullName": "signrpc.SignResp",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "raw_sigs",
              "description": "A set of signatures realized in a fixed 64-byte format ordered in ascending\ninput order.",
              "label": "repeated",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "TaprootTweakDesc",
          "longName": "TaprootTweakDesc",
          "fullName": "signrpc.TaprootTweakDesc",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "script_root",
              "description": "The root hash of the tapscript tree if a script path is committed to. If\nthe MuSig2 key put on chain doesn't also commit to a script path (BIP-0086\nkey spend only), then this needs to be empty and the key_spend_only field\nbelow must be set to true. This is required because gRPC cannot\ndifferentiate between a zero-size byte slice and a nil byte slice (both\nwould be serialized the same way). So the extra boolean is required.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "key_spend_only",
              "description": "Indicates that the above script_root is expected to be empty because this\nis a BIP-0086 key spend only commitment where only the internal key is\ncommitted to instead of also including a script root hash.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "TweakDesc",
          "longName": "TweakDesc",
          "fullName": "signrpc.TweakDesc",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "tweak",
              "description": "Tweak is the 32-byte value that will modify the public key.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "is_x_only",
              "description": "Specifies if the target key should be converted to an x-only public key\nbefore tweaking. If true, then the public key will be mapped to an x-only\nkey before the tweaking operation is applied.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "TxOut",
          "longName": "TxOut",
          "fullName": "signrpc.TxOut",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "value",
              "description": "The value of the output being spent.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pk_script",
              "description": "The script of the output being spent.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "VerifyMessageReq",
          "longName": "VerifyMessageReq",
          "fullName": "signrpc.VerifyMessageReq",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "msg",
              "description": "The message over which the signature is to be verified. When using\nREST, this field must be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "signature",
              "description": "The fixed-size LN wire encoded signature to be verified over the given\nmessage. When using REST, this field must be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pubkey",
              "description": "The public key the signature has to be valid for. When using REST, this\nfield must be encoded as base64. If the is_schnorr_sig option is true, then\nthe public key is expected to be in the 32-byte x-only serialization\naccording to BIP-340.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "is_schnorr_sig",
              "description": "Specifies if the signature is a Schnorr signature.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "VerifyMessageResp",
          "longName": "VerifyMessageResp",
          "fullName": "signrpc.VerifyMessageResp",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "valid",
              "description": "Whether the signature was valid over the given message.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": [
        {
          "name": "Signer",
          "longName": "Signer",
          "fullName": "signrpc.Signer",
          "description": "Signer is a service that gives access to the signing functionality of the\ndaemon's wallet.",
          "methods": [
            {
              "name": "SignOutputRaw",
              "description": "SignOutputRaw is a method that can be used to generated a signature for a\nset of inputs/outputs to a transaction. Each request specifies details\nconcerning how the outputs should be signed, which keys they should be\nsigned with, and also any optional tweaks. The return value is a fixed\n64-byte signature (the same format as we use on the wire in Lightning).\n\nIf we are  unable to sign using the specified keys, then an error will be\nreturned.",
              "requestType": "SignReq",
              "requestLongType": "SignReq",
              "requestFullType": "signrpc.SignReq",
              "requestStreaming": false,
              "responseType": "SignResp",
              "responseLongType": "SignResp",
              "responseFullType": "signrpc.SignResp",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/signer/signraw",
                  "details": {
                    "description": "If we are  unable to sign using the specified keys, then an error will be\nreturned.",
                    "operationId": "Signer_SignOutputRaw",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/signrpcSignReq"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcSignResp"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SignOutputRaw is a method that can be used to generated a signature for a\nset of inputs/outputs to a transaction. Each request specifies details\nconcerning how the outputs should be signed, which keys they should be\nsigned with, and also any optional tweaks. The return value is a fixed\n64-byte signature (the same format as we use on the wire in Lightning).",
                    "tags": [
                      "Signer"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ComputeInputScript",
              "description": "ComputeInputScript generates a complete InputIndex for the passed\ntransaction with the signature as defined within the passed SignDescriptor.\nThis method should be capable of generating the proper input script for both\nregular p2wkh/p2tr outputs and p2wkh outputs nested within a regular p2sh\noutput.\n\nNote that when using this method to sign inputs belonging to the wallet,\nthe only items of the SignDescriptor that need to be populated are pkScript\nin the TxOut field, the value in that same field, and finally the input\nindex.",
              "requestType": "SignReq",
              "requestLongType": "SignReq",
              "requestFullType": "signrpc.SignReq",
              "requestStreaming": false,
              "responseType": "InputScriptResp",
              "responseLongType": "InputScriptResp",
              "responseFullType": "signrpc.InputScriptResp",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/signer/inputscript",
                  "details": {
                    "description": "Note that when using this method to sign inputs belonging to the wallet,\nthe only items of the SignDescriptor that need to be populated are pkScript\nin the TxOut field, the value in that same field, and finally the input\nindex.",
                    "operationId": "Signer_ComputeInputScript",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/signrpcSignReq"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcInputScriptResp"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ComputeInputScript generates a complete InputIndex for the passed\ntransaction with the signature as defined within the passed SignDescriptor.\nThis method should be capable of generating the proper input script for both\nregular p2wkh/p2tr outputs and p2wkh outputs nested within a regular p2sh\noutput.",
                    "tags": [
                      "Signer"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SignMessage",
              "description": "SignMessage signs a message with the key specified in the key locator. The\nreturned signature is fixed-size LN wire format encoded.\n\nThe main difference to SignMessage in the main RPC is that a specific key is\nused to sign the message instead of the node identity private key.",
              "requestType": "SignMessageReq",
              "requestLongType": "SignMessageReq",
              "requestFullType": "signrpc.SignMessageReq",
              "requestStreaming": false,
              "responseType": "SignMessageResp",
              "responseLongType": "SignMessageResp",
              "responseFullType": "signrpc.SignMessageResp",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/signer/signmessage",
                  "details": {
                    "description": "The main difference to SignMessage in the main RPC is that a specific key is\nused to sign the message instead of the node identity private key.",
                    "operationId": "Signer_SignMessage",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/signrpcSignMessageReq"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcSignMessageResp"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SignMessage signs a message with the key specified in the key locator. The\nreturned signature is fixed-size LN wire format encoded.",
                    "tags": [
                      "Signer"
                    ]
                  }
                }
              ]
            },
            {
              "name": "VerifyMessage",
              "description": "VerifyMessage verifies a signature over a message using the public key\nprovided. The signature must be fixed-size LN wire format encoded.\n\nThe main difference to VerifyMessage in the main RPC is that the public key\nused to sign the message does not have to be a node known to the network.",
              "requestType": "VerifyMessageReq",
              "requestLongType": "VerifyMessageReq",
              "requestFullType": "signrpc.VerifyMessageReq",
              "requestStreaming": false,
              "responseType": "VerifyMessageResp",
              "responseLongType": "VerifyMessageResp",
              "responseFullType": "signrpc.VerifyMessageResp",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/signer/verifymessage",
                  "details": {
                    "description": "The main difference to VerifyMessage in the main RPC is that the public key\nused to sign the message does not have to be a node known to the network.",
                    "operationId": "Signer_VerifyMessage",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/signrpcVerifyMessageReq"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcVerifyMessageResp"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "VerifyMessage verifies a signature over a message using the public key\nprovided. The signature must be fixed-size LN wire format encoded.",
                    "tags": [
                      "Signer"
                    ]
                  }
                }
              ]
            },
            {
              "name": "DeriveSharedKey",
              "description": "DeriveSharedKey returns a shared secret key by performing Diffie-Hellman key\nderivation between the ephemeral public key in the request and the node's\nkey specified in the key_desc parameter. Either a key locator or a raw\npublic key is expected in the key_desc, if neither is supplied, defaults to\nthe node's identity private key:\nP_shared = privKeyNode * ephemeralPubkey\nThe resulting shared public key is serialized in the compressed format and\nhashed with sha256, resulting in the final key length of 256bit.",
              "requestType": "SharedKeyRequest",
              "requestLongType": "SharedKeyRequest",
              "requestFullType": "signrpc.SharedKeyRequest",
              "requestStreaming": false,
              "responseType": "SharedKeyResponse",
              "responseLongType": "SharedKeyResponse",
              "responseFullType": "signrpc.SharedKeyResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/signer/sharedkey",
                  "details": {
                    "operationId": "Signer_DeriveSharedKey",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/signrpcSharedKeyRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcSharedKeyResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "DeriveSharedKey returns a shared secret key by performing Diffie-Hellman key\nderivation between the ephemeral public key in the request and the node's\nkey specified in the key_desc parameter. Either a key locator or a raw\npublic key is expected in the key_desc, if neither is supplied, defaults to\nthe node's identity private key:\nP_shared = privKeyNode * ephemeralPubkey\nThe resulting shared public key is serialized in the compressed format and\nhashed with sha256, resulting in the final key length of 256bit.",
                    "tags": [
                      "Signer"
                    ]
                  }
                }
              ]
            },
            {
              "name": "MuSig2CombineKeys",
              "description": "MuSig2CombineKeys (experimental!) is a stateless helper RPC that can be used\nto calculate the combined MuSig2 public key from a list of all participating\nsigners' public keys. This RPC is completely stateless and deterministic and\ndoes not create any signing session. It can be used to determine the Taproot\npublic key that should be put in an on-chain output once all public keys are\nknown. A signing session is only needed later when that output should be\n_spent_ again.\n\nNOTE: The MuSig2 BIP is not final yet and therefore this API must be\nconsidered to be HIGHLY EXPERIMENTAL and subject to change in upcoming\nreleases. Backward compatibility is not guaranteed!",
              "requestType": "MuSig2CombineKeysRequest",
              "requestLongType": "MuSig2CombineKeysRequest",
              "requestFullType": "signrpc.MuSig2CombineKeysRequest",
              "requestStreaming": false,
              "responseType": "MuSig2CombineKeysResponse",
              "responseLongType": "MuSig2CombineKeysResponse",
              "responseFullType": "signrpc.MuSig2CombineKeysResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/signer/musig2/combinekeys",
                  "details": {
                    "description": "NOTE: The MuSig2 BIP is not final yet and therefore this API must be\nconsidered to be HIGHLY EXPERIMENTAL and subject to change in upcoming\nreleases. Backward compatibility is not guaranteed!",
                    "operationId": "Signer_MuSig2CombineKeys",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/signrpcMuSig2CombineKeysRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcMuSig2CombineKeysResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "MuSig2CombineKeys (experimental!) is a stateless helper RPC that can be used\nto calculate the combined MuSig2 public key from a list of all participating\nsigners' public keys. This RPC is completely stateless and deterministic and\ndoes not create any signing session. It can be used to determine the Taproot\npublic key that should be put in an on-chain output once all public keys are\nknown. A signing session is only needed later when that output should be\n_spent_ again.",
                    "tags": [
                      "Signer"
                    ]
                  }
                }
              ]
            },
            {
              "name": "MuSig2CreateSession",
              "description": "MuSig2CreateSession (experimental!) creates a new MuSig2 signing session\nusing the local key identified by the key locator. The complete list of all\npublic keys of all signing parties must be provided, including the public\nkey of the local signing key. If nonces of other parties are already known,\nthey can be submitted as well to reduce the number of RPC calls necessary\nlater on.\n\nNOTE: The MuSig2 BIP is not final yet and therefore this API must be\nconsidered to be HIGHLY EXPERIMENTAL and subject to change in upcoming\nreleases. Backward compatibility is not guaranteed!",
              "requestType": "MuSig2SessionRequest",
              "requestLongType": "MuSig2SessionRequest",
              "requestFullType": "signrpc.MuSig2SessionRequest",
              "requestStreaming": false,
              "responseType": "MuSig2SessionResponse",
              "responseLongType": "MuSig2SessionResponse",
              "responseFullType": "signrpc.MuSig2SessionResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/signer/musig2/createsession",
                  "details": {
                    "description": "NOTE: The MuSig2 BIP is not final yet and therefore this API must be\nconsidered to be HIGHLY EXPERIMENTAL and subject to change in upcoming\nreleases. Backward compatibility is not guaranteed!",
                    "operationId": "Signer_MuSig2CreateSession",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/signrpcMuSig2SessionRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcMuSig2SessionResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "MuSig2CreateSession (experimental!) creates a new MuSig2 signing session\nusing the local key identified by the key locator. The complete list of all\npublic keys of all signing parties must be provided, including the public\nkey of the local signing key. If nonces of other parties are already known,\nthey can be submitted as well to reduce the number of RPC calls necessary\nlater on.",
                    "tags": [
                      "Signer"
                    ]
                  }
                }
              ]
            },
            {
              "name": "MuSig2RegisterNonces",
              "description": "MuSig2RegisterNonces (experimental!) registers one or more public nonces of\nother signing participants for a session identified by its ID. This RPC can\nbe called multiple times until all nonces are registered.\n\nNOTE: The MuSig2 BIP is not final yet and therefore this API must be\nconsidered to be HIGHLY EXPERIMENTAL and subject to change in upcoming\nreleases. Backward compatibility is not guaranteed!",
              "requestType": "MuSig2RegisterNoncesRequest",
              "requestLongType": "MuSig2RegisterNoncesRequest",
              "requestFullType": "signrpc.MuSig2RegisterNoncesRequest",
              "requestStreaming": false,
              "responseType": "MuSig2RegisterNoncesResponse",
              "responseLongType": "MuSig2RegisterNoncesResponse",
              "responseFullType": "signrpc.MuSig2RegisterNoncesResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/signer/musig2/registernonces",
                  "details": {
                    "description": "NOTE: The MuSig2 BIP is not final yet and therefore this API must be\nconsidered to be HIGHLY EXPERIMENTAL and subject to change in upcoming\nreleases. Backward compatibility is not guaranteed!",
                    "operationId": "Signer_MuSig2RegisterNonces",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/signrpcMuSig2RegisterNoncesRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcMuSig2RegisterNoncesResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "MuSig2RegisterNonces (experimental!) registers one or more public nonces of\nother signing participants for a session identified by its ID. This RPC can\nbe called multiple times until all nonces are registered.",
                    "tags": [
                      "Signer"
                    ]
                  }
                }
              ]
            },
            {
              "name": "MuSig2Sign",
              "description": "MuSig2Sign (experimental!) creates a partial signature using the local\nsigning key that was specified when the session was created. This can only\nbe called when all public nonces of all participants are known and have been\nregistered with the session. If this node isn't responsible for combining\nall the partial signatures, then the cleanup flag should be set, indicating\nthat the session can be removed from memory once the signature was produced.\n\nNOTE: The MuSig2 BIP is not final yet and therefore this API must be\nconsidered to be HIGHLY EXPERIMENTAL and subject to change in upcoming\nreleases. Backward compatibility is not guaranteed!",
              "requestType": "MuSig2SignRequest",
              "requestLongType": "MuSig2SignRequest",
              "requestFullType": "signrpc.MuSig2SignRequest",
              "requestStreaming": false,
              "responseType": "MuSig2SignResponse",
              "responseLongType": "MuSig2SignResponse",
              "responseFullType": "signrpc.MuSig2SignResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/signer/musig2/sign",
                  "details": {
                    "description": "NOTE: The MuSig2 BIP is not final yet and therefore this API must be\nconsidered to be HIGHLY EXPERIMENTAL and subject to change in upcoming\nreleases. Backward compatibility is not guaranteed!",
                    "operationId": "Signer_MuSig2Sign",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/signrpcMuSig2SignRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcMuSig2SignResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "MuSig2Sign (experimental!) creates a partial signature using the local\nsigning key that was specified when the session was created. This can only\nbe called when all public nonces of all participants are known and have been\nregistered with the session. If this node isn't responsible for combining\nall the partial signatures, then the cleanup flag should be set, indicating\nthat the session can be removed from memory once the signature was produced.",
                    "tags": [
                      "Signer"
                    ]
                  }
                }
              ]
            },
            {
              "name": "MuSig2CombineSig",
              "description": "MuSig2CombineSig (experimental!) combines the given partial signature(s)\nwith the local one, if it already exists. Once a partial signature of all\nparticipants is registered, the final signature will be combined and\nreturned.\n\nNOTE: The MuSig2 BIP is not final yet and therefore this API must be\nconsidered to be HIGHLY EXPERIMENTAL and subject to change in upcoming\nreleases. Backward compatibility is not guaranteed!",
              "requestType": "MuSig2CombineSigRequest",
              "requestLongType": "MuSig2CombineSigRequest",
              "requestFullType": "signrpc.MuSig2CombineSigRequest",
              "requestStreaming": false,
              "responseType": "MuSig2CombineSigResponse",
              "responseLongType": "MuSig2CombineSigResponse",
              "responseFullType": "signrpc.MuSig2CombineSigResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/signer/musig2/combinesig",
                  "details": {
                    "description": "NOTE: The MuSig2 BIP is not final yet and therefore this API must be\nconsidered to be HIGHLY EXPERIMENTAL and subject to change in upcoming\nreleases. Backward compatibility is not guaranteed!",
                    "operationId": "Signer_MuSig2CombineSig",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/signrpcMuSig2CombineSigRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcMuSig2CombineSigResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "MuSig2CombineSig (experimental!) combines the given partial signature(s)\nwith the local one, if it already exists. Once a partial signature of all\nparticipants is registered, the final signature will be combined and\nreturned.",
                    "tags": [
                      "Signer"
                    ]
                  }
                }
              ]
            },
            {
              "name": "MuSig2Cleanup",
              "description": "MuSig2Cleanup (experimental!) allows a caller to clean up a session early in\ncases where it's obvious that the signing session won't succeed and the\nresources can be released.\n\nNOTE: The MuSig2 BIP is not final yet and therefore this API must be\nconsidered to be HIGHLY EXPERIMENTAL and subject to change in upcoming\nreleases. Backward compatibility is not guaranteed!",
              "requestType": "MuSig2CleanupRequest",
              "requestLongType": "MuSig2CleanupRequest",
              "requestFullType": "signrpc.MuSig2CleanupRequest",
              "requestStreaming": false,
              "responseType": "MuSig2CleanupResponse",
              "responseLongType": "MuSig2CleanupResponse",
              "responseFullType": "signrpc.MuSig2CleanupResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/signer/musig2/cleanup",
                  "details": {
                    "description": "NOTE: The MuSig2 BIP is not final yet and therefore this API must be\nconsidered to be HIGHLY EXPERIMENTAL and subject to change in upcoming\nreleases. Backward compatibility is not guaranteed!",
                    "operationId": "Signer_MuSig2Cleanup",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/signrpcMuSig2CleanupRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcMuSig2CleanupResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "MuSig2Cleanup (experimental!) allows a caller to clean up a session early in\ncases where it's obvious that the signing session won't succeed and the\nresources can be released.",
                    "tags": [
                      "Signer"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "verrpc/verrpc.proto",
      "description": "",
      "package": "verrpc",
      "hasEnums": false,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [],
      "extensions": [],
      "messages": [
        {
          "name": "Version",
          "longName": "Version",
          "fullName": "verrpc.Version",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "commit",
              "description": "A verbose description of the daemon's commit.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "commit_hash",
              "description": "The SHA1 commit hash that the daemon is compiled with.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "version",
              "description": "The semantic version.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "app_major",
              "description": "The major application version.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "app_minor",
              "description": "The minor application version.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "app_patch",
              "description": "The application patch number.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "app_pre_release",
              "description": "The application pre-release modifier, possibly empty.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "build_tags",
              "description": "The list of build tags that were supplied during compilation.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "go_version",
              "description": "The version of go that compiled the executable.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "VersionRequest",
          "longName": "VersionRequest",
          "fullName": "verrpc.VersionRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        }
      ],
      "services": [
        {
          "name": "Versioner",
          "longName": "Versioner",
          "fullName": "verrpc.Versioner",
          "description": "Versioner is a service that can be used to get information about the version\nand build information of the running daemon.",
          "methods": [
            {
              "name": "GetVersion",
              "description": "lncli: `version`\nGetVersion returns the current version and build information of the running\ndaemon.",
              "requestType": "VersionRequest",
              "requestLongType": "VersionRequest",
              "requestFullType": "verrpc.VersionRequest",
              "requestStreaming": false,
              "responseType": "Version",
              "responseLongType": "Version",
              "responseFullType": "verrpc.Version",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/versioner/version",
                  "details": {
                    "operationId": "Versioner_GetVersion",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/verrpcVersion"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `version`\nGetVersion returns the current version and build information of the running\ndaemon.",
                    "tags": [
                      "Versioner"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "walletunlocker.proto",
      "description": "",
      "package": "lnrpc",
      "hasEnums": false,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [],
      "extensions": [],
      "messages": [
        {
          "name": "ChangePasswordRequest",
          "longName": "ChangePasswordRequest",
          "fullName": "lnrpc.ChangePasswordRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "current_password",
              "description": "current_password should be the current valid passphrase used to unlock the\ndaemon. When using REST, this field must be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "new_password",
              "description": "new_password should be the new passphrase that will be needed to unlock the\ndaemon. When using REST, this field must be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "stateless_init",
              "description": "stateless_init is an optional argument instructing the daemon NOT to create\nany *.macaroon files in its filesystem. If this parameter is set, then the\nadmin macaroon returned in the response MUST be stored by the caller of the\nRPC as otherwise all access to the daemon will be lost!",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "new_macaroon_root_key",
              "description": "new_macaroon_root_key is an optional argument instructing the daemon to\nrotate the macaroon root key when set to true. This will invalidate all\npreviously generated macaroons.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChangePasswordResponse",
          "longName": "ChangePasswordResponse",
          "fullName": "lnrpc.ChangePasswordResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "admin_macaroon",
              "description": "The binary serialized admin macaroon that can be used to access the daemon\nafter rotating the macaroon root key. If both the stateless_init and\nnew_macaroon_root_key parameter were set to true, this is the ONLY copy of\nthe macaroon that was created from the new root key and MUST be stored\nsafely by the caller. Otherwise a copy of this macaroon is also persisted on\ndisk by the daemon, together with other macaroon files.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "GenSeedRequest",
          "longName": "GenSeedRequest",
          "fullName": "lnrpc.GenSeedRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "aezeed_passphrase",
              "description": "aezeed_passphrase is an optional user provided passphrase that will be used\nto encrypt the generated aezeed cipher seed. When using REST, this field\nmust be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "seed_entropy",
              "description": "seed_entropy is an optional 16-bytes generated via CSPRNG. If not\nspecified, then a fresh set of randomness will be used to create the seed.\nWhen using REST, this field must be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "GenSeedResponse",
          "longName": "GenSeedResponse",
          "fullName": "lnrpc.GenSeedResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "cipher_seed_mnemonic",
              "description": "cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed\ncipher seed obtained by the user. This field is optional, as if not\nprovided, then the daemon will generate a new cipher seed for the user.\nOtherwise, then the daemon will attempt to recover the wallet state linked\nto this cipher seed.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "enciphered_seed",
              "description": "enciphered_seed are the raw aezeed cipher seed bytes. This is the raw\ncipher text before run through our mnemonic encoding scheme.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "InitWalletRequest",
          "longName": "InitWalletRequest",
          "fullName": "lnrpc.InitWalletRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "wallet_password",
              "description": "wallet_password is the passphrase that should be used to encrypt the\nwallet. This MUST be at least 8 chars in length. After creation, this\npassword is required to unlock the daemon. When using REST, this field\nmust be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "cipher_seed_mnemonic",
              "description": "cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed\ncipher seed obtained by the user. This may have been generated by the\nGenSeed method, or be an existing seed.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "aezeed_passphrase",
              "description": "aezeed_passphrase is an optional user provided passphrase that will be used\nto encrypt the generated aezeed cipher seed. When using REST, this field\nmust be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "recovery_window",
              "description": "recovery_window is an optional argument specifying the address lookahead\nwhen restoring a wallet seed. The recovery window applies to each\nindividual branch of the BIP44 derivation paths. Supplying a recovery\nwindow of zero indicates that no addresses should be recovered, such after\nthe first initialization of the wallet.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "channel_backups",
              "description": "channel_backups is an optional argument that allows clients to recover the\nsettled funds within a set of channels. This should be populated if the\nuser was unable to close out all channels and sweep funds before partial or\ntotal data loss occurred. If specified, then after on-chain recovery of\nfunds, lnd begin to carry out the data loss recovery protocol in order to\nrecover the funds in each channel from a remote force closed transaction.",
              "label": "",
              "type": "ChanBackupSnapshot",
              "longType": "ChanBackupSnapshot",
              "fullType": "lnrpc.ChanBackupSnapshot",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "stateless_init",
              "description": "stateless_init is an optional argument instructing the daemon NOT to create\nany *.macaroon files in its filesystem. If this parameter is set, then the\nadmin macaroon returned in the response MUST be stored by the caller of the\nRPC as otherwise all access to the daemon will be lost!",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "extended_master_key",
              "description": "extended_master_key is an alternative to specifying cipher_seed_mnemonic and\naezeed_passphrase. Instead of deriving the master root key from the entropy\nof an aezeed cipher seed, the given extended master root key is used\ndirectly as the wallet's master key. This allows users to import/use a\nmaster key from another wallet. When doing so, lnd still uses its default\nSegWit only (BIP49/84) derivation paths and funds from custom/non-default\nderivation paths will not automatically appear in the on-chain wallet. Using\nan 'xprv' instead of an aezeed also has the disadvantage that the wallet's\nbirthday is not known as that is an information that's only encoded in the\naezeed, not the xprv. Therefore a birthday needs to be specified in\nextended_master_key_birthday_timestamp or a \"safe\" default value will be\nused.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "extended_master_key_birthday_timestamp",
              "description": "extended_master_key_birthday_timestamp is the optional unix timestamp in\nseconds to use as the wallet's birthday when using an extended master key\nto restore the wallet. lnd will only start scanning for funds in blocks that\nare after the birthday which can speed up the process significantly. If the\nbirthday is not known, this should be left at its default value of 0 in\nwhich case lnd will start scanning from the first SegWit block (481824 on\nmainnet).",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "watch_only",
              "description": "watch_only is the third option of initializing a wallet: by importing\naccount xpubs only and therefore creating a watch-only wallet that does not\ncontain any private keys. That means the wallet won't be able to sign for\nany of the keys and _needs_ to be run with a remote signer that has the\ncorresponding private keys and can serve signing RPC requests.",
              "label": "",
              "type": "WatchOnly",
              "longType": "WatchOnly",
              "fullType": "lnrpc.WatchOnly",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "InitWalletResponse",
          "longName": "InitWalletResponse",
          "fullName": "lnrpc.InitWalletResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "admin_macaroon",
              "description": "The binary serialized admin macaroon that can be used to access the daemon\nafter creating the wallet. If the stateless_init parameter was set to true,\nthis is the ONLY copy of the macaroon and MUST be stored safely by the\ncaller. Otherwise a copy of this macaroon is also persisted on disk by the\ndaemon, together with other macaroon files.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "UnlockWalletRequest",
          "longName": "UnlockWalletRequest",
          "fullName": "lnrpc.UnlockWalletRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "wallet_password",
              "description": "wallet_password should be the current valid passphrase for the daemon. This\nwill be required to decrypt on-disk material that the daemon requires to\nfunction properly. When using REST, this field must be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "recovery_window",
              "description": "recovery_window is an optional argument specifying the address lookahead\nwhen restoring a wallet seed. The recovery window applies to each\nindividual branch of the BIP44 derivation paths. Supplying a recovery\nwindow of zero indicates that no addresses should be recovered, such after\nthe first initialization of the wallet.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "channel_backups",
              "description": "channel_backups is an optional argument that allows clients to recover the\nsettled funds within a set of channels. This should be populated if the\nuser was unable to close out all channels and sweep funds before partial or\ntotal data loss occurred. If specified, then after on-chain recovery of\nfunds, lnd begin to carry out the data loss recovery protocol in order to\nrecover the funds in each channel from a remote force closed transaction.",
              "label": "",
              "type": "ChanBackupSnapshot",
              "longType": "ChanBackupSnapshot",
              "fullType": "lnrpc.ChanBackupSnapshot",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "stateless_init",
              "description": "stateless_init is an optional argument instructing the daemon NOT to create\nany *.macaroon files in its file system.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "UnlockWalletResponse",
          "longName": "UnlockWalletResponse",
          "fullName": "lnrpc.UnlockWalletResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "WatchOnly",
          "longName": "WatchOnly",
          "fullName": "lnrpc.WatchOnly",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "master_key_birthday_timestamp",
              "description": "The unix timestamp in seconds of when the master key was created. lnd will\nonly start scanning for funds in blocks that are after the birthday which\ncan speed up the process significantly. If the birthday is not known, this\nshould be left at its default value of 0 in which case lnd will start\nscanning from the first SegWit block (481824 on mainnet).",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "master_key_fingerprint",
              "description": "The fingerprint of the root key (also known as the key with derivation path\nm/) from which the account public keys were derived from. This may be\nrequired by some hardware wallets for proper identification and signing. The\nbytes must be in big-endian order.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "accounts",
              "description": "The list of accounts to import. There _must_ be an account for all of lnd's\nmain key scopes: BIP49/BIP84 (m/49'/0'/0', m/84'/0'/0', note that the\ncoin type is always 0, even for testnet/regtest) and lnd's internal key\nscope (m/1017'/\u003ccoin_type\u003e'/\u003caccount\u003e'), where account is the key family as\ndefined in `keychain/derivation.go` (currently indices 0 to 9).",
              "label": "repeated",
              "type": "WatchOnlyAccount",
              "longType": "WatchOnlyAccount",
              "fullType": "lnrpc.WatchOnlyAccount",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "WatchOnlyAccount",
          "longName": "WatchOnlyAccount",
          "fullName": "lnrpc.WatchOnlyAccount",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "purpose",
              "description": "Purpose is the first number in the derivation path, must be either 49, 84\nor 1017.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "coin_type",
              "description": "Coin type is the second number in the derivation path, this is _always_ 0\nfor purposes 49 and 84. It only needs to be set to 1 for purpose 1017 on\ntestnet or regtest.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "account",
              "description": "Account is the third number in the derivation path. For purposes 49 and 84\nat least the default account (index 0) needs to be created but optional\nadditional accounts are allowed. For purpose 1017 there needs to be exactly\none account for each of the key families defined in `keychain/derivation.go`\n(currently indices 0 to 9)",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "xpub",
              "description": "The extended public key at depth 3 for the given account.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": [
        {
          "name": "WalletUnlocker",
          "longName": "WalletUnlocker",
          "fullName": "lnrpc.WalletUnlocker",
          "description": "WalletUnlocker is a service that is used to set up a wallet password for\nlnd at first startup, and unlock a previously set up wallet.",
          "methods": [
            {
              "name": "GenSeed",
              "description": "GenSeed is the first method that should be used to instantiate a new lnd\ninstance. This method allows a caller to generate a new aezeed cipher seed\ngiven an optional passphrase. If provided, the passphrase will be necessary\nto decrypt the cipherseed to expose the internal wallet seed.\n\nOnce the cipherseed is obtained and verified by the user, the InitWallet\nmethod should be used to commit the newly generated seed, and create the\nwallet.",
              "requestType": "GenSeedRequest",
              "requestLongType": "GenSeedRequest",
              "requestFullType": "lnrpc.GenSeedRequest",
              "requestStreaming": false,
              "responseType": "GenSeedResponse",
              "responseLongType": "GenSeedResponse",
              "responseFullType": "lnrpc.GenSeedResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/genseed",
                  "details": {
                    "description": "Once the cipherseed is obtained and verified by the user, the InitWallet\nmethod should be used to commit the newly generated seed, and create the\nwallet.",
                    "operationId": "WalletUnlocker_GenSeed",
                    "parameters": [
                      {
                        "description": "aezeed_passphrase is an optional user provided passphrase that will be used\nto encrypt the generated aezeed cipher seed. When using REST, this field\nmust be encoded as base64.",
                        "format": "byte",
                        "in": "query",
                        "name": "aezeed_passphrase",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "seed_entropy is an optional 16-bytes generated via CSPRNG. If not\nspecified, then a fresh set of randomness will be used to create the seed.\nWhen using REST, this field must be encoded as base64.",
                        "format": "byte",
                        "in": "query",
                        "name": "seed_entropy",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcGenSeedResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "GenSeed is the first method that should be used to instantiate a new lnd\ninstance. This method allows a caller to generate a new aezeed cipher seed\ngiven an optional passphrase. If provided, the passphrase will be necessary\nto decrypt the cipherseed to expose the internal wallet seed.",
                    "tags": [
                      "WalletUnlocker"
                    ]
                  }
                }
              ]
            },
            {
              "name": "InitWallet",
              "description": "InitWallet is used when lnd is starting up for the first time to fully\ninitialize the daemon and its internal wallet. At the very least a wallet\npassword must be provided. This will be used to encrypt sensitive material\non disk.\n\nIn the case of a recovery scenario, the user can also specify their aezeed\nmnemonic and passphrase. If set, then the daemon will use this prior state\nto initialize its internal wallet.\n\nAlternatively, this can be used along with the GenSeed RPC to obtain a\nseed, then present it to the user. Once it has been verified by the user,\nthe seed can be fed into this RPC in order to commit the new wallet.",
              "requestType": "InitWalletRequest",
              "requestLongType": "InitWalletRequest",
              "requestFullType": "lnrpc.InitWalletRequest",
              "requestStreaming": false,
              "responseType": "InitWalletResponse",
              "responseLongType": "InitWalletResponse",
              "responseFullType": "lnrpc.InitWalletResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/initwallet",
                  "details": {
                    "description": "In the case of a recovery scenario, the user can also specify their aezeed\nmnemonic and passphrase. If set, then the daemon will use this prior state\nto initialize its internal wallet.\n\nAlternatively, this can be used along with the GenSeed RPC to obtain a\nseed, then present it to the user. Once it has been verified by the user,\nthe seed can be fed into this RPC in order to commit the new wallet.",
                    "operationId": "WalletUnlocker_InitWallet",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcInitWalletRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcInitWalletResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "InitWallet is used when lnd is starting up for the first time to fully\ninitialize the daemon and its internal wallet. At the very least a wallet\npassword must be provided. This will be used to encrypt sensitive material\non disk.",
                    "tags": [
                      "WalletUnlocker"
                    ]
                  }
                }
              ]
            },
            {
              "name": "UnlockWallet",
              "description": "lncli: `unlock`\nUnlockWallet is used at startup of lnd to provide a password to unlock\nthe wallet database.",
              "requestType": "UnlockWalletRequest",
              "requestLongType": "UnlockWalletRequest",
              "requestFullType": "lnrpc.UnlockWalletRequest",
              "requestStreaming": false,
              "responseType": "UnlockWalletResponse",
              "responseLongType": "UnlockWalletResponse",
              "responseFullType": "lnrpc.UnlockWalletResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/unlockwallet",
                  "details": {
                    "operationId": "WalletUnlocker_UnlockWallet",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcUnlockWalletRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcUnlockWalletResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `unlock`\nUnlockWallet is used at startup of lnd to provide a password to unlock\nthe wallet database.",
                    "tags": [
                      "WalletUnlocker"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ChangePassword",
              "description": "lncli: `changepassword`\nChangePassword changes the password of the encrypted wallet. This will\nautomatically unlock the wallet database if successful.",
              "requestType": "ChangePasswordRequest",
              "requestLongType": "ChangePasswordRequest",
              "requestFullType": "lnrpc.ChangePasswordRequest",
              "requestStreaming": false,
              "responseType": "ChangePasswordResponse",
              "responseLongType": "ChangePasswordResponse",
              "responseFullType": "lnrpc.ChangePasswordResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/changepassword",
                  "details": {
                    "operationId": "WalletUnlocker_ChangePassword",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcChangePasswordRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcChangePasswordResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `changepassword`\nChangePassword changes the password of the encrypted wallet. This will\nautomatically unlock the wallet database if successful.",
                    "tags": [
                      "WalletUnlocker"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "walletrpc/walletkit.proto",
      "description": "",
      "package": "walletrpc",
      "hasEnums": true,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [
        {
          "name": "AddressType",
          "longName": "AddressType",
          "fullName": "walletrpc.AddressType",
          "description": "",
          "values": [
            {
              "name": "UNKNOWN",
              "number": "0",
              "description": ""
            },
            {
              "name": "WITNESS_PUBKEY_HASH",
              "number": "1",
              "description": ""
            },
            {
              "name": "NESTED_WITNESS_PUBKEY_HASH",
              "number": "2",
              "description": ""
            },
            {
              "name": "HYBRID_NESTED_WITNESS_PUBKEY_HASH",
              "number": "3",
              "description": ""
            },
            {
              "name": "TAPROOT_PUBKEY",
              "number": "4",
              "description": ""
            }
          ]
        },
        {
          "name": "WitnessType",
          "longName": "WitnessType",
          "fullName": "walletrpc.WitnessType",
          "description": "",
          "values": [
            {
              "name": "UNKNOWN_WITNESS",
              "number": "0",
              "description": ""
            },
            {
              "name": "COMMITMENT_TIME_LOCK",
              "number": "1",
              "description": "A witness that allows us to spend the output of a commitment transaction\nafter a relative lock-time lockout."
            },
            {
              "name": "COMMITMENT_NO_DELAY",
              "number": "2",
              "description": "A witness that allows us to spend a settled no-delay output immediately on a\ncounterparty's commitment transaction."
            },
            {
              "name": "COMMITMENT_REVOKE",
              "number": "3",
              "description": "A witness that allows us to sweep the settled output of a malicious\ncounterparty's who broadcasts a revoked commitment transaction."
            },
            {
              "name": "HTLC_OFFERED_REVOKE",
              "number": "4",
              "description": "A witness that allows us to sweep an HTLC which we offered to the remote\nparty in the case that they broadcast a revoked commitment state."
            },
            {
              "name": "HTLC_ACCEPTED_REVOKE",
              "number": "5",
              "description": "A witness that allows us to sweep an HTLC output sent to us in the case that\nthe remote party broadcasts a revoked commitment state."
            },
            {
              "name": "HTLC_OFFERED_TIMEOUT_SECOND_LEVEL",
              "number": "6",
              "description": "A witness that allows us to sweep an HTLC output that we extended to a\nparty, but was never fulfilled.  This HTLC output isn't directly on the\ncommitment transaction, but is the result of a confirmed second-level HTLC\ntransaction. As a result, we can only spend this after a CSV delay."
            },
            {
              "name": "HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL",
              "number": "7",
              "description": "A witness that allows us to sweep an HTLC output that was offered to us, and\nfor which we have a payment preimage. This HTLC output isn't directly on our\ncommitment transaction, but is the result of confirmed second-level HTLC\ntransaction. As a result, we can only spend this after a CSV delay."
            },
            {
              "name": "HTLC_OFFERED_REMOTE_TIMEOUT",
              "number": "8",
              "description": "A witness that allows us to sweep an HTLC that we offered to the remote\nparty which lies in the commitment transaction of the remote party. We can\nspend this output after the absolute CLTV timeout of the HTLC as passed."
            },
            {
              "name": "HTLC_ACCEPTED_REMOTE_SUCCESS",
              "number": "9",
              "description": "A witness that allows us to sweep an HTLC that was offered to us by the\nremote party. We use this witness in the case that the remote party goes to\nchain, and we know the pre-image to the HTLC. We can sweep this without any\nadditional timeout."
            },
            {
              "name": "HTLC_SECOND_LEVEL_REVOKE",
              "number": "10",
              "description": "A witness that allows us to sweep an HTLC from the remote party's commitment\ntransaction in the case that the broadcast a revoked commitment, but then\nalso immediately attempt to go to the second level to claim the HTLC."
            },
            {
              "name": "WITNESS_KEY_HASH",
              "number": "11",
              "description": "A witness type that allows us to spend a regular p2wkh output that's sent to\nan output which is under complete control of the backing wallet."
            },
            {
              "name": "NESTED_WITNESS_KEY_HASH",
              "number": "12",
              "description": "A witness type that allows us to sweep an output that sends to a nested P2SH\nscript that pays to a key solely under our control."
            },
            {
              "name": "COMMITMENT_ANCHOR",
              "number": "13",
              "description": "A witness type that allows us to spend our anchor on the commitment\ntransaction."
            }
          ]
        }
      ],
      "extensions": [],
      "messages": [
        {
          "name": "Account",
          "longName": "Account",
          "fullName": "walletrpc.Account",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "name",
              "description": "The name used to identify the account.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "address_type",
              "description": "The type of addresses the account supports.\nAddressType                       | External Branch | Internal Branch\n---------------------------------------------------------------------\nWITNESS_PUBKEY_HASH               | P2WPKH          | P2WPKH\nNESTED_WITNESS_PUBKEY_HASH        | NP2WPKH         | NP2WPKH\nHYBRID_NESTED_WITNESS_PUBKEY_HASH | NP2WPKH         | P2WPKH",
              "label": "",
              "type": "AddressType",
              "longType": "AddressType",
              "fullType": "walletrpc.AddressType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "extended_public_key",
              "description": "The public key backing the account that all keys are derived from\nrepresented as an extended key. This will always be empty for the default\nimported account in which single public keys are imported into.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "master_key_fingerprint",
              "description": "The fingerprint of the root key from which the account public key was\nderived from. This will always be zero for the default imported account in\nwhich single public keys are imported into. The bytes are in big-endian\norder.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "derivation_path",
              "description": "The derivation path corresponding to the account public key. This will\nalways be empty for the default imported account in which single public keys\nare imported into.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "external_key_count",
              "description": "The number of keys derived from the external branch of the account public\nkey. This will always be zero for the default imported account in which\nsingle public keys are imported into.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "internal_key_count",
              "description": "The number of keys derived from the internal branch of the account public\nkey. This will always be zero for the default imported account in which\nsingle public keys are imported into.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "watch_only",
              "description": "Whether the wallet stores private keys for the account.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AddrRequest",
          "longName": "AddrRequest",
          "fullName": "walletrpc.AddrRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "account",
              "description": "The name of the account to retrieve the next address of. If empty, the\ndefault wallet account is used.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "type",
              "description": "The type of address to derive.",
              "label": "",
              "type": "AddressType",
              "longType": "AddressType",
              "fullType": "walletrpc.AddressType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "change",
              "description": "Whether a change address should be derived.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AddrResponse",
          "longName": "AddrResponse",
          "fullName": "walletrpc.AddrResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "addr",
              "description": "The address encoded using a bech32 format.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "BumpFeeRequest",
          "longName": "BumpFeeRequest",
          "fullName": "walletrpc.BumpFeeRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "outpoint",
              "description": "The input we're attempting to bump the fee of.",
              "label": "",
              "type": "OutPoint",
              "longType": "lnrpc.OutPoint",
              "fullType": "lnrpc.OutPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "target_conf",
              "description": "The target number of blocks that the input should be spent within.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_per_byte",
              "description": "Deprecated, use sat_per_vbyte.\nThe fee rate, expressed in sat/vbyte, that should be used to spend the input\nwith.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "force",
              "description": "Whether this input must be force-swept. This means that it is swept even\nif it has a negative yield.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_per_vbyte",
              "description": "The fee rate, expressed in sat/vbyte, that should be used to spend the input\nwith.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "BumpFeeResponse",
          "longName": "BumpFeeResponse",
          "fullName": "walletrpc.BumpFeeResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "EstimateFeeRequest",
          "longName": "EstimateFeeRequest",
          "fullName": "walletrpc.EstimateFeeRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "conf_target",
              "description": "The number of confirmations to shoot for when estimating the fee.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "EstimateFeeResponse",
          "longName": "EstimateFeeResponse",
          "fullName": "walletrpc.EstimateFeeResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "sat_per_kw",
              "description": "The amount of satoshis per kw that should be used in order to reach the\nconfirmation target in the request.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FinalizePsbtRequest",
          "longName": "FinalizePsbtRequest",
          "fullName": "walletrpc.FinalizePsbtRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "funded_psbt",
              "description": "A PSBT that should be signed and finalized. The PSBT must contain all\nrequired inputs, outputs, UTXO data and partial signatures of all other\nsigners.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "account",
              "description": "The name of the account to finalize the PSBT with. If empty, the default\nwallet account is used.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FinalizePsbtResponse",
          "longName": "FinalizePsbtResponse",
          "fullName": "walletrpc.FinalizePsbtResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "signed_psbt",
              "description": "The fully signed and finalized transaction in PSBT format.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "raw_final_tx",
              "description": "The fully signed and finalized transaction in the raw wire format.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FundPsbtRequest",
          "longName": "FundPsbtRequest",
          "fullName": "walletrpc.FundPsbtRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "psbt",
              "description": "Use an existing PSBT packet as the template for the funded PSBT.\n\nThe packet must contain at least one non-dust output. If one or more\ninputs are specified, no coin selection is performed. In that case every\ninput must be an UTXO known to the wallet that has not been locked\nbefore. The sum of all inputs must be sufficiently greater than the sum\nof all outputs to pay a miner fee with the specified fee rate. A change\noutput is added to the PSBT if necessary.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "template",
              "defaultValue": ""
            },
            {
              "name": "raw",
              "description": "Use the outputs and optional inputs from this raw template.",
              "label": "",
              "type": "TxTemplate",
              "longType": "TxTemplate",
              "fullType": "walletrpc.TxTemplate",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "template",
              "defaultValue": ""
            },
            {
              "name": "target_conf",
              "description": "The target number of blocks that the transaction should be confirmed in.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "fees",
              "defaultValue": ""
            },
            {
              "name": "sat_per_vbyte",
              "description": "The fee rate, expressed in sat/vbyte, that should be used to spend the\ninput with.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "fees",
              "defaultValue": ""
            },
            {
              "name": "account",
              "description": "The name of the account to fund the PSBT with. If empty, the default wallet\naccount is used.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_confs",
              "description": "The minimum number of confirmations each one of your outputs used for\nthe transaction must satisfy.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "spend_unconfirmed",
              "description": "Whether unconfirmed outputs should be used as inputs for the transaction.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FundPsbtResponse",
          "longName": "FundPsbtResponse",
          "fullName": "walletrpc.FundPsbtResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "funded_psbt",
              "description": "The funded but not yet signed PSBT packet.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "change_output_index",
              "description": "The index of the added change output or -1 if no change was left over.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "locked_utxos",
              "description": "The list of lock leases that were acquired for the inputs in the funded PSBT\npacket.",
              "label": "repeated",
              "type": "UtxoLease",
              "longType": "UtxoLease",
              "fullType": "walletrpc.UtxoLease",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ImportAccountRequest",
          "longName": "ImportAccountRequest",
          "fullName": "walletrpc.ImportAccountRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "name",
              "description": "A name to identify the account with.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "extended_public_key",
              "description": "A public key that corresponds to a wallet account represented as an extended\nkey. It must conform to a derivation path of the form\nm/purpose'/coin_type'/account'.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "master_key_fingerprint",
              "description": "The fingerprint of the root key (also known as the key with derivation path\nm/) from which the account public key was derived from. This may be required\nby some hardware wallets for proper identification and signing. The bytes\nmust be in big-endian order.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "address_type",
              "description": "An address type is only required when the extended account public key has a\nlegacy version (xpub, tpub, etc.), such that the wallet cannot detect what\naddress scheme it belongs to.",
              "label": "",
              "type": "AddressType",
              "longType": "AddressType",
              "fullType": "walletrpc.AddressType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dry_run",
              "description": "Whether a dry run should be attempted when importing the account. This\nserves as a way to confirm whether the account is being imported correctly\nby returning the first N addresses for the external and internal branches of\nthe account. If these addresses match as expected, then it should be safe to\nimport the account as is.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ImportAccountResponse",
          "longName": "ImportAccountResponse",
          "fullName": "walletrpc.ImportAccountResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "account",
              "description": "The details of the imported account.",
              "label": "",
              "type": "Account",
              "longType": "Account",
              "fullType": "walletrpc.Account",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dry_run_external_addrs",
              "description": "The first N addresses that belong to the external branch of the account.\nThe external branch is typically used for external non-change addresses.\nThese are only returned if a dry run was specified within the request.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dry_run_internal_addrs",
              "description": "The first N addresses that belong to the internal branch of the account.\nThe internal branch is typically used for change addresses. These are only\nreturned if a dry run was specified within the request.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ImportPublicKeyRequest",
          "longName": "ImportPublicKeyRequest",
          "fullName": "walletrpc.ImportPublicKeyRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "public_key",
              "description": "A compressed public key represented as raw bytes.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "address_type",
              "description": "The type of address that will be generated from the public key.",
              "label": "",
              "type": "AddressType",
              "longType": "AddressType",
              "fullType": "walletrpc.AddressType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ImportPublicKeyResponse",
          "longName": "ImportPublicKeyResponse",
          "fullName": "walletrpc.ImportPublicKeyResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "KeyReq",
          "longName": "KeyReq",
          "fullName": "walletrpc.KeyReq",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key_finger_print",
              "description": "Is the key finger print of the root pubkey that this request is targeting.\nThis allows the WalletKit to possibly serve out keys for multiple HD chains\nvia public derivation.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "key_family",
              "description": "The target key family to derive a key from. In other contexts, this is\nknown as the \"account\".",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "LabelTransactionRequest",
          "longName": "LabelTransactionRequest",
          "fullName": "walletrpc.LabelTransactionRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "txid",
              "description": "The txid of the transaction to label.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "label",
              "description": "The label to add to the transaction, limited to 500 characters.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "overwrite",
              "description": "Whether to overwrite the existing label, if it is present.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "LabelTransactionResponse",
          "longName": "LabelTransactionResponse",
          "fullName": "walletrpc.LabelTransactionResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "LeaseOutputRequest",
          "longName": "LeaseOutputRequest",
          "fullName": "walletrpc.LeaseOutputRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "id",
              "description": "An ID of 32 random bytes that must be unique for each distinct application\nusing this RPC which will be used to bound the output lease to.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outpoint",
              "description": "The identifying outpoint of the output being leased.",
              "label": "",
              "type": "OutPoint",
              "longType": "lnrpc.OutPoint",
              "fullType": "lnrpc.OutPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "expiration_seconds",
              "description": "The time in seconds before the lock expires. If set to zero, the default\nlock duration is used.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "LeaseOutputResponse",
          "longName": "LeaseOutputResponse",
          "fullName": "walletrpc.LeaseOutputResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "expiration",
              "description": "The absolute expiration of the output lease represented as a unix timestamp.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListAccountsRequest",
          "longName": "ListAccountsRequest",
          "fullName": "walletrpc.ListAccountsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "name",
              "description": "An optional filter to only return accounts matching this name.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "address_type",
              "description": "An optional filter to only return accounts matching this address type.",
              "label": "",
              "type": "AddressType",
              "longType": "AddressType",
              "fullType": "walletrpc.AddressType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListAccountsResponse",
          "longName": "ListAccountsResponse",
          "fullName": "walletrpc.ListAccountsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "accounts",
              "description": "",
              "label": "repeated",
              "type": "Account",
              "longType": "Account",
              "fullType": "walletrpc.Account",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListLeasesRequest",
          "longName": "ListLeasesRequest",
          "fullName": "walletrpc.ListLeasesRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "ListLeasesResponse",
          "longName": "ListLeasesResponse",
          "fullName": "walletrpc.ListLeasesResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "locked_utxos",
              "description": "The list of currently leased utxos.",
              "label": "repeated",
              "type": "UtxoLease",
              "longType": "UtxoLease",
              "fullType": "walletrpc.UtxoLease",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListSweepsRequest",
          "longName": "ListSweepsRequest",
          "fullName": "walletrpc.ListSweepsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "verbose",
              "description": "Retrieve the full sweep transaction details. If false, only the sweep txids\nwill be returned. Note that some sweeps that LND publishes will have been\nreplaced-by-fee, so will not be included in this output.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListSweepsResponse",
          "longName": "ListSweepsResponse",
          "fullName": "walletrpc.ListSweepsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "transaction_details",
              "description": "",
              "label": "",
              "type": "TransactionDetails",
              "longType": "lnrpc.TransactionDetails",
              "fullType": "lnrpc.TransactionDetails",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "sweeps",
              "defaultValue": ""
            },
            {
              "name": "transaction_ids",
              "description": "",
              "label": "",
              "type": "TransactionIDs",
              "longType": "ListSweepsResponse.TransactionIDs",
              "fullType": "walletrpc.ListSweepsResponse.TransactionIDs",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "sweeps",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "TransactionIDs",
          "longName": "ListSweepsResponse.TransactionIDs",
          "fullName": "walletrpc.ListSweepsResponse.TransactionIDs",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "transaction_ids",
              "description": "Reversed, hex-encoded string representing the transaction ids of the\nsweeps that our node has broadcast. Note that these transactions may\nnot have confirmed yet, we record sweeps on broadcast, not confirmation.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListUnspentRequest",
          "longName": "ListUnspentRequest",
          "fullName": "walletrpc.ListUnspentRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "min_confs",
              "description": "The minimum number of confirmations to be included.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_confs",
              "description": "The maximum number of confirmations to be included.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "account",
              "description": "An optional filter to only include outputs belonging to an account.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "unconfirmed_only",
              "description": "When min_confs and max_confs are zero, setting false implicitly\noverrides max_confs to be MaxInt32, otherwise max_confs remains\nzero. An error is returned if the value is true and both min_confs\nand max_confs are non-zero. (default: false)",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListUnspentResponse",
          "longName": "ListUnspentResponse",
          "fullName": "walletrpc.ListUnspentResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "utxos",
              "description": "A list of utxos satisfying the specified number of confirmations.",
              "label": "repeated",
              "type": "Utxo",
              "longType": "lnrpc.Utxo",
              "fullType": "lnrpc.Utxo",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PendingSweep",
          "longName": "PendingSweep",
          "fullName": "walletrpc.PendingSweep",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "outpoint",
              "description": "The outpoint of the output we're attempting to sweep.",
              "label": "",
              "type": "OutPoint",
              "longType": "lnrpc.OutPoint",
              "fullType": "lnrpc.OutPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "witness_type",
              "description": "The witness type of the output we're attempting to sweep.",
              "label": "",
              "type": "WitnessType",
              "longType": "WitnessType",
              "fullType": "walletrpc.WitnessType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amount_sat",
              "description": "The value of the output we're attempting to sweep.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_per_byte",
              "description": "Deprecated, use sat_per_vbyte.\nThe fee rate we'll use to sweep the output, expressed in sat/vbyte. The fee\nrate is only determined once a sweeping transaction for the output is\ncreated, so it's possible for this to be 0 before this.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "broadcast_attempts",
              "description": "The number of broadcast attempts we've made to sweep the output.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "next_broadcast_height",
              "description": "The next height of the chain at which we'll attempt to broadcast the\nsweep transaction of the output.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "requested_conf_target",
              "description": "The requested confirmation target for this output.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "requested_sat_per_byte",
              "description": "Deprecated, use requested_sat_per_vbyte.\nThe requested fee rate, expressed in sat/vbyte, for this output.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "sat_per_vbyte",
              "description": "The fee rate we'll use to sweep the output, expressed in sat/vbyte. The fee\nrate is only determined once a sweeping transaction for the output is\ncreated, so it's possible for this to be 0 before this.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "requested_sat_per_vbyte",
              "description": "The requested fee rate, expressed in sat/vbyte, for this output.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "force",
              "description": "Whether this input must be force-swept. This means that it is swept even\nif it has a negative yield.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PendingSweepsRequest",
          "longName": "PendingSweepsRequest",
          "fullName": "walletrpc.PendingSweepsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "PendingSweepsResponse",
          "longName": "PendingSweepsResponse",
          "fullName": "walletrpc.PendingSweepsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pending_sweeps",
              "description": "The set of outputs currently being swept by lnd's central batching engine.",
              "label": "repeated",
              "type": "PendingSweep",
              "longType": "PendingSweep",
              "fullType": "walletrpc.PendingSweep",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PublishResponse",
          "longName": "PublishResponse",
          "fullName": "walletrpc.PublishResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "publish_error",
              "description": "If blank, then no error occurred and the transaction was successfully\npublished. If not the empty string, then a string representation of the\nbroadcast error.\n\nTODO(roasbeef): map to a proper enum type",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ReleaseOutputRequest",
          "longName": "ReleaseOutputRequest",
          "fullName": "walletrpc.ReleaseOutputRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "id",
              "description": "The unique ID that was used to lock the output.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outpoint",
              "description": "The identifying outpoint of the output being released.",
              "label": "",
              "type": "OutPoint",
              "longType": "lnrpc.OutPoint",
              "fullType": "lnrpc.OutPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ReleaseOutputResponse",
          "longName": "ReleaseOutputResponse",
          "fullName": "walletrpc.ReleaseOutputResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "RequiredReserveRequest",
          "longName": "RequiredReserveRequest",
          "fullName": "walletrpc.RequiredReserveRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "additional_public_channels",
              "description": "The number of additional channels the user would like to open.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "RequiredReserveResponse",
          "longName": "RequiredReserveResponse",
          "fullName": "walletrpc.RequiredReserveResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "required_reserve",
              "description": "The amount of reserve required.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendOutputsRequest",
          "longName": "SendOutputsRequest",
          "fullName": "walletrpc.SendOutputsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "sat_per_kw",
              "description": "The number of satoshis per kilo weight that should be used when crafting\nthis transaction.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outputs",
              "description": "A slice of the outputs that should be created in the transaction produced.",
              "label": "repeated",
              "type": "TxOut",
              "longType": "signrpc.TxOut",
              "fullType": "signrpc.TxOut",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "label",
              "description": "An optional label for the transaction, limited to 500 characters.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_confs",
              "description": "The minimum number of confirmations each one of your outputs used for\nthe transaction must satisfy.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "spend_unconfirmed",
              "description": "Whether unconfirmed outputs should be used as inputs for the transaction.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendOutputsResponse",
          "longName": "SendOutputsResponse",
          "fullName": "walletrpc.SendOutputsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "raw_tx",
              "description": "The serialized transaction sent out on the network.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SignPsbtRequest",
          "longName": "SignPsbtRequest",
          "fullName": "walletrpc.SignPsbtRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "funded_psbt",
              "description": "The PSBT that should be signed. The PSBT must contain all required inputs,\noutputs, UTXO data and custom fields required to identify the signing key.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SignPsbtResponse",
          "longName": "SignPsbtResponse",
          "fullName": "walletrpc.SignPsbtResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "signed_psbt",
              "description": "The signed transaction in PSBT format.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Transaction",
          "longName": "Transaction",
          "fullName": "walletrpc.Transaction",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "tx_hex",
              "description": "The raw serialized transaction.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "label",
              "description": "An optional label to save with the transaction. Limited to 500 characters.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "TxTemplate",
          "longName": "TxTemplate",
          "fullName": "walletrpc.TxTemplate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "inputs",
              "description": "An optional list of inputs to use. Every input must be an UTXO known to the\nwallet that has not been locked before. The sum of all inputs must be\nsufficiently greater than the sum of all outputs to pay a miner fee with the\nfee rate specified in the parent message.\n\nIf no inputs are specified, coin selection will be performed instead and\ninputs of sufficient value will be added to the resulting PSBT.",
              "label": "repeated",
              "type": "OutPoint",
              "longType": "lnrpc.OutPoint",
              "fullType": "lnrpc.OutPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outputs",
              "description": "A map of all addresses and the amounts to send to in the funded PSBT.",
              "label": "repeated",
              "type": "OutputsEntry",
              "longType": "TxTemplate.OutputsEntry",
              "fullType": "walletrpc.TxTemplate.OutputsEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "OutputsEntry",
          "longName": "TxTemplate.OutputsEntry",
          "fullName": "walletrpc.TxTemplate.OutputsEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "UtxoLease",
          "longName": "UtxoLease",
          "fullName": "walletrpc.UtxoLease",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "id",
              "description": "A 32 byte random ID that identifies the lease.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outpoint",
              "description": "The identifying outpoint of the output being leased.",
              "label": "",
              "type": "OutPoint",
              "longType": "lnrpc.OutPoint",
              "fullType": "lnrpc.OutPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "expiration",
              "description": "The absolute expiration of the output lease represented as a unix timestamp.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pk_script",
              "description": "The public key script of the leased output.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "The value of the leased output in satoshis.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": [
        {
          "name": "WalletKit",
          "longName": "WalletKit",
          "fullName": "walletrpc.WalletKit",
          "description": "WalletKit is a service that gives access to the core functionalities of the\ndaemon's wallet.",
          "methods": [
            {
              "name": "ListUnspent",
              "description": "ListUnspent returns a list of all utxos spendable by the wallet with a\nnumber of confirmations between the specified minimum and maximum. By\ndefault, all utxos are listed. To list only the unconfirmed utxos, set\nthe unconfirmed_only to true.",
              "requestType": "ListUnspentRequest",
              "requestLongType": "ListUnspentRequest",
              "requestFullType": "walletrpc.ListUnspentRequest",
              "requestStreaming": false,
              "responseType": "ListUnspentResponse",
              "responseLongType": "ListUnspentResponse",
              "responseFullType": "walletrpc.ListUnspentResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/utxos",
                  "details": {
                    "operationId": "WalletKit_ListUnspent",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcListUnspentRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcListUnspentResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ListUnspent returns a list of all utxos spendable by the wallet with a\nnumber of confirmations between the specified minimum and maximum. By\ndefault, all utxos are listed. To list only the unconfirmed utxos, set\nthe unconfirmed_only to true.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "LeaseOutput",
              "description": "LeaseOutput locks an output to the given ID, preventing it from being\navailable for any future coin selection attempts. The absolute time of the\nlock's expiration is returned. The expiration of the lock can be extended by\nsuccessive invocations of this RPC. Outputs can be unlocked before their\nexpiration through `ReleaseOutput`.",
              "requestType": "LeaseOutputRequest",
              "requestLongType": "LeaseOutputRequest",
              "requestFullType": "walletrpc.LeaseOutputRequest",
              "requestStreaming": false,
              "responseType": "LeaseOutputResponse",
              "responseLongType": "LeaseOutputResponse",
              "responseFullType": "walletrpc.LeaseOutputResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/utxos/lease",
                  "details": {
                    "operationId": "WalletKit_LeaseOutput",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcLeaseOutputRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcLeaseOutputResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "LeaseOutput locks an output to the given ID, preventing it from being\navailable for any future coin selection attempts. The absolute time of the\nlock's expiration is returned. The expiration of the lock can be extended by\nsuccessive invocations of this RPC. Outputs can be unlocked before their\nexpiration through `ReleaseOutput`.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ReleaseOutput",
              "description": "ReleaseOutput unlocks an output, allowing it to be available for coin\nselection if it remains unspent. The ID should match the one used to\noriginally lock the output.",
              "requestType": "ReleaseOutputRequest",
              "requestLongType": "ReleaseOutputRequest",
              "requestFullType": "walletrpc.ReleaseOutputRequest",
              "requestStreaming": false,
              "responseType": "ReleaseOutputResponse",
              "responseLongType": "ReleaseOutputResponse",
              "responseFullType": "walletrpc.ReleaseOutputResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/utxos/release",
                  "details": {
                    "operationId": "WalletKit_ReleaseOutput",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcReleaseOutputRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcReleaseOutputResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ReleaseOutput unlocks an output, allowing it to be available for coin\nselection if it remains unspent. The ID should match the one used to\noriginally lock the output.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ListLeases",
              "description": "ListLeases lists all currently locked utxos.",
              "requestType": "ListLeasesRequest",
              "requestLongType": "ListLeasesRequest",
              "requestFullType": "walletrpc.ListLeasesRequest",
              "requestStreaming": false,
              "responseType": "ListLeasesResponse",
              "responseLongType": "ListLeasesResponse",
              "responseFullType": "walletrpc.ListLeasesResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/utxos/leases",
                  "details": {
                    "operationId": "WalletKit_ListLeases",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcListLeasesResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ListLeases lists all currently locked utxos.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "DeriveNextKey",
              "description": "DeriveNextKey attempts to derive the *next* key within the key family\n(account in BIP43) specified. This method should return the next external\nchild within this branch.",
              "requestType": "KeyReq",
              "requestLongType": "KeyReq",
              "requestFullType": "walletrpc.KeyReq",
              "requestStreaming": false,
              "responseType": "KeyDescriptor",
              "responseLongType": ".signrpc.KeyDescriptor",
              "responseFullType": "signrpc.KeyDescriptor",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/key/next",
                  "details": {
                    "operationId": "WalletKit_DeriveNextKey",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcKeyReq"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcKeyDescriptor"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "DeriveNextKey attempts to derive the *next* key within the key family\n(account in BIP43) specified. This method should return the next external\nchild within this branch.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "DeriveKey",
              "description": "DeriveKey attempts to derive an arbitrary key specified by the passed\nKeyLocator.",
              "requestType": "KeyLocator",
              "requestLongType": ".signrpc.KeyLocator",
              "requestFullType": "signrpc.KeyLocator",
              "requestStreaming": false,
              "responseType": "KeyDescriptor",
              "responseLongType": ".signrpc.KeyDescriptor",
              "responseFullType": "signrpc.KeyDescriptor",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/key",
                  "details": {
                    "operationId": "WalletKit_DeriveKey",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/signrpcKeyLocator"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/signrpcKeyDescriptor"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "DeriveKey attempts to derive an arbitrary key specified by the passed\nKeyLocator.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "NextAddr",
              "description": "NextAddr returns the next unused address within the wallet.",
              "requestType": "AddrRequest",
              "requestLongType": "AddrRequest",
              "requestFullType": "walletrpc.AddrRequest",
              "requestStreaming": false,
              "responseType": "AddrResponse",
              "responseLongType": "AddrResponse",
              "responseFullType": "walletrpc.AddrResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/address/next",
                  "details": {
                    "operationId": "WalletKit_NextAddr",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcAddrRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcAddrResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "NextAddr returns the next unused address within the wallet.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ListAccounts",
              "description": "ListAccounts retrieves all accounts belonging to the wallet by default. A\nname and key scope filter can be provided to filter through all of the\nwallet accounts and return only those matching.",
              "requestType": "ListAccountsRequest",
              "requestLongType": "ListAccountsRequest",
              "requestFullType": "walletrpc.ListAccountsRequest",
              "requestStreaming": false,
              "responseType": "ListAccountsResponse",
              "responseLongType": "ListAccountsResponse",
              "responseFullType": "walletrpc.ListAccountsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/wallet/accounts",
                  "details": {
                    "operationId": "WalletKit_ListAccounts",
                    "parameters": [
                      {
                        "description": "An optional filter to only return accounts matching this name.",
                        "in": "query",
                        "name": "name",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "default": "UNKNOWN",
                        "description": "An optional filter to only return accounts matching this address type.",
                        "enum": [
                          "UNKNOWN",
                          "WITNESS_PUBKEY_HASH",
                          "NESTED_WITNESS_PUBKEY_HASH",
                          "HYBRID_NESTED_WITNESS_PUBKEY_HASH",
                          "TAPROOT_PUBKEY"
                        ],
                        "in": "query",
                        "name": "address_type",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcListAccountsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ListAccounts retrieves all accounts belonging to the wallet by default. A\nname and key scope filter can be provided to filter through all of the\nwallet accounts and return only those matching.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "RequiredReserve",
              "description": "RequiredReserve returns the minimum amount of satoshis that should be kept\nin the wallet in order to fee bump anchor channels if necessary. The value\nscales with the number of public anchor channels but is capped at a maximum.",
              "requestType": "RequiredReserveRequest",
              "requestLongType": "RequiredReserveRequest",
              "requestFullType": "walletrpc.RequiredReserveRequest",
              "requestStreaming": false,
              "responseType": "RequiredReserveResponse",
              "responseLongType": "RequiredReserveResponse",
              "responseFullType": "walletrpc.RequiredReserveResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/wallet/reserve",
                  "details": {
                    "operationId": "WalletKit_RequiredReserve",
                    "parameters": [
                      {
                        "description": "The number of additional channels the user would like to open.",
                        "format": "int64",
                        "in": "query",
                        "name": "additional_public_channels",
                        "required": false,
                        "type": "integer"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcRequiredReserveResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "RequiredReserve returns the minimum amount of satoshis that should be kept\nin the wallet in order to fee bump anchor channels if necessary. The value\nscales with the number of public anchor channels but is capped at a maximum.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ImportAccount",
              "description": "ImportAccount imports an account backed by an account extended public key.\nThe master key fingerprint denotes the fingerprint of the root key\ncorresponding to the account public key (also known as the key with\nderivation path m/). This may be required by some hardware wallets for\nproper identification and signing.\n\nThe address type can usually be inferred from the key's version, but may be\nrequired for certain keys to map them into the proper scope.\n\nFor BIP-0044 keys, an address type must be specified as we intend to not\nsupport importing BIP-0044 keys into the wallet using the legacy\npay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will force\nthe standard BIP-0049 derivation scheme, while a witness address type will\nforce the standard BIP-0084 derivation scheme.\n\nFor BIP-0049 keys, an address type must also be specified to make a\ndistinction between the standard BIP-0049 address schema (nested witness\npubkeys everywhere) and our own BIP-0049Plus address schema (nested pubkeys\nexternally, witness pubkeys internally).\n\nNOTE: Events (deposits/spends) for keys derived from an account will only be\ndetected by lnd if they happen after the import. Rescans to detect past\nevents will be supported later on.",
              "requestType": "ImportAccountRequest",
              "requestLongType": "ImportAccountRequest",
              "requestFullType": "walletrpc.ImportAccountRequest",
              "requestStreaming": false,
              "responseType": "ImportAccountResponse",
              "responseLongType": "ImportAccountResponse",
              "responseFullType": "walletrpc.ImportAccountResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/accounts/import",
                  "details": {
                    "description": "The address type can usually be inferred from the key's version, but may be\nrequired for certain keys to map them into the proper scope.\n\nFor BIP-0044 keys, an address type must be specified as we intend to not\nsupport importing BIP-0044 keys into the wallet using the legacy\npay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will force\nthe standard BIP-0049 derivation scheme, while a witness address type will\nforce the standard BIP-0084 derivation scheme.\n\nFor BIP-0049 keys, an address type must also be specified to make a\ndistinction between the standard BIP-0049 address schema (nested witness\npubkeys everywhere) and our own BIP-0049Plus address schema (nested pubkeys\nexternally, witness pubkeys internally).\n\nNOTE: Events (deposits/spends) for keys derived from an account will only be\ndetected by lnd if they happen after the import. Rescans to detect past\nevents will be supported later on.",
                    "operationId": "WalletKit_ImportAccount",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcImportAccountRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcImportAccountResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ImportAccount imports an account backed by an account extended public key.\nThe master key fingerprint denotes the fingerprint of the root key\ncorresponding to the account public key (also known as the key with\nderivation path m/). This may be required by some hardware wallets for\nproper identification and signing.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ImportPublicKey",
              "description": "ImportPublicKey imports a public key as watch-only into the wallet.\n\nNOTE: Events (deposits/spends) for a key will only be detected by lnd if\nthey happen after the import. Rescans to detect past events will be\nsupported later on.",
              "requestType": "ImportPublicKeyRequest",
              "requestLongType": "ImportPublicKeyRequest",
              "requestFullType": "walletrpc.ImportPublicKeyRequest",
              "requestStreaming": false,
              "responseType": "ImportPublicKeyResponse",
              "responseLongType": "ImportPublicKeyResponse",
              "responseFullType": "walletrpc.ImportPublicKeyResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/key/import",
                  "details": {
                    "description": "NOTE: Events (deposits/spends) for a key will only be detected by lnd if\nthey happen after the import. Rescans to detect past events will be\nsupported later on.",
                    "operationId": "WalletKit_ImportPublicKey",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcImportPublicKeyRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcImportPublicKeyResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ImportPublicKey imports a public key as watch-only into the wallet.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "PublishTransaction",
              "description": "PublishTransaction attempts to publish the passed transaction to the\nnetwork. Once this returns without an error, the wallet will continually\nattempt to re-broadcast the transaction on start up, until it enters the\nchain.",
              "requestType": "Transaction",
              "requestLongType": "Transaction",
              "requestFullType": "walletrpc.Transaction",
              "requestStreaming": false,
              "responseType": "PublishResponse",
              "responseLongType": "PublishResponse",
              "responseFullType": "walletrpc.PublishResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/tx",
                  "details": {
                    "operationId": "WalletKit_PublishTransaction",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcTransaction"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcPublishResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "PublishTransaction attempts to publish the passed transaction to the\nnetwork. Once this returns without an error, the wallet will continually\nattempt to re-broadcast the transaction on start up, until it enters the\nchain.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SendOutputs",
              "description": "SendOutputs is similar to the existing sendmany call in Bitcoind, and\nallows the caller to create a transaction that sends to several outputs at\nonce. This is ideal when wanting to batch create a set of transactions.",
              "requestType": "SendOutputsRequest",
              "requestLongType": "SendOutputsRequest",
              "requestFullType": "walletrpc.SendOutputsRequest",
              "requestStreaming": false,
              "responseType": "SendOutputsResponse",
              "responseLongType": "SendOutputsResponse",
              "responseFullType": "walletrpc.SendOutputsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/send",
                  "details": {
                    "operationId": "WalletKit_SendOutputs",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcSendOutputsRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcSendOutputsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SendOutputs is similar to the existing sendmany call in Bitcoind, and\nallows the caller to create a transaction that sends to several outputs at\nonce. This is ideal when wanting to batch create a set of transactions.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "EstimateFee",
              "description": "EstimateFee attempts to query the internal fee estimator of the wallet to\ndetermine the fee (in sat/kw) to attach to a transaction in order to\nachieve the confirmation target.",
              "requestType": "EstimateFeeRequest",
              "requestLongType": "EstimateFeeRequest",
              "requestFullType": "walletrpc.EstimateFeeRequest",
              "requestStreaming": false,
              "responseType": "EstimateFeeResponse",
              "responseLongType": "EstimateFeeResponse",
              "responseFullType": "walletrpc.EstimateFeeResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/wallet/estimatefee/{conf_target}",
                  "details": {
                    "operationId": "WalletKit_EstimateFee",
                    "parameters": [
                      {
                        "description": "The number of confirmations to shoot for when estimating the fee.",
                        "format": "int32",
                        "in": "path",
                        "name": "conf_target",
                        "required": true,
                        "type": "integer"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcEstimateFeeResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "EstimateFee attempts to query the internal fee estimator of the wallet to\ndetermine the fee (in sat/kw) to attach to a transaction in order to\nachieve the confirmation target.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "PendingSweeps",
              "description": "PendingSweeps returns lists of on-chain outputs that lnd is currently\nattempting to sweep within its central batching engine. Outputs with similar\nfee rates are batched together in order to sweep them within a single\ntransaction.\n\nNOTE: Some of the fields within PendingSweepsRequest are not guaranteed to\nremain supported. This is an advanced API that depends on the internals of\nthe UtxoSweeper, so things may change.",
              "requestType": "PendingSweepsRequest",
              "requestLongType": "PendingSweepsRequest",
              "requestFullType": "walletrpc.PendingSweepsRequest",
              "requestStreaming": false,
              "responseType": "PendingSweepsResponse",
              "responseLongType": "PendingSweepsResponse",
              "responseFullType": "walletrpc.PendingSweepsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/wallet/sweeps/pending",
                  "details": {
                    "description": "NOTE: Some of the fields within PendingSweepsRequest are not guaranteed to\nremain supported. This is an advanced API that depends on the internals of\nthe UtxoSweeper, so things may change.",
                    "operationId": "WalletKit_PendingSweeps",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcPendingSweepsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "PendingSweeps returns lists of on-chain outputs that lnd is currently\nattempting to sweep within its central batching engine. Outputs with similar\nfee rates are batched together in order to sweep them within a single\ntransaction.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "BumpFee",
              "description": "BumpFee bumps the fee of an arbitrary input within a transaction. This RPC\ntakes a different approach than bitcoind's bumpfee command. lnd has a\ncentral batching engine in which inputs with similar fee rates are batched\ntogether to save on transaction fees. Due to this, we cannot rely on\nbumping the fee on a specific transaction, since transactions can change at\nany point with the addition of new inputs. The list of inputs that\ncurrently exist within lnd's central batching engine can be retrieved\nthrough the PendingSweeps RPC.\n\nWhen bumping the fee of an input that currently exists within lnd's central\nbatching engine, a higher fee transaction will be created that replaces the\nlower fee transaction through the Replace-By-Fee (RBF) policy. If it\n\nThis RPC also serves useful when wanting to perform a Child-Pays-For-Parent\n(CPFP), where the child transaction pays for its parent's fee. This can be\ndone by specifying an outpoint within the low fee transaction that is under\nthe control of the wallet.\n\nThe fee preference can be expressed either as a specific fee rate or a delta\nof blocks in which the output should be swept on-chain within. If a fee\npreference is not explicitly specified, then an error is returned.\n\nNote that this RPC currently doesn't perform any validation checks on the\nfee preference being provided. For now, the responsibility of ensuring that\nthe new fee preference is sufficient is delegated to the user.",
              "requestType": "BumpFeeRequest",
              "requestLongType": "BumpFeeRequest",
              "requestFullType": "walletrpc.BumpFeeRequest",
              "requestStreaming": false,
              "responseType": "BumpFeeResponse",
              "responseLongType": "BumpFeeResponse",
              "responseFullType": "walletrpc.BumpFeeResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/bumpfee",
                  "details": {
                    "description": "When bumping the fee of an input that currently exists within lnd's central\nbatching engine, a higher fee transaction will be created that replaces the\nlower fee transaction through the Replace-By-Fee (RBF) policy. If it\n\nThis RPC also serves useful when wanting to perform a Child-Pays-For-Parent\n(CPFP), where the child transaction pays for its parent's fee. This can be\ndone by specifying an outpoint within the low fee transaction that is under\nthe control of the wallet.\n\nThe fee preference can be expressed either as a specific fee rate or a delta\nof blocks in which the output should be swept on-chain within. If a fee\npreference is not explicitly specified, then an error is returned.\n\nNote that this RPC currently doesn't perform any validation checks on the\nfee preference being provided. For now, the responsibility of ensuring that\nthe new fee preference is sufficient is delegated to the user.",
                    "operationId": "WalletKit_BumpFee",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcBumpFeeRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcBumpFeeResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "BumpFee bumps the fee of an arbitrary input within a transaction. This RPC\ntakes a different approach than bitcoind's bumpfee command. lnd has a\ncentral batching engine in which inputs with similar fee rates are batched\ntogether to save on transaction fees. Due to this, we cannot rely on\nbumping the fee on a specific transaction, since transactions can change at\nany point with the addition of new inputs. The list of inputs that\ncurrently exist within lnd's central batching engine can be retrieved\nthrough the PendingSweeps RPC.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ListSweeps",
              "description": "ListSweeps returns a list of the sweep transactions our node has produced.\nNote that these sweeps may not be confirmed yet, as we record sweeps on\nbroadcast, not confirmation.",
              "requestType": "ListSweepsRequest",
              "requestLongType": "ListSweepsRequest",
              "requestFullType": "walletrpc.ListSweepsRequest",
              "requestStreaming": false,
              "responseType": "ListSweepsResponse",
              "responseLongType": "ListSweepsResponse",
              "responseFullType": "walletrpc.ListSweepsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/wallet/sweeps",
                  "details": {
                    "operationId": "WalletKit_ListSweeps",
                    "parameters": [
                      {
                        "description": "Retrieve the full sweep transaction details. If false, only the sweep txids\nwill be returned. Note that some sweeps that LND publishes will have been\nreplaced-by-fee, so will not be included in this output.",
                        "in": "query",
                        "name": "verbose",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcListSweepsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ListSweeps returns a list of the sweep transactions our node has produced.\nNote that these sweeps may not be confirmed yet, as we record sweeps on\nbroadcast, not confirmation.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "LabelTransaction",
              "description": "LabelTransaction adds a label to a transaction. If the transaction already\nhas a label the call will fail unless the overwrite bool is set. This will\noverwrite the exiting transaction label. Labels must not be empty, and\ncannot exceed 500 characters.",
              "requestType": "LabelTransactionRequest",
              "requestLongType": "LabelTransactionRequest",
              "requestFullType": "walletrpc.LabelTransactionRequest",
              "requestStreaming": false,
              "responseType": "LabelTransactionResponse",
              "responseLongType": "LabelTransactionResponse",
              "responseFullType": "walletrpc.LabelTransactionResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/tx/label",
                  "details": {
                    "operationId": "WalletKit_LabelTransaction",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcLabelTransactionRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcLabelTransactionResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "LabelTransaction adds a label to a transaction. If the transaction already\nhas a label the call will fail unless the overwrite bool is set. This will\noverwrite the exiting transaction label. Labels must not be empty, and\ncannot exceed 500 characters.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "FundPsbt",
              "description": "FundPsbt creates a fully populated PSBT that contains enough inputs to fund\nthe outputs specified in the template. There are two ways of specifying a\ntemplate: Either by passing in a PSBT with at least one output declared or\nby passing in a raw TxTemplate message.\n\nIf there are no inputs specified in the template, coin selection is\nperformed automatically. If the template does contain any inputs, it is\nassumed that full coin selection happened externally and no additional\ninputs are added. If the specified inputs aren't enough to fund the outputs\nwith the given fee rate, an error is returned.\n\nAfter either selecting or verifying the inputs, all input UTXOs are locked\nwith an internal app ID.\n\nNOTE: If this method returns without an error, it is the caller's\nresponsibility to either spend the locked UTXOs (by finalizing and then\npublishing the transaction) or to unlock/release the locked UTXOs in case of\nan error on the caller's side.",
              "requestType": "FundPsbtRequest",
              "requestLongType": "FundPsbtRequest",
              "requestFullType": "walletrpc.FundPsbtRequest",
              "requestStreaming": false,
              "responseType": "FundPsbtResponse",
              "responseLongType": "FundPsbtResponse",
              "responseFullType": "walletrpc.FundPsbtResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/psbt/fund",
                  "details": {
                    "description": "If there are no inputs specified in the template, coin selection is\nperformed automatically. If the template does contain any inputs, it is\nassumed that full coin selection happened externally and no additional\ninputs are added. If the specified inputs aren't enough to fund the outputs\nwith the given fee rate, an error is returned.\n\nAfter either selecting or verifying the inputs, all input UTXOs are locked\nwith an internal app ID.\n\nNOTE: If this method returns without an error, it is the caller's\nresponsibility to either spend the locked UTXOs (by finalizing and then\npublishing the transaction) or to unlock/release the locked UTXOs in case of\nan error on the caller's side.",
                    "operationId": "WalletKit_FundPsbt",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcFundPsbtRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcFundPsbtResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "FundPsbt creates a fully populated PSBT that contains enough inputs to fund\nthe outputs specified in the template. There are two ways of specifying a\ntemplate: Either by passing in a PSBT with at least one output declared or\nby passing in a raw TxTemplate message.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SignPsbt",
              "description": "SignPsbt expects a partial transaction with all inputs and outputs fully\ndeclared and tries to sign all unsigned inputs that have all required fields\n(UTXO information, BIP32 derivation information, witness or sig scripts)\nset.\nIf no error is returned, the PSBT is ready to be given to the next signer or\nto be finalized if lnd was the last signer.\n\nNOTE: This RPC only signs inputs (and only those it can sign), it does not\nperform any other tasks (such as coin selection, UTXO locking or\ninput/output/fee value validation, PSBT finalization). Any input that is\nincomplete will be skipped.",
              "requestType": "SignPsbtRequest",
              "requestLongType": "SignPsbtRequest",
              "requestFullType": "walletrpc.SignPsbtRequest",
              "requestStreaming": false,
              "responseType": "SignPsbtResponse",
              "responseLongType": "SignPsbtResponse",
              "responseFullType": "walletrpc.SignPsbtResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/psbt/sign",
                  "details": {
                    "description": "NOTE: This RPC only signs inputs (and only those it can sign), it does not\nperform any other tasks (such as coin selection, UTXO locking or\ninput/output/fee value validation, PSBT finalization). Any input that is\nincomplete will be skipped.",
                    "operationId": "WalletKit_SignPsbt",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcSignPsbtRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcSignPsbtResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SignPsbt expects a partial transaction with all inputs and outputs fully\ndeclared and tries to sign all unsigned inputs that have all required fields\n(UTXO information, BIP32 derivation information, witness or sig scripts)\nset.\nIf no error is returned, the PSBT is ready to be given to the next signer or\nto be finalized if lnd was the last signer.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "FinalizePsbt",
              "description": "FinalizePsbt expects a partial transaction with all inputs and outputs fully\ndeclared and tries to sign all inputs that belong to the wallet. Lnd must be\nthe last signer of the transaction. That means, if there are any unsigned\nnon-witness inputs or inputs without UTXO information attached or inputs\nwithout witness data that do not belong to lnd's wallet, this method will\nfail. If no error is returned, the PSBT is ready to be extracted and the\nfinal TX within to be broadcast.\n\nNOTE: This method does NOT publish the transaction once finalized. It is the\ncaller's responsibility to either publish the transaction on success or\nunlock/release any locked UTXOs in case of an error in this method.",
              "requestType": "FinalizePsbtRequest",
              "requestLongType": "FinalizePsbtRequest",
              "requestFullType": "walletrpc.FinalizePsbtRequest",
              "requestStreaming": false,
              "responseType": "FinalizePsbtResponse",
              "responseLongType": "FinalizePsbtResponse",
              "responseFullType": "walletrpc.FinalizePsbtResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/wallet/psbt/finalize",
                  "details": {
                    "description": "NOTE: This method does NOT publish the transaction once finalized. It is the\ncaller's responsibility to either publish the transaction on success or\nunlock/release any locked UTXOs in case of an error in this method.",
                    "operationId": "WalletKit_FinalizePsbt",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/walletrpcFinalizePsbtRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/walletrpcFinalizePsbtResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "FinalizePsbt expects a partial transaction with all inputs and outputs fully\ndeclared and tries to sign all inputs that belong to the wallet. Lnd must be\nthe last signer of the transaction. That means, if there are any unsigned\nnon-witness inputs or inputs without UTXO information attached or inputs\nwithout witness data that do not belong to lnd's wallet, this method will\nfail. If no error is returned, the PSBT is ready to be extracted and the\nfinal TX within to be broadcast.",
                    "tags": [
                      "WalletKit"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "chainrpc/chainnotifier.proto",
      "description": "",
      "package": "chainrpc",
      "hasEnums": false,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [],
      "extensions": [],
      "messages": [
        {
          "name": "BlockEpoch",
          "longName": "BlockEpoch",
          "fullName": "chainrpc.BlockEpoch",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "hash",
              "description": "The hash of the block.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "height",
              "description": "The height of the block.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ConfDetails",
          "longName": "ConfDetails",
          "fullName": "chainrpc.ConfDetails",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "raw_tx",
              "description": "The raw bytes of the confirmed transaction.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "block_hash",
              "description": "The hash of the block in which the confirmed transaction was included in.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "block_height",
              "description": "The height of the block in which the confirmed transaction was included\nin.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "tx_index",
              "description": "The index of the confirmed transaction within the transaction.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ConfEvent",
          "longName": "ConfEvent",
          "fullName": "chainrpc.ConfEvent",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "conf",
              "description": "An event that includes the confirmation details of the request\n(txid/ouput script).",
              "label": "",
              "type": "ConfDetails",
              "longType": "ConfDetails",
              "fullType": "chainrpc.ConfDetails",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "event",
              "defaultValue": ""
            },
            {
              "name": "reorg",
              "description": "An event send when the transaction of the request is reorged out of the\nchain.",
              "label": "",
              "type": "Reorg",
              "longType": "Reorg",
              "fullType": "chainrpc.Reorg",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "event",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ConfRequest",
          "longName": "ConfRequest",
          "fullName": "chainrpc.ConfRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "txid",
              "description": "The transaction hash for which we should request a confirmation notification\nfor. If set to a hash of all zeros, then the confirmation notification will\nbe requested for the script instead.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "script",
              "description": "An output script within a transaction with the hash above which will be used\nby light clients to match block filters. If the transaction hash is set to a\nhash of all zeros, then a confirmation notification will be requested for\nthis script instead.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_confs",
              "description": "The number of desired confirmations the transaction/output script should\nreach before dispatching a confirmation notification.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "height_hint",
              "description": "The earliest height in the chain for which the transaction/output script\ncould have been included in a block. This should in most cases be set to the\nbroadcast height of the transaction/output script.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Outpoint",
          "longName": "Outpoint",
          "fullName": "chainrpc.Outpoint",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "hash",
              "description": "The hash of the transaction.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "index",
              "description": "The index of the output within the transaction.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Reorg",
          "longName": "Reorg",
          "fullName": "chainrpc.Reorg",
          "description": "TODO(wilmer): need to know how the client will use this first.",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "SpendDetails",
          "longName": "SpendDetails",
          "fullName": "chainrpc.SpendDetails",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "spending_outpoint",
              "description": "The outpoint was that spent.",
              "label": "",
              "type": "Outpoint",
              "longType": "Outpoint",
              "fullType": "chainrpc.Outpoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "raw_spending_tx",
              "description": "The raw bytes of the spending transaction.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "spending_tx_hash",
              "description": "The hash of the spending transaction.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "spending_input_index",
              "description": "The input of the spending transaction that fulfilled the spend request.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "spending_height",
              "description": "The height at which the spending transaction was included in a block.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SpendEvent",
          "longName": "SpendEvent",
          "fullName": "chainrpc.SpendEvent",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "spend",
              "description": "An event that includes the details of the spending transaction of the\nrequest (outpoint/output script).",
              "label": "",
              "type": "SpendDetails",
              "longType": "SpendDetails",
              "fullType": "chainrpc.SpendDetails",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "event",
              "defaultValue": ""
            },
            {
              "name": "reorg",
              "description": "An event sent when the spending transaction of the request was\nreorged out of the chain.",
              "label": "",
              "type": "Reorg",
              "longType": "Reorg",
              "fullType": "chainrpc.Reorg",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "event",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SpendRequest",
          "longName": "SpendRequest",
          "fullName": "chainrpc.SpendRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "outpoint",
              "description": "The outpoint for which we should request a spend notification for. If set to\na zero outpoint, then the spend notification will be requested for the\nscript instead. A zero or nil outpoint is not supported for Taproot spends\nbecause the output script cannot reliably be computed from the witness alone\nand the spent output script is not always available in the rescan context.\nSo an outpoint must _always_ be specified when registering a spend\nnotification for a Taproot output.",
              "label": "",
              "type": "Outpoint",
              "longType": "Outpoint",
              "fullType": "chainrpc.Outpoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "script",
              "description": "The output script for the outpoint above. This will be used by light clients\nto match block filters. If the outpoint is set to a zero outpoint, then a\nspend notification will be requested for this script instead.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "height_hint",
              "description": "The earliest height in the chain for which the outpoint/output script could\nhave been spent. This should in most cases be set to the broadcast height of\nthe outpoint/output script.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": [
        {
          "name": "ChainNotifier",
          "longName": "ChainNotifier",
          "fullName": "chainrpc.ChainNotifier",
          "description": "ChainNotifier is a service that can be used to get information about the\nchain backend by registering notifiers for chain events.",
          "methods": [
            {
              "name": "RegisterConfirmationsNtfn",
              "description": "RegisterConfirmationsNtfn is a synchronous response-streaming RPC that\nregisters an intent for a client to be notified once a confirmation request\nhas reached its required number of confirmations on-chain.\n\nA confirmation request must have a valid output script. It is also possible\nto give a transaction ID. If the transaction ID is not set, a notification\nis sent once the output script confirms. If the transaction ID is also set,\na notification is sent once the output script confirms in the given\ntransaction.",
              "requestType": "ConfRequest",
              "requestLongType": "ConfRequest",
              "requestFullType": "chainrpc.ConfRequest",
              "requestStreaming": false,
              "responseType": "ConfEvent",
              "responseLongType": "ConfEvent",
              "responseFullType": "chainrpc.ConfEvent",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/chainnotifier/register/confirmations",
                  "details": {
                    "description": "A confirmation request must have a valid output script. It is also possible\nto give a transaction ID. If the transaction ID is not set, a notification\nis sent once the output script confirms. If the transaction ID is also set,\na notification is sent once the output script confirms in the given\ntransaction.",
                    "operationId": "ChainNotifier_RegisterConfirmationsNtfn",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/chainrpcConfRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/chainrpcConfEvent"
                            }
                          },
                          "title": "Stream result of chainrpcConfEvent",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "RegisterConfirmationsNtfn is a synchronous response-streaming RPC that\nregisters an intent for a client to be notified once a confirmation request\nhas reached its required number of confirmations on-chain.",
                    "tags": [
                      "ChainNotifier"
                    ]
                  }
                }
              ]
            },
            {
              "name": "RegisterSpendNtfn",
              "description": "RegisterSpendNtfn is a synchronous response-streaming RPC that registers an\nintent for a client to be notification once a spend request has been spent\nby a transaction that has confirmed on-chain.\n\nA client can specify whether the spend request should be for a particular\noutpoint  or for an output script by specifying a zero outpoint.",
              "requestType": "SpendRequest",
              "requestLongType": "SpendRequest",
              "requestFullType": "chainrpc.SpendRequest",
              "requestStreaming": false,
              "responseType": "SpendEvent",
              "responseLongType": "SpendEvent",
              "responseFullType": "chainrpc.SpendEvent",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/chainnotifier/register/spends",
                  "details": {
                    "description": "A client can specify whether the spend request should be for a particular\noutpoint  or for an output script by specifying a zero outpoint.",
                    "operationId": "ChainNotifier_RegisterSpendNtfn",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/chainrpcSpendRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/chainrpcSpendEvent"
                            }
                          },
                          "title": "Stream result of chainrpcSpendEvent",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "RegisterSpendNtfn is a synchronous response-streaming RPC that registers an\nintent for a client to be notification once a spend request has been spent\nby a transaction that has confirmed on-chain.",
                    "tags": [
                      "ChainNotifier"
                    ]
                  }
                }
              ]
            },
            {
              "name": "RegisterBlockEpochNtfn",
              "description": "RegisterBlockEpochNtfn is a synchronous response-streaming RPC that\nregisters an intent for a client to be notified of blocks in the chain. The\nstream will return a hash and height tuple of a block for each new/stale\nblock in the chain. It is the client's responsibility to determine whether\nthe tuple returned is for a new or stale block in the chain.\n\nA client can also request a historical backlog of blocks from a particular\npoint. This allows clients to be idempotent by ensuring that they do not\nmissing processing a single block within the chain.",
              "requestType": "BlockEpoch",
              "requestLongType": "BlockEpoch",
              "requestFullType": "chainrpc.BlockEpoch",
              "requestStreaming": false,
              "responseType": "BlockEpoch",
              "responseLongType": "BlockEpoch",
              "responseFullType": "chainrpc.BlockEpoch",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/chainnotifier/register/blocks",
                  "details": {
                    "description": "A client can also request a historical backlog of blocks from a particular\npoint. This allows clients to be idempotent by ensuring that they do not\nmissing processing a single block within the chain.",
                    "operationId": "ChainNotifier_RegisterBlockEpochNtfn",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/chainrpcBlockEpoch"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/chainrpcBlockEpoch"
                            }
                          },
                          "title": "Stream result of chainrpcBlockEpoch",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "RegisterBlockEpochNtfn is a synchronous response-streaming RPC that\nregisters an intent for a client to be notified of blocks in the chain. The\nstream will return a hash and height tuple of a block for each new/stale\nblock in the chain. It is the client's responsibility to determine whether\nthe tuple returned is for a new or stale block in the chain.",
                    "tags": [
                      "ChainNotifier"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "routerrpc/router.proto",
      "description": "",
      "package": "routerrpc",
      "hasEnums": true,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [
        {
          "name": "ChanStatusAction",
          "longName": "ChanStatusAction",
          "fullName": "routerrpc.ChanStatusAction",
          "description": "",
          "values": [
            {
              "name": "ENABLE",
              "number": "0",
              "description": ""
            },
            {
              "name": "DISABLE",
              "number": "1",
              "description": ""
            },
            {
              "name": "AUTO",
              "number": "2",
              "description": ""
            }
          ]
        },
        {
          "name": "FailureDetail",
          "longName": "FailureDetail",
          "fullName": "routerrpc.FailureDetail",
          "description": "",
          "values": [
            {
              "name": "UNKNOWN",
              "number": "0",
              "description": ""
            },
            {
              "name": "NO_DETAIL",
              "number": "1",
              "description": ""
            },
            {
              "name": "ONION_DECODE",
              "number": "2",
              "description": ""
            },
            {
              "name": "LINK_NOT_ELIGIBLE",
              "number": "3",
              "description": ""
            },
            {
              "name": "ON_CHAIN_TIMEOUT",
              "number": "4",
              "description": ""
            },
            {
              "name": "HTLC_EXCEEDS_MAX",
              "number": "5",
              "description": ""
            },
            {
              "name": "INSUFFICIENT_BALANCE",
              "number": "6",
              "description": ""
            },
            {
              "name": "INCOMPLETE_FORWARD",
              "number": "7",
              "description": ""
            },
            {
              "name": "HTLC_ADD_FAILED",
              "number": "8",
              "description": ""
            },
            {
              "name": "FORWARDS_DISABLED",
              "number": "9",
              "description": ""
            },
            {
              "name": "INVOICE_CANCELED",
              "number": "10",
              "description": ""
            },
            {
              "name": "INVOICE_UNDERPAID",
              "number": "11",
              "description": ""
            },
            {
              "name": "INVOICE_EXPIRY_TOO_SOON",
              "number": "12",
              "description": ""
            },
            {
              "name": "INVOICE_NOT_OPEN",
              "number": "13",
              "description": ""
            },
            {
              "name": "MPP_INVOICE_TIMEOUT",
              "number": "14",
              "description": ""
            },
            {
              "name": "ADDRESS_MISMATCH",
              "number": "15",
              "description": ""
            },
            {
              "name": "SET_TOTAL_MISMATCH",
              "number": "16",
              "description": ""
            },
            {
              "name": "SET_TOTAL_TOO_LOW",
              "number": "17",
              "description": ""
            },
            {
              "name": "SET_OVERPAID",
              "number": "18",
              "description": ""
            },
            {
              "name": "UNKNOWN_INVOICE",
              "number": "19",
              "description": ""
            },
            {
              "name": "INVALID_KEYSEND",
              "number": "20",
              "description": ""
            },
            {
              "name": "MPP_IN_PROGRESS",
              "number": "21",
              "description": ""
            },
            {
              "name": "CIRCULAR_ROUTE",
              "number": "22",
              "description": ""
            }
          ]
        },
        {
          "name": "EventType",
          "longName": "HtlcEvent.EventType",
          "fullName": "routerrpc.HtlcEvent.EventType",
          "description": "",
          "values": [
            {
              "name": "UNKNOWN",
              "number": "0",
              "description": ""
            },
            {
              "name": "SEND",
              "number": "1",
              "description": ""
            },
            {
              "name": "RECEIVE",
              "number": "2",
              "description": ""
            },
            {
              "name": "FORWARD",
              "number": "3",
              "description": ""
            }
          ]
        },
        {
          "name": "PaymentState",
          "longName": "PaymentState",
          "fullName": "routerrpc.PaymentState",
          "description": "",
          "values": [
            {
              "name": "IN_FLIGHT",
              "number": "0",
              "description": "Payment is still in flight."
            },
            {
              "name": "SUCCEEDED",
              "number": "1",
              "description": "Payment completed successfully."
            },
            {
              "name": "FAILED_TIMEOUT",
              "number": "2",
              "description": "There are more routes to try, but the payment timeout was exceeded."
            },
            {
              "name": "FAILED_NO_ROUTE",
              "number": "3",
              "description": "All possible routes were tried and failed permanently. Or were no\nroutes to the destination at all."
            },
            {
              "name": "FAILED_ERROR",
              "number": "4",
              "description": "A non-recoverable error has occurred."
            },
            {
              "name": "FAILED_INCORRECT_PAYMENT_DETAILS",
              "number": "5",
              "description": "Payment details incorrect (unknown hash, invalid amt or\ninvalid final cltv delta)"
            },
            {
              "name": "FAILED_INSUFFICIENT_BALANCE",
              "number": "6",
              "description": "Insufficient local balance."
            }
          ]
        },
        {
          "name": "ResolveHoldForwardAction",
          "longName": "ResolveHoldForwardAction",
          "fullName": "routerrpc.ResolveHoldForwardAction",
          "description": "",
          "values": [
            {
              "name": "SETTLE",
              "number": "0",
              "description": ""
            },
            {
              "name": "FAIL",
              "number": "1",
              "description": ""
            },
            {
              "name": "RESUME",
              "number": "2",
              "description": ""
            }
          ]
        }
      ],
      "extensions": [],
      "messages": [
        {
          "name": "BuildRouteRequest",
          "longName": "BuildRouteRequest",
          "fullName": "routerrpc.BuildRouteRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "amt_msat",
              "description": "The amount to send expressed in msat. If set to zero, the minimum routable\namount is used.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "final_cltv_delta",
              "description": "CLTV delta from the current height that should be used for the timelock\nof the final hop",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outgoing_chan_id",
              "description": "The channel id of the channel that must be taken to the first hop. If zero,\nany channel may be used.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "hop_pubkeys",
              "description": "A list of hops that defines the route. This does not include the source hop\npubkey.",
              "label": "repeated",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_addr",
              "description": "An optional payment addr to be included within the last hop of the route.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "BuildRouteResponse",
          "longName": "BuildRouteResponse",
          "fullName": "routerrpc.BuildRouteResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "route",
              "description": "Fully specified route that can be used to execute the payment.",
              "label": "",
              "type": "Route",
              "longType": "lnrpc.Route",
              "fullType": "lnrpc.Route",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "CircuitKey",
          "longName": "CircuitKey",
          "fullName": "routerrpc.CircuitKey",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chan_id",
              "description": "The id of the channel that the is part of this circuit.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "htlc_id",
              "description": "The index of the incoming htlc in the incoming channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ForwardEvent",
          "longName": "ForwardEvent",
          "fullName": "routerrpc.ForwardEvent",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "info",
              "description": "Info contains details about the htlc that was forwarded.",
              "label": "",
              "type": "HtlcInfo",
              "longType": "HtlcInfo",
              "fullType": "routerrpc.HtlcInfo",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ForwardFailEvent",
          "longName": "ForwardFailEvent",
          "fullName": "routerrpc.ForwardFailEvent",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "ForwardHtlcInterceptRequest",
          "longName": "ForwardHtlcInterceptRequest",
          "fullName": "routerrpc.ForwardHtlcInterceptRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "incoming_circuit_key",
              "description": "The key of this forwarded htlc. It defines the incoming channel id and\nthe index in this channel.",
              "label": "",
              "type": "CircuitKey",
              "longType": "CircuitKey",
              "fullType": "routerrpc.CircuitKey",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "incoming_amount_msat",
              "description": "The incoming htlc amount.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "incoming_expiry",
              "description": "The incoming htlc expiry.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_hash",
              "description": "The htlc payment hash. This value is not guaranteed to be unique per\nrequest.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outgoing_requested_chan_id",
              "description": "The requested outgoing channel id for this forwarded htlc. Because of\nnon-strict forwarding, this isn't necessarily the channel over which the\npacket will be forwarded eventually. A different channel to the same peer\nmay be selected as well.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outgoing_amount_msat",
              "description": "The outgoing htlc amount.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outgoing_expiry",
              "description": "The outgoing htlc expiry.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "custom_records",
              "description": "Any custom records that were present in the payload.",
              "label": "repeated",
              "type": "CustomRecordsEntry",
              "longType": "ForwardHtlcInterceptRequest.CustomRecordsEntry",
              "fullType": "routerrpc.ForwardHtlcInterceptRequest.CustomRecordsEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "onion_blob",
              "description": "The onion blob for the next hop",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "CustomRecordsEntry",
          "longName": "ForwardHtlcInterceptRequest.CustomRecordsEntry",
          "fullName": "routerrpc.ForwardHtlcInterceptRequest.CustomRecordsEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ForwardHtlcInterceptResponse",
          "longName": "ForwardHtlcInterceptResponse",
          "fullName": "routerrpc.ForwardHtlcInterceptResponse",
          "description": "ForwardHtlcInterceptResponse enables the caller to resolve a previously hold\nforward. The caller can choose either to:\n- `Resume`: Execute the default behavior (usually forward).\n- `Reject`: Fail the htlc backwards.\n- `Settle`: Settle this htlc with a given preimage.",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "incoming_circuit_key",
              "description": "The key of this forwarded htlc. It defines the incoming channel id and\nthe index in this channel.",
              "label": "",
              "type": "CircuitKey",
              "longType": "CircuitKey",
              "fullType": "routerrpc.CircuitKey",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "action",
              "description": "The resolve action for this intercepted htlc.",
              "label": "",
              "type": "ResolveHoldForwardAction",
              "longType": "ResolveHoldForwardAction",
              "fullType": "routerrpc.ResolveHoldForwardAction",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "preimage",
              "description": "The preimage in case the resolve action is Settle.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "failure_message",
              "description": "Encrypted failure message in case the resolve action is Fail.\n\nIf failure_message is specified, the failure_code field must be set\nto zero.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "failure_code",
              "description": "Return the specified failure code in case the resolve action is Fail. The\nmessage data fields are populated automatically.\n\nIf a non-zero failure_code is specified, failure_message must not be set.\n\nFor backwards-compatibility reasons, TEMPORARY_CHANNEL_FAILURE is the\ndefault value for this field.",
              "label": "",
              "type": "FailureCode",
              "longType": "lnrpc.Failure.FailureCode",
              "fullType": "lnrpc.Failure.FailureCode",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "GetMissionControlConfigRequest",
          "longName": "GetMissionControlConfigRequest",
          "fullName": "routerrpc.GetMissionControlConfigRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "GetMissionControlConfigResponse",
          "longName": "GetMissionControlConfigResponse",
          "fullName": "routerrpc.GetMissionControlConfigResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "config",
              "description": "Mission control's currently active config.",
              "label": "",
              "type": "MissionControlConfig",
              "longType": "MissionControlConfig",
              "fullType": "routerrpc.MissionControlConfig",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "HtlcEvent",
          "longName": "HtlcEvent",
          "fullName": "routerrpc.HtlcEvent",
          "description": "HtlcEvent contains the htlc event that was processed. These are served on a\nbest-effort basis; events are not persisted, delivery is not guaranteed\n(in the event of a crash in the switch, forward events may be lost) and\nsome events may be replayed upon restart. Events consumed from this package\nshould be de-duplicated by the htlc's unique combination of incoming and\noutgoing channel id and htlc id. [EXPERIMENTAL]",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "incoming_channel_id",
              "description": "The short channel id that the incoming htlc arrived at our node on. This\nvalue is zero for sends.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outgoing_channel_id",
              "description": "The short channel id that the outgoing htlc left our node on. This value\nis zero for receives.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "incoming_htlc_id",
              "description": "Incoming id is the index of the incoming htlc in the incoming channel.\nThis value is zero for sends.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outgoing_htlc_id",
              "description": "Outgoing id is the index of the outgoing htlc in the outgoing channel.\nThis value is zero for receives.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "timestamp_ns",
              "description": "The time in unix nanoseconds that the event occurred.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "event_type",
              "description": "The event type indicates whether the htlc was part of a send, receive or\nforward.",
              "label": "",
              "type": "EventType",
              "longType": "HtlcEvent.EventType",
              "fullType": "routerrpc.HtlcEvent.EventType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "forward_event",
              "description": "",
              "label": "",
              "type": "ForwardEvent",
              "longType": "ForwardEvent",
              "fullType": "routerrpc.ForwardEvent",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "event",
              "defaultValue": ""
            },
            {
              "name": "forward_fail_event",
              "description": "",
              "label": "",
              "type": "ForwardFailEvent",
              "longType": "ForwardFailEvent",
              "fullType": "routerrpc.ForwardFailEvent",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "event",
              "defaultValue": ""
            },
            {
              "name": "settle_event",
              "description": "",
              "label": "",
              "type": "SettleEvent",
              "longType": "SettleEvent",
              "fullType": "routerrpc.SettleEvent",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "event",
              "defaultValue": ""
            },
            {
              "name": "link_fail_event",
              "description": "",
              "label": "",
              "type": "LinkFailEvent",
              "longType": "LinkFailEvent",
              "fullType": "routerrpc.LinkFailEvent",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "event",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "HtlcInfo",
          "longName": "HtlcInfo",
          "fullName": "routerrpc.HtlcInfo",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "incoming_timelock",
              "description": "The timelock on the incoming htlc.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outgoing_timelock",
              "description": "The timelock on the outgoing htlc.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "incoming_amt_msat",
              "description": "The amount of the incoming htlc.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outgoing_amt_msat",
              "description": "The amount of the outgoing htlc.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "LinkFailEvent",
          "longName": "LinkFailEvent",
          "fullName": "routerrpc.LinkFailEvent",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "info",
              "description": "Info contains details about the htlc that we failed.",
              "label": "",
              "type": "HtlcInfo",
              "longType": "HtlcInfo",
              "fullType": "routerrpc.HtlcInfo",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "wire_failure",
              "description": "FailureCode is the BOLT error code for the failure.",
              "label": "",
              "type": "FailureCode",
              "longType": "lnrpc.Failure.FailureCode",
              "fullType": "lnrpc.Failure.FailureCode",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "failure_detail",
              "description": "FailureDetail provides additional information about the reason for the\nfailure. This detail enriches the information provided by the wire message\nand may be 'no detail' if the wire message requires no additional metadata.",
              "label": "",
              "type": "FailureDetail",
              "longType": "FailureDetail",
              "fullType": "routerrpc.FailureDetail",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "failure_string",
              "description": "A string representation of the link failure.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MissionControlConfig",
          "longName": "MissionControlConfig",
          "fullName": "routerrpc.MissionControlConfig",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "half_life_seconds",
              "description": "The amount of time mission control will take to restore a penalized node\nor channel back to 50% success probability, expressed in seconds. Setting\nthis value to a higher value will penalize failures for longer, making\nmission control less likely to route through nodes and channels that we\nhave previously recorded failures for.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "hop_probability",
              "description": "The probability of success mission control should assign to hop in a route\nwhere it has no other information available. Higher values will make mission\ncontrol more willing to try hops that we have no information about, lower\nvalues will discourage trying these hops.",
              "label": "",
              "type": "float",
              "longType": "float",
              "fullType": "float",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "weight",
              "description": "The importance that mission control should place on historical results,\nexpressed as a value in [0;1]. Setting this value to 1 will ignore all\nhistorical payments and just use the hop probability to assess the\nprobability of success for each hop. A zero value ignores hop probability\ncompletely and relies entirely on historical results, unless none are\navailable.",
              "label": "",
              "type": "float",
              "longType": "float",
              "fullType": "float",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "maximum_payment_results",
              "description": "The maximum number of payment results that mission control will store.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "minimum_failure_relax_interval",
              "description": "The minimum time that must have passed since the previously recorded failure\nbefore we raise the failure amount.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PairData",
          "longName": "PairData",
          "fullName": "routerrpc.PairData",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "fail_time",
              "description": "Time of last failure.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fail_amt_sat",
              "description": "Lowest amount that failed to forward rounded to whole sats. This may be\nset to zero if the failure is independent of amount.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fail_amt_msat",
              "description": "Lowest amount that failed to forward in millisats. This may be\nset to zero if the failure is independent of amount.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "success_time",
              "description": "Time of last success.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "success_amt_sat",
              "description": "Highest amount that we could successfully forward rounded to whole sats.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "success_amt_msat",
              "description": "Highest amount that we could successfully forward in millisats.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PairHistory",
          "longName": "PairHistory",
          "fullName": "routerrpc.PairHistory",
          "description": "PairHistory contains the mission control state for a particular node pair.",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "node_from",
              "description": "The source node pubkey of the pair.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "node_to",
              "description": "The destination node pubkey of the pair.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "history",
              "description": "",
              "label": "",
              "type": "PairData",
              "longType": "PairData",
              "fullType": "routerrpc.PairData",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PaymentStatus",
          "longName": "PaymentStatus",
          "fullName": "routerrpc.PaymentStatus",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "state",
              "description": "Current state the payment is in.",
              "label": "",
              "type": "PaymentState",
              "longType": "PaymentState",
              "fullType": "routerrpc.PaymentState",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "preimage",
              "description": "The pre-image of the payment when state is SUCCEEDED.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "htlcs",
              "description": "The HTLCs made in attempt to settle the payment [EXPERIMENTAL].",
              "label": "repeated",
              "type": "HTLCAttempt",
              "longType": "lnrpc.HTLCAttempt",
              "fullType": "lnrpc.HTLCAttempt",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "QueryMissionControlRequest",
          "longName": "QueryMissionControlRequest",
          "fullName": "routerrpc.QueryMissionControlRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "QueryMissionControlResponse",
          "longName": "QueryMissionControlResponse",
          "fullName": "routerrpc.QueryMissionControlResponse",
          "description": "QueryMissionControlResponse contains mission control state.",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pairs",
              "description": "Node pair-level mission control state.",
              "label": "repeated",
              "type": "PairHistory",
              "longType": "PairHistory",
              "fullType": "routerrpc.PairHistory",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "QueryProbabilityRequest",
          "longName": "QueryProbabilityRequest",
          "fullName": "routerrpc.QueryProbabilityRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "from_node",
              "description": "The source node pubkey of the pair.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "to_node",
              "description": "The destination node pubkey of the pair.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_msat",
              "description": "The amount for which to calculate a probability.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "QueryProbabilityResponse",
          "longName": "QueryProbabilityResponse",
          "fullName": "routerrpc.QueryProbabilityResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "probability",
              "description": "The success probability for the requested pair.",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "history",
              "description": "The historical data for the requested pair.",
              "label": "",
              "type": "PairData",
              "longType": "PairData",
              "fullType": "routerrpc.PairData",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ResetMissionControlRequest",
          "longName": "ResetMissionControlRequest",
          "fullName": "routerrpc.ResetMissionControlRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "ResetMissionControlResponse",
          "longName": "ResetMissionControlResponse",
          "fullName": "routerrpc.ResetMissionControlResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "RouteFeeRequest",
          "longName": "RouteFeeRequest",
          "fullName": "routerrpc.RouteFeeRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "dest",
              "description": "The destination once wishes to obtain a routing fee quote to.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_sat",
              "description": "The amount one wishes to send to the target destination.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "RouteFeeResponse",
          "longName": "RouteFeeResponse",
          "fullName": "routerrpc.RouteFeeResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "routing_fee_msat",
              "description": "A lower bound of the estimated fee to the target destination within the\nnetwork, expressed in milli-satoshis.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "time_lock_delay",
              "description": "An estimate of the worst case time delay that can occur. Note that callers\nwill still need to factor in the final CLTV delta of the last hop into this\nvalue.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendPaymentRequest",
          "longName": "SendPaymentRequest",
          "fullName": "routerrpc.SendPaymentRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "dest",
              "description": "The identity pubkey of the payment recipient",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt",
              "description": "Number of satoshis to send.\n\nThe fields amt and amt_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_msat",
              "description": "Number of millisatoshis to send.\n\nThe fields amt and amt_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_hash",
              "description": "The hash to use within the payment's HTLC",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "final_cltv_delta",
              "description": "The CLTV delta from the current height that should be used to set the\ntimelock for the final hop.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_addr",
              "description": "An optional payment addr to be included within the last hop of the route.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_request",
              "description": "A bare-bones invoice for a payment within the Lightning Network.  With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient. The amount in the payment request may be zero. In\nthat case it is required to set the amt field as well. If no payment request\nis specified, the following fields are required: dest, amt and payment_hash.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "timeout_seconds",
              "description": "An upper limit on the amount of time we should spend when attempting to\nfulfill the payment. This is expressed in seconds. If we cannot make a\nsuccessful payment within this time frame, an error will be returned.\nThis field must be non-zero.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_limit_sat",
              "description": "The maximum number of satoshis that will be paid as a fee of the payment.\nIf this field is left to the default value of 0, only zero-fee routes will\nbe considered. This usually means single hop routes connecting directly to\nthe destination. To send the payment without a fee limit, use max int here.\n\nThe fields fee_limit_sat and fee_limit_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_limit_msat",
              "description": "The maximum number of millisatoshis that will be paid as a fee of the\npayment. If this field is left to the default value of 0, only zero-fee\nroutes will be considered. This usually means single hop routes connecting\ndirectly to the destination. To send the payment without a fee limit, use\nmax int here.\n\nThe fields fee_limit_sat and fee_limit_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outgoing_chan_id",
              "description": "Deprecated, use outgoing_chan_ids. The channel id of the channel that must\nbe taken to the first hop. If zero, any channel may be used (unless\noutgoing_chan_ids are set).",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "outgoing_chan_ids",
              "description": "The channel ids of the channels are allowed for the first hop. If empty,\nany channel may be used.",
              "label": "repeated",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "last_hop_pubkey",
              "description": "The pubkey of the last hop of the route. If empty, any hop may be used.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "cltv_limit",
              "description": "An optional maximum total time lock for the route. This should not exceed\nlnd's `--max-cltv-expiry` setting. If zero, then the value of\n`--max-cltv-expiry` is enforced.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "route_hints",
              "description": "Optional route hints to reach the destination through private channels.",
              "label": "repeated",
              "type": "RouteHint",
              "longType": "lnrpc.RouteHint",
              "fullType": "lnrpc.RouteHint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dest_custom_records",
              "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto a peer which understands the new records. This can be used to pass\napplication specific data during the payment attempt. Record types are\nrequired to be in the custom range \u003e= 65536. When using REST, the values\nmust be encoded as base64.",
              "label": "repeated",
              "type": "DestCustomRecordsEntry",
              "longType": "SendPaymentRequest.DestCustomRecordsEntry",
              "fullType": "routerrpc.SendPaymentRequest.DestCustomRecordsEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "allow_self_payment",
              "description": "If set, circular payments to self are permitted.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dest_features",
              "description": "Features assumed to be supported by the final node. All transitive feature\ndependencies must also be set properly. For a given feature bit pair, either\noptional or remote may be set, but not both. If this field is nil or empty,\nthe router will try to load destination features from the graph as a\nfallback.",
              "label": "repeated",
              "type": "FeatureBit",
              "longType": "lnrpc.FeatureBit",
              "fullType": "lnrpc.FeatureBit",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_parts",
              "description": "The maximum number of partial payments that may be use to complete the full\namount.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "no_inflight_updates",
              "description": "If set, only the final payment update is streamed back. Intermediate updates\nthat show which htlcs are still in flight are suppressed.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_shard_size_msat",
              "description": "The largest payment split that should be attempted when making a payment if\nsplitting is necessary. Setting this value will effectively cause lnd to\nsplit more aggressively, vs only when it thinks it needs to. Note that this\nvalue is in milli-satoshis.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amp",
              "description": "If set, an AMP-payment will be attempted.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "time_pref",
              "description": "The time preference for this payment. Set to -1 to optimize for fees\nonly, to 1 to optimize for reliability only or a value inbetween for a mix.",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "DestCustomRecordsEntry",
          "longName": "SendPaymentRequest.DestCustomRecordsEntry",
          "fullName": "routerrpc.SendPaymentRequest.DestCustomRecordsEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendToRouteRequest",
          "longName": "SendToRouteRequest",
          "fullName": "routerrpc.SendToRouteRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "payment_hash",
              "description": "The payment hash to use for the HTLC.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "route",
              "description": "Route that should be used to attempt to complete the payment.",
              "label": "",
              "type": "Route",
              "longType": "lnrpc.Route",
              "fullType": "lnrpc.Route",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "skip_temp_err",
              "description": "Whether the payment should be marked as failed when a temporary error is\nreturned from the given route. Set it to true so the payment won't be\nfailed unless a terminal error is occurred, such as payment timeout, no\nroutes, incorrect payment details, or insufficient funds.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendToRouteResponse",
          "longName": "SendToRouteResponse",
          "fullName": "routerrpc.SendToRouteResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "preimage",
              "description": "The preimage obtained by making the payment.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "failure",
              "description": "The failure message in case the payment failed.",
              "label": "",
              "type": "Failure",
              "longType": "lnrpc.Failure",
              "fullType": "lnrpc.Failure",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SetMissionControlConfigRequest",
          "longName": "SetMissionControlConfigRequest",
          "fullName": "routerrpc.SetMissionControlConfigRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "config",
              "description": "The config to set for mission control. Note that all values *must* be set,\nbecause the full config will be applied.",
              "label": "",
              "type": "MissionControlConfig",
              "longType": "MissionControlConfig",
              "fullType": "routerrpc.MissionControlConfig",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SetMissionControlConfigResponse",
          "longName": "SetMissionControlConfigResponse",
          "fullName": "routerrpc.SetMissionControlConfigResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "SettleEvent",
          "longName": "SettleEvent",
          "fullName": "routerrpc.SettleEvent",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "preimage",
              "description": "The revealed preimage.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SubscribeHtlcEventsRequest",
          "longName": "SubscribeHtlcEventsRequest",
          "fullName": "routerrpc.SubscribeHtlcEventsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "TrackPaymentRequest",
          "longName": "TrackPaymentRequest",
          "fullName": "routerrpc.TrackPaymentRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "payment_hash",
              "description": "The hash of the payment to look up.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "no_inflight_updates",
              "description": "If set, only the final payment update is streamed back. Intermediate updates\nthat show which htlcs are still in flight are suppressed.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "UpdateChanStatusRequest",
          "longName": "UpdateChanStatusRequest",
          "fullName": "routerrpc.UpdateChanStatusRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chan_point",
              "description": "",
              "label": "",
              "type": "ChannelPoint",
              "longType": "lnrpc.ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "action",
              "description": "",
              "label": "",
              "type": "ChanStatusAction",
              "longType": "ChanStatusAction",
              "fullType": "routerrpc.ChanStatusAction",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "UpdateChanStatusResponse",
          "longName": "UpdateChanStatusResponse",
          "fullName": "routerrpc.UpdateChanStatusResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "XImportMissionControlRequest",
          "longName": "XImportMissionControlRequest",
          "fullName": "routerrpc.XImportMissionControlRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pairs",
              "description": "Node pair-level mission control state to be imported.",
              "label": "repeated",
              "type": "PairHistory",
              "longType": "PairHistory",
              "fullType": "routerrpc.PairHistory",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "force",
              "description": "Whether to force override MC pair history. Note that even with force\noverride the failure pair is imported before the success pair and both\nstill clamp existing failure/success amounts.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "XImportMissionControlResponse",
          "longName": "XImportMissionControlResponse",
          "fullName": "routerrpc.XImportMissionControlResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        }
      ],
      "services": [
        {
          "name": "Router",
          "longName": "Router",
          "fullName": "routerrpc.Router",
          "description": "Router is a service that offers advanced interaction with the router\nsubsystem of the daemon.",
          "methods": [
            {
              "name": "SendPaymentV2",
              "description": "SendPaymentV2 attempts to route a payment described by the passed\nPaymentRequest to the final destination. The call returns a stream of\npayment updates.",
              "requestType": "SendPaymentRequest",
              "requestLongType": "SendPaymentRequest",
              "requestFullType": "routerrpc.SendPaymentRequest",
              "requestStreaming": false,
              "responseType": "Payment",
              "responseLongType": ".lnrpc.Payment",
              "responseFullType": "lnrpc.Payment",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/router/send",
                  "details": {
                    "operationId": "Router_SendPaymentV2",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/routerrpcSendPaymentRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcPayment"
                            }
                          },
                          "title": "Stream result of lnrpcPayment",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SendPaymentV2 attempts to route a payment described by the passed\nPaymentRequest to the final destination. The call returns a stream of\npayment updates.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "TrackPaymentV2",
              "description": "TrackPaymentV2 returns an update stream for the payment identified by the\npayment hash.",
              "requestType": "TrackPaymentRequest",
              "requestLongType": "TrackPaymentRequest",
              "requestFullType": "routerrpc.TrackPaymentRequest",
              "requestStreaming": false,
              "responseType": "Payment",
              "responseLongType": ".lnrpc.Payment",
              "responseFullType": "lnrpc.Payment",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/router/track/{payment_hash}",
                  "details": {
                    "operationId": "Router_TrackPaymentV2",
                    "parameters": [
                      {
                        "description": "The hash of the payment to look up.",
                        "format": "byte",
                        "in": "path",
                        "name": "payment_hash",
                        "required": true,
                        "type": "string"
                      },
                      {
                        "description": "If set, only the final payment update is streamed back. Intermediate updates\nthat show which htlcs are still in flight are suppressed.",
                        "in": "query",
                        "name": "no_inflight_updates",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcPayment"
                            }
                          },
                          "title": "Stream result of lnrpcPayment",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "TrackPaymentV2 returns an update stream for the payment identified by the\npayment hash.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "EstimateRouteFee",
              "description": "EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it\nmay cost to send an HTLC to the target end destination.",
              "requestType": "RouteFeeRequest",
              "requestLongType": "RouteFeeRequest",
              "requestFullType": "routerrpc.RouteFeeRequest",
              "requestStreaming": false,
              "responseType": "RouteFeeResponse",
              "responseLongType": "RouteFeeResponse",
              "responseFullType": "routerrpc.RouteFeeResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/router/route/estimatefee",
                  "details": {
                    "operationId": "Router_EstimateRouteFee",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/routerrpcRouteFeeRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/routerrpcRouteFeeResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it\nmay cost to send an HTLC to the target end destination.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SendToRoute",
              "description": "Deprecated, use SendToRouteV2. SendToRoute attempts to make a payment via\nthe specified route. This method differs from SendPayment in that it\nallows users to specify a full route manually. This can be used for\nthings like rebalancing, and atomic swaps. It differs from the newer\nSendToRouteV2 in that it doesn't return the full HTLC information.",
              "requestType": "SendToRouteRequest",
              "requestLongType": "SendToRouteRequest",
              "requestFullType": "routerrpc.SendToRouteRequest",
              "requestStreaming": false,
              "responseType": "SendToRouteResponse",
              "responseLongType": "SendToRouteResponse",
              "responseFullType": "routerrpc.SendToRouteResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "UNKNOWN",
                  "path": "",
                  "details": null
                }
              ],
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "SendToRouteV2",
              "description": "SendToRouteV2 attempts to make a payment via the specified route. This\nmethod differs from SendPayment in that it allows users to specify a full\nroute manually. This can be used for things like rebalancing, and atomic\nswaps.",
              "requestType": "SendToRouteRequest",
              "requestLongType": "SendToRouteRequest",
              "requestFullType": "routerrpc.SendToRouteRequest",
              "requestStreaming": false,
              "responseType": "HTLCAttempt",
              "responseLongType": ".lnrpc.HTLCAttempt",
              "responseFullType": "lnrpc.HTLCAttempt",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/router/route/send",
                  "details": {
                    "operationId": "Router_SendToRouteV2",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/routerrpcSendToRouteRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcHTLCAttempt"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SendToRouteV2 attempts to make a payment via the specified route. This\nmethod differs from SendPayment in that it allows users to specify a full\nroute manually. This can be used for things like rebalancing, and atomic\nswaps.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ResetMissionControl",
              "description": "ResetMissionControl clears all mission control state and starts with a clean\nslate.",
              "requestType": "ResetMissionControlRequest",
              "requestLongType": "ResetMissionControlRequest",
              "requestFullType": "routerrpc.ResetMissionControlRequest",
              "requestStreaming": false,
              "responseType": "ResetMissionControlResponse",
              "responseLongType": "ResetMissionControlResponse",
              "responseFullType": "routerrpc.ResetMissionControlResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/router/mc/reset",
                  "details": {
                    "operationId": "Router_ResetMissionControl",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/routerrpcResetMissionControlRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/routerrpcResetMissionControlResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ResetMissionControl clears all mission control state and starts with a clean\nslate.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "QueryMissionControl",
              "description": "QueryMissionControl exposes the internal mission control state to callers.\nIt is a development feature.",
              "requestType": "QueryMissionControlRequest",
              "requestLongType": "QueryMissionControlRequest",
              "requestFullType": "routerrpc.QueryMissionControlRequest",
              "requestStreaming": false,
              "responseType": "QueryMissionControlResponse",
              "responseLongType": "QueryMissionControlResponse",
              "responseFullType": "routerrpc.QueryMissionControlResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/router/mc",
                  "details": {
                    "operationId": "Router_QueryMissionControl",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/routerrpcQueryMissionControlResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "QueryMissionControl exposes the internal mission control state to callers.\nIt is a development feature.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "XImportMissionControl",
              "description": "XImportMissionControl is an experimental API that imports the state provided\nto the internal mission control's state, using all results which are more\nrecent than our existing values. These values will only be imported\nin-memory, and will not be persisted across restarts.",
              "requestType": "XImportMissionControlRequest",
              "requestLongType": "XImportMissionControlRequest",
              "requestFullType": "routerrpc.XImportMissionControlRequest",
              "requestStreaming": false,
              "responseType": "XImportMissionControlResponse",
              "responseLongType": "XImportMissionControlResponse",
              "responseFullType": "routerrpc.XImportMissionControlResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/router/x/importhistory",
                  "details": {
                    "operationId": "Router_XImportMissionControl",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/routerrpcXImportMissionControlRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/routerrpcXImportMissionControlResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "XImportMissionControl is an experimental API that imports the state provided\nto the internal mission control's state, using all results which are more\nrecent than our existing values. These values will only be imported\nin-memory, and will not be persisted across restarts.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetMissionControlConfig",
              "description": "GetMissionControlConfig returns mission control's current config.",
              "requestType": "GetMissionControlConfigRequest",
              "requestLongType": "GetMissionControlConfigRequest",
              "requestFullType": "routerrpc.GetMissionControlConfigRequest",
              "requestStreaming": false,
              "responseType": "GetMissionControlConfigResponse",
              "responseLongType": "GetMissionControlConfigResponse",
              "responseFullType": "routerrpc.GetMissionControlConfigResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/router/mccfg",
                  "details": {
                    "operationId": "Router_GetMissionControlConfig",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/routerrpcGetMissionControlConfigResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "GetMissionControlConfig returns mission control's current config.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SetMissionControlConfig",
              "description": "SetMissionControlConfig will set mission control's config, if the config\nprovided is valid.",
              "requestType": "SetMissionControlConfigRequest",
              "requestLongType": "SetMissionControlConfigRequest",
              "requestFullType": "routerrpc.SetMissionControlConfigRequest",
              "requestStreaming": false,
              "responseType": "SetMissionControlConfigResponse",
              "responseLongType": "SetMissionControlConfigResponse",
              "responseFullType": "routerrpc.SetMissionControlConfigResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/router/mccfg",
                  "details": {
                    "operationId": "Router_SetMissionControlConfig",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/routerrpcSetMissionControlConfigRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/routerrpcSetMissionControlConfigResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SetMissionControlConfig will set mission control's config, if the config\nprovided is valid.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "QueryProbability",
              "description": "QueryProbability returns the current success probability estimate for a\ngiven node pair and amount.",
              "requestType": "QueryProbabilityRequest",
              "requestLongType": "QueryProbabilityRequest",
              "requestFullType": "routerrpc.QueryProbabilityRequest",
              "requestStreaming": false,
              "responseType": "QueryProbabilityResponse",
              "responseLongType": "QueryProbabilityResponse",
              "responseFullType": "routerrpc.QueryProbabilityResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/router/mc/probability/{from_node}/{to_node}/{amt_msat}",
                  "details": {
                    "operationId": "Router_QueryProbability",
                    "parameters": [
                      {
                        "description": "The source node pubkey of the pair.",
                        "format": "byte",
                        "in": "path",
                        "name": "from_node",
                        "required": true,
                        "type": "string"
                      },
                      {
                        "description": "The destination node pubkey of the pair.",
                        "format": "byte",
                        "in": "path",
                        "name": "to_node",
                        "required": true,
                        "type": "string"
                      },
                      {
                        "description": "The amount for which to calculate a probability.",
                        "format": "int64",
                        "in": "path",
                        "name": "amt_msat",
                        "required": true,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/routerrpcQueryProbabilityResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "QueryProbability returns the current success probability estimate for a\ngiven node pair and amount.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "BuildRoute",
              "description": "BuildRoute builds a fully specified route based on a list of hop public\nkeys. It retrieves the relevant channel policies from the graph in order to\ncalculate the correct fees and time locks.",
              "requestType": "BuildRouteRequest",
              "requestLongType": "BuildRouteRequest",
              "requestFullType": "routerrpc.BuildRouteRequest",
              "requestStreaming": false,
              "responseType": "BuildRouteResponse",
              "responseLongType": "BuildRouteResponse",
              "responseFullType": "routerrpc.BuildRouteResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/router/route",
                  "details": {
                    "operationId": "Router_BuildRoute",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/routerrpcBuildRouteRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/routerrpcBuildRouteResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "BuildRoute builds a fully specified route based on a list of hop public\nkeys. It retrieves the relevant channel policies from the graph in order to\ncalculate the correct fees and time locks.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SubscribeHtlcEvents",
              "description": "SubscribeHtlcEvents creates a uni-directional stream from the server to\nthe client which delivers a stream of htlc events.",
              "requestType": "SubscribeHtlcEventsRequest",
              "requestLongType": "SubscribeHtlcEventsRequest",
              "requestFullType": "routerrpc.SubscribeHtlcEventsRequest",
              "requestStreaming": false,
              "responseType": "HtlcEvent",
              "responseLongType": "HtlcEvent",
              "responseFullType": "routerrpc.HtlcEvent",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/router/htlcevents",
                  "details": {
                    "operationId": "Router_SubscribeHtlcEvents",
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/routerrpcHtlcEvent"
                            }
                          },
                          "title": "Stream result of routerrpcHtlcEvent",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SubscribeHtlcEvents creates a uni-directional stream from the server to\nthe client which delivers a stream of htlc events.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SendPayment",
              "description": "Deprecated, use SendPaymentV2. SendPayment attempts to route a payment\ndescribed by the passed PaymentRequest to the final destination. The call\nreturns a stream of payment status updates.",
              "requestType": "SendPaymentRequest",
              "requestLongType": "SendPaymentRequest",
              "requestFullType": "routerrpc.SendPaymentRequest",
              "requestStreaming": false,
              "responseType": "PaymentStatus",
              "responseLongType": "PaymentStatus",
              "responseFullType": "routerrpc.PaymentStatus",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "UNKNOWN",
                  "path": "",
                  "details": null
                }
              ],
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "TrackPayment",
              "description": "Deprecated, use TrackPaymentV2. TrackPayment returns an update stream for\nthe payment identified by the payment hash.",
              "requestType": "TrackPaymentRequest",
              "requestLongType": "TrackPaymentRequest",
              "requestFullType": "routerrpc.TrackPaymentRequest",
              "requestStreaming": false,
              "responseType": "PaymentStatus",
              "responseLongType": "PaymentStatus",
              "responseFullType": "routerrpc.PaymentStatus",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "UNKNOWN",
                  "path": "",
                  "details": null
                }
              ],
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "HtlcInterceptor",
              "description": "HtlcInterceptor dispatches a bi-directional streaming RPC in which\nForwarded HTLC requests are sent to the client and the client responds with\na boolean that tells LND if this htlc should be intercepted.\nIn case of interception, the htlc can be either settled, cancelled or\nresumed later by using the ResolveHoldForward endpoint.",
              "requestType": "ForwardHtlcInterceptResponse",
              "requestLongType": "ForwardHtlcInterceptResponse",
              "requestFullType": "routerrpc.ForwardHtlcInterceptResponse",
              "requestStreaming": true,
              "responseType": "ForwardHtlcInterceptRequest",
              "responseLongType": "ForwardHtlcInterceptRequest",
              "responseFullType": "routerrpc.ForwardHtlcInterceptRequest",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/router/htlcinterceptor",
                  "details": {
                    "operationId": "Router_HtlcInterceptor",
                    "parameters": [
                      {
                        "description": " (streaming inputs)",
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/routerrpcForwardHtlcInterceptResponse"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/routerrpcForwardHtlcInterceptRequest"
                            }
                          },
                          "title": "Stream result of routerrpcForwardHtlcInterceptRequest",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "*\nHtlcInterceptor dispatches a bi-directional streaming RPC in which\nForwarded HTLC requests are sent to the client and the client responds with\na boolean that tells LND if this htlc should be intercepted.\nIn case of interception, the htlc can be either settled, cancelled or\nresumed later by using the ResolveHoldForward endpoint.",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            },
            {
              "name": "UpdateChanStatus",
              "description": "UpdateChanStatus attempts to manually set the state of a channel\n(enabled, disabled, or auto). A manual \"disable\" request will cause the\nchannel to stay disabled until a subsequent manual request of either\n\"enable\" or \"auto\".",
              "requestType": "UpdateChanStatusRequest",
              "requestLongType": "UpdateChanStatusRequest",
              "requestFullType": "routerrpc.UpdateChanStatusRequest",
              "requestStreaming": false,
              "responseType": "UpdateChanStatusResponse",
              "responseLongType": "UpdateChanStatusResponse",
              "responseFullType": "routerrpc.UpdateChanStatusResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/router/updatechanstatus",
                  "details": {
                    "operationId": "Router_UpdateChanStatus",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/routerrpcUpdateChanStatusRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/routerrpcUpdateChanStatusResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "UpdateChanStatus attempts to manually set the state of a channel\n(enabled, disabled, or auto). A manual \"disable\" request will cause the\nchannel to stay disabled until a subsequent manual request of either\n\"enable\" or \"auto\".",
                    "tags": [
                      "Router"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "invoicesrpc/invoices.proto",
      "description": "",
      "package": "invoicesrpc",
      "hasEnums": true,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [
        {
          "name": "LookupModifier",
          "longName": "LookupModifier",
          "fullName": "invoicesrpc.LookupModifier",
          "description": "",
          "values": [
            {
              "name": "DEFAULT",
              "number": "0",
              "description": "The default look up modifier, no look up behavior is changed."
            },
            {
              "name": "HTLC_SET_ONLY",
              "number": "1",
              "description": "Indicates that when a look up is done based on a set_id, then only that set\nof HTLCs related to that set ID should be returned."
            },
            {
              "name": "HTLC_SET_BLANK",
              "number": "2",
              "description": "Indicates that when a look up is done using a payment_addr, then no HTLCs\nrelated to the payment_addr should be returned. This is useful when one\nwants to be able to obtain the set of associated setIDs with a given\ninvoice, then look up the sub-invoices \"projected\" by that set ID."
            }
          ]
        }
      ],
      "extensions": [],
      "messages": [
        {
          "name": "AddHoldInvoiceRequest",
          "longName": "AddHoldInvoiceRequest",
          "fullName": "invoicesrpc.AddHoldInvoiceRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "memo",
              "description": "An optional memo to attach along with the invoice. Used for record keeping\npurposes for the invoice's creator, and will also be set in the description\nfield of the encoded payment request if the description_hash field is not\nbeing used.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "hash",
              "description": "The hash of the preimage",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "The value of this invoice in satoshis\n\nThe fields value and value_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value_msat",
              "description": "The value of this invoice in millisatoshis\n\nThe fields value and value_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "description_hash",
              "description": "Hash (SHA-256) of a description of the payment. Used if the description of\npayment (memo) is too long to naturally fit within the description field\nof an encoded payment request.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "expiry",
              "description": "Payment request expiry time in seconds. Default is 3600 (1 hour).",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fallback_addr",
              "description": "Fallback on-chain address.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "cltv_expiry",
              "description": "Delta to use for the time-lock of the CLTV extended to the final hop.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "route_hints",
              "description": "Route hints that can each be individually used to assist in reaching the\ninvoice's destination.",
              "label": "repeated",
              "type": "RouteHint",
              "longType": "lnrpc.RouteHint",
              "fullType": "lnrpc.RouteHint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "private",
              "description": "Whether this invoice should include routing hints for private channels.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AddHoldInvoiceResp",
          "longName": "AddHoldInvoiceResp",
          "fullName": "invoicesrpc.AddHoldInvoiceResp",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "payment_request",
              "description": "A bare-bones invoice for a payment within the Lightning Network. With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "add_index",
              "description": "The \"add\" index of this invoice. Each newly created invoice will increment\nthis index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all added\ninvoices with an add_index greater than this one.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_addr",
              "description": "The payment address of the generated invoice. This value should be used\nin all payments for this invoice as we require it for end to end\nsecurity.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "CancelInvoiceMsg",
          "longName": "CancelInvoiceMsg",
          "fullName": "invoicesrpc.CancelInvoiceMsg",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "payment_hash",
              "description": "Hash corresponding to the (hold) invoice to cancel. When using\nREST, this field must be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "CancelInvoiceResp",
          "longName": "CancelInvoiceResp",
          "fullName": "invoicesrpc.CancelInvoiceResp",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "LookupInvoiceMsg",
          "longName": "LookupInvoiceMsg",
          "fullName": "invoicesrpc.LookupInvoiceMsg",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "payment_hash",
              "description": "When using REST, this field must be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "invoice_ref",
              "defaultValue": ""
            },
            {
              "name": "payment_addr",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "invoice_ref",
              "defaultValue": ""
            },
            {
              "name": "set_id",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "invoice_ref",
              "defaultValue": ""
            },
            {
              "name": "lookup_modifier",
              "description": "",
              "label": "",
              "type": "LookupModifier",
              "longType": "LookupModifier",
              "fullType": "invoicesrpc.LookupModifier",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SettleInvoiceMsg",
          "longName": "SettleInvoiceMsg",
          "fullName": "invoicesrpc.SettleInvoiceMsg",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "preimage",
              "description": "Externally discovered pre-image that should be used to settle the hold\ninvoice.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SettleInvoiceResp",
          "longName": "SettleInvoiceResp",
          "fullName": "invoicesrpc.SettleInvoiceResp",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "SubscribeSingleInvoiceRequest",
          "longName": "SubscribeSingleInvoiceRequest",
          "fullName": "invoicesrpc.SubscribeSingleInvoiceRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "r_hash",
              "description": "Hash corresponding to the (hold) invoice to subscribe to. When using\nREST, this field must be encoded as base64url.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": [
        {
          "name": "Invoices",
          "longName": "Invoices",
          "fullName": "invoicesrpc.Invoices",
          "description": "Invoices is a service that can be used to create, accept, settle and cancel\ninvoices.",
          "methods": [
            {
              "name": "SubscribeSingleInvoice",
              "description": "SubscribeSingleInvoice returns a uni-directional stream (server -\u003e client)\nto notify the client of state transitions of the specified invoice.\nInitially the current invoice state is always sent out.",
              "requestType": "SubscribeSingleInvoiceRequest",
              "requestLongType": "SubscribeSingleInvoiceRequest",
              "requestFullType": "invoicesrpc.SubscribeSingleInvoiceRequest",
              "requestStreaming": false,
              "responseType": "Invoice",
              "responseLongType": ".lnrpc.Invoice",
              "responseFullType": "lnrpc.Invoice",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/invoices/subscribe/{r_hash}",
                  "details": {
                    "operationId": "Invoices_SubscribeSingleInvoice",
                    "parameters": [
                      {
                        "description": "Hash corresponding to the (hold) invoice to subscribe to. When using\nREST, this field must be encoded as base64url.",
                        "format": "byte",
                        "in": "path",
                        "name": "r_hash",
                        "required": true,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcInvoice"
                            }
                          },
                          "title": "Stream result of lnrpcInvoice",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SubscribeSingleInvoice returns a uni-directional stream (server -\u003e client)\nto notify the client of state transitions of the specified invoice.\nInitially the current invoice state is always sent out.",
                    "tags": [
                      "Invoices"
                    ]
                  }
                }
              ]
            },
            {
              "name": "CancelInvoice",
              "description": "CancelInvoice cancels a currently open invoice. If the invoice is already\ncanceled, this call will succeed. If the invoice is already settled, it will\nfail.",
              "requestType": "CancelInvoiceMsg",
              "requestLongType": "CancelInvoiceMsg",
              "requestFullType": "invoicesrpc.CancelInvoiceMsg",
              "requestStreaming": false,
              "responseType": "CancelInvoiceResp",
              "responseLongType": "CancelInvoiceResp",
              "responseFullType": "invoicesrpc.CancelInvoiceResp",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/invoices/cancel",
                  "details": {
                    "operationId": "Invoices_CancelInvoice",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/invoicesrpcCancelInvoiceMsg"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/invoicesrpcCancelInvoiceResp"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "CancelInvoice cancels a currently open invoice. If the invoice is already\ncanceled, this call will succeed. If the invoice is already settled, it will\nfail.",
                    "tags": [
                      "Invoices"
                    ]
                  }
                }
              ]
            },
            {
              "name": "AddHoldInvoice",
              "description": "AddHoldInvoice creates a hold invoice. It ties the invoice to the hash\nsupplied in the request.",
              "requestType": "AddHoldInvoiceRequest",
              "requestLongType": "AddHoldInvoiceRequest",
              "requestFullType": "invoicesrpc.AddHoldInvoiceRequest",
              "requestStreaming": false,
              "responseType": "AddHoldInvoiceResp",
              "responseLongType": "AddHoldInvoiceResp",
              "responseFullType": "invoicesrpc.AddHoldInvoiceResp",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/invoices/hodl",
                  "details": {
                    "operationId": "Invoices_AddHoldInvoice",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/invoicesrpcAddHoldInvoiceRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/invoicesrpcAddHoldInvoiceResp"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "AddHoldInvoice creates a hold invoice. It ties the invoice to the hash\nsupplied in the request.",
                    "tags": [
                      "Invoices"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SettleInvoice",
              "description": "SettleInvoice settles an accepted invoice. If the invoice is already\nsettled, this call will succeed.",
              "requestType": "SettleInvoiceMsg",
              "requestLongType": "SettleInvoiceMsg",
              "requestFullType": "invoicesrpc.SettleInvoiceMsg",
              "requestStreaming": false,
              "responseType": "SettleInvoiceResp",
              "responseLongType": "SettleInvoiceResp",
              "responseFullType": "invoicesrpc.SettleInvoiceResp",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/invoices/settle",
                  "details": {
                    "operationId": "Invoices_SettleInvoice",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/invoicesrpcSettleInvoiceMsg"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/invoicesrpcSettleInvoiceResp"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SettleInvoice settles an accepted invoice. If the invoice is already\nsettled, this call will succeed.",
                    "tags": [
                      "Invoices"
                    ]
                  }
                }
              ]
            },
            {
              "name": "LookupInvoiceV2",
              "description": "LookupInvoiceV2 attempts to look up at invoice. An invoice can be refrenced\nusing either its payment hash, payment address, or set ID.",
              "requestType": "LookupInvoiceMsg",
              "requestLongType": "LookupInvoiceMsg",
              "requestFullType": "invoicesrpc.LookupInvoiceMsg",
              "requestStreaming": false,
              "responseType": "Invoice",
              "responseLongType": ".lnrpc.Invoice",
              "responseFullType": "lnrpc.Invoice",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/invoices/lookup",
                  "details": {
                    "operationId": "Invoices_LookupInvoiceV2",
                    "parameters": [
                      {
                        "description": "When using REST, this field must be encoded as base64.",
                        "format": "byte",
                        "in": "query",
                        "name": "payment_hash",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "format": "byte",
                        "in": "query",
                        "name": "payment_addr",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "format": "byte",
                        "in": "query",
                        "name": "set_id",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "default": "DEFAULT",
                        "description": " - DEFAULT: The default look up modifier, no look up behavior is changed.\n - HTLC_SET_ONLY: Indicates that when a look up is done based on a set_id, then only that set\nof HTLCs related to that set ID should be returned.\n - HTLC_SET_BLANK: Indicates that when a look up is done using a payment_addr, then no HTLCs\nrelated to the payment_addr should be returned. This is useful when one\nwants to be able to obtain the set of associated setIDs with a given\ninvoice, then look up the sub-invoices \"projected\" by that set ID.",
                        "enum": [
                          "DEFAULT",
                          "HTLC_SET_ONLY",
                          "HTLC_SET_BLANK"
                        ],
                        "in": "query",
                        "name": "lookup_modifier",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcInvoice"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "LookupInvoiceV2 attempts to look up at invoice. An invoice can be refrenced\nusing either its payment hash, payment address, or set ID.",
                    "tags": [
                      "Invoices"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "peersrpc/peers.proto",
      "description": "",
      "package": "peersrpc",
      "hasEnums": true,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [
        {
          "name": "FeatureSet",
          "longName": "FeatureSet",
          "fullName": "peersrpc.FeatureSet",
          "description": "",
          "values": [
            {
              "name": "SET_INIT",
              "number": "0",
              "description": "SET_INIT identifies features that should be sent in an Init message to\na remote peer."
            },
            {
              "name": "SET_LEGACY_GLOBAL",
              "number": "1",
              "description": "SET_LEGACY_GLOBAL identifies features that should be set in the legacy\nGlobalFeatures field of an Init message, which maintains backwards\ncompatibility with nodes that haven't implemented flat features."
            },
            {
              "name": "SET_NODE_ANN",
              "number": "2",
              "description": "SET_NODE_ANN identifies features that should be advertised on node\nannouncements."
            },
            {
              "name": "SET_INVOICE",
              "number": "3",
              "description": "SET_INVOICE identifies features that should be advertised on invoices\ngenerated by the daemon."
            },
            {
              "name": "SET_INVOICE_AMP",
              "number": "4",
              "description": "SET_INVOICE_AMP identifies the features that should be advertised on\nAMP invoices generated by the daemon."
            }
          ]
        },
        {
          "name": "UpdateAction",
          "longName": "UpdateAction",
          "fullName": "peersrpc.UpdateAction",
          "description": "UpdateAction is used to determine the kind of action we are referring to.",
          "values": [
            {
              "name": "ADD",
              "number": "0",
              "description": "ADD indicates this is an \"insertion\" kind of action."
            },
            {
              "name": "REMOVE",
              "number": "1",
              "description": "REMOVE indicates this is a \"deletion\" kind of action."
            }
          ]
        }
      ],
      "extensions": [],
      "messages": [
        {
          "name": "NodeAnnouncementUpdateRequest",
          "longName": "NodeAnnouncementUpdateRequest",
          "fullName": "peersrpc.NodeAnnouncementUpdateRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "feature_updates",
              "description": "Set of changes for the features that the node supports.",
              "label": "repeated",
              "type": "UpdateFeatureAction",
              "longType": "UpdateFeatureAction",
              "fullType": "peersrpc.UpdateFeatureAction",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "color",
              "description": "Color is the node's color in hex code format.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "alias",
              "description": "Alias or nick name of the node.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "address_updates",
              "description": "Set of changes for the node's known addresses.",
              "label": "repeated",
              "type": "UpdateAddressAction",
              "longType": "UpdateAddressAction",
              "fullType": "peersrpc.UpdateAddressAction",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "NodeAnnouncementUpdateResponse",
          "longName": "NodeAnnouncementUpdateResponse",
          "fullName": "peersrpc.NodeAnnouncementUpdateResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "ops",
              "description": "",
              "label": "repeated",
              "type": "Op",
              "longType": "lnrpc.Op",
              "fullType": "lnrpc.Op",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "UpdateAddressAction",
          "longName": "UpdateAddressAction",
          "fullName": "peersrpc.UpdateAddressAction",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "action",
              "description": "Determines the kind of action.",
              "label": "",
              "type": "UpdateAction",
              "longType": "UpdateAction",
              "fullType": "peersrpc.UpdateAction",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "address",
              "description": "The address used to apply the update action.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "UpdateFeatureAction",
          "longName": "UpdateFeatureAction",
          "fullName": "peersrpc.UpdateFeatureAction",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "action",
              "description": "Determines the kind of action.",
              "label": "",
              "type": "UpdateAction",
              "longType": "UpdateAction",
              "fullType": "peersrpc.UpdateAction",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "feature_bit",
              "description": "The feature bit used to apply the update action.",
              "label": "",
              "type": "FeatureBit",
              "longType": "lnrpc.FeatureBit",
              "fullType": "lnrpc.FeatureBit",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": [
        {
          "name": "Peers",
          "longName": "Peers",
          "fullName": "peersrpc.Peers",
          "description": "Peers is a service that can be used to get information and interact\nwith the other nodes of the newtwork.",
          "methods": [
            {
              "name": "UpdateNodeAnnouncement",
              "description": "lncli: peers updatenodeannouncement\nUpdateNodeAnnouncement allows the caller to update the node parameters\nand broadcasts a new version of the node announcement to its peers.",
              "requestType": "NodeAnnouncementUpdateRequest",
              "requestLongType": "NodeAnnouncementUpdateRequest",
              "requestFullType": "peersrpc.NodeAnnouncementUpdateRequest",
              "requestStreaming": false,
              "responseType": "NodeAnnouncementUpdateResponse",
              "responseLongType": "NodeAnnouncementUpdateResponse",
              "responseFullType": "peersrpc.NodeAnnouncementUpdateResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/peers/nodeannouncement",
                  "details": {
                    "operationId": "Peers_UpdateNodeAnnouncement",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/peersrpcNodeAnnouncementUpdateRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/peersrpcNodeAnnouncementUpdateResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: peers updatenodeannouncement\nUpdateNodeAnnouncement allows the caller to update the node parameters\nand broadcasts a new version of the node announcement to its peers.",
                    "tags": [
                      "Peers"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "lnclipb/lncli.proto",
      "description": "",
      "package": "lnclipb",
      "hasEnums": false,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": false,
      "enums": [],
      "extensions": [],
      "messages": [
        {
          "name": "VersionResponse",
          "longName": "VersionResponse",
          "fullName": "lnclipb.VersionResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "lncli",
              "description": "The version information for lncli.",
              "label": "",
              "type": "Version",
              "longType": "verrpc.Version",
              "fullType": "verrpc.Version",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "lnd",
              "description": "The version information for lnd.",
              "label": "",
              "type": "Version",
              "longType": "verrpc.Version",
              "fullType": "verrpc.Version",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": []
    },
    {
      "name": "neutrinorpc/neutrino.proto",
      "description": "",
      "package": "neutrinorpc",
      "hasEnums": false,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [],
      "extensions": [],
      "messages": [
        {
          "name": "AddPeerRequest",
          "longName": "AddPeerRequest",
          "fullName": "neutrinorpc.AddPeerRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "peer_addrs",
              "description": "Peer to add.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AddPeerResponse",
          "longName": "AddPeerResponse",
          "fullName": "neutrinorpc.AddPeerResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "DisconnectPeerRequest",
          "longName": "DisconnectPeerRequest",
          "fullName": "neutrinorpc.DisconnectPeerRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "peer_addrs",
              "description": "Peer to disconnect.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "DisconnectPeerResponse",
          "longName": "DisconnectPeerResponse",
          "fullName": "neutrinorpc.DisconnectPeerResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "GetBlockHeaderRequest",
          "longName": "GetBlockHeaderRequest",
          "fullName": "neutrinorpc.GetBlockHeaderRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "hash",
              "description": "Block hash in hex notation.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "GetBlockHeaderResponse",
          "longName": "GetBlockHeaderResponse",
          "fullName": "neutrinorpc.GetBlockHeaderResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "hash",
              "description": "The block hash (same as provided).",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "confirmations",
              "description": "The number of confirmations.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "stripped_size",
              "description": "The block size excluding witness data.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "size",
              "description": "The block size (bytes).",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "weight",
              "description": "The block weight as defined in BIP 141.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "height",
              "description": "The block height or index.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "version",
              "description": "The block version.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "version_hex",
              "description": "The block version.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "merkleroot",
              "description": "The merkle root.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "time",
              "description": "The block time in seconds since epoch (Jan 1 1970 GMT).",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "nonce",
              "description": "The nonce.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "bits",
              "description": "The bits in hex notation.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "ntx",
              "description": "The number of transactions in the block.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "previous_block_hash",
              "description": "The hash of the previous block.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "raw_hex",
              "description": "The raw hex of the block.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "GetBlockRequest",
          "longName": "GetBlockRequest",
          "fullName": "neutrinorpc.GetBlockRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "hash",
              "description": "Block hash in hex notation.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "GetBlockResponse",
          "longName": "GetBlockResponse",
          "fullName": "neutrinorpc.GetBlockResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "hash",
              "description": "The block hash (same as provided).",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "confirmations",
              "description": "The number of confirmations.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "stripped_size",
              "description": "The block size excluding witness data.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "size",
              "description": "The block size (bytes).",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "weight",
              "description": "The block weight as defined in BIP 141.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "height",
              "description": "The block height or index.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "version",
              "description": "The block version.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "version_hex",
              "description": "The block version.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "merkleroot",
              "description": "The merkle root.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "tx",
              "description": "List of transaction ids.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "time",
              "description": "The block time in seconds since epoch (Jan 1 1970 GMT).",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "nonce",
              "description": "The nonce.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "bits",
              "description": "The bits in hex notation.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "ntx",
              "description": "The number of transactions in the block.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "previous_block_hash",
              "description": "The hash of the previous block.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "raw_hex",
              "description": "The raw hex of the block.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "GetCFilterRequest",
          "longName": "GetCFilterRequest",
          "fullName": "neutrinorpc.GetCFilterRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "hash",
              "description": "Block hash in hex notation.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "GetCFilterResponse",
          "longName": "GetCFilterResponse",
          "fullName": "neutrinorpc.GetCFilterResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "filter",
              "description": "GCS filter.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "IsBannedRequest",
          "longName": "IsBannedRequest",
          "fullName": "neutrinorpc.IsBannedRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "peer_addrs",
              "description": "Peer to lookup.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "IsBannedResponse",
          "longName": "IsBannedResponse",
          "fullName": "neutrinorpc.IsBannedResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "banned",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "StatusRequest",
          "longName": "StatusRequest",
          "fullName": "neutrinorpc.StatusRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "StatusResponse",
          "longName": "StatusResponse",
          "fullName": "neutrinorpc.StatusResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "active",
              "description": "Indicates whether the neutrino backend is active or not.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "synced",
              "description": "Is fully synced.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "block_height",
              "description": "Best block height.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "block_hash",
              "description": "Best block hash.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "peers",
              "description": "Connected peers.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": [
        {
          "name": "NeutrinoKit",
          "longName": "NeutrinoKit",
          "fullName": "neutrinorpc.NeutrinoKit",
          "description": "NeutrinoKit is a service that can be used to get information about the\ncurrent state of the neutrino instance, fetch blocks and add/remove peers.",
          "methods": [
            {
              "name": "Status",
              "description": "Status returns the status of the light client neutrino instance,\nalong with height and hash of the best block, and a list of connected\npeers.",
              "requestType": "StatusRequest",
              "requestLongType": "StatusRequest",
              "requestFullType": "neutrinorpc.StatusRequest",
              "requestStreaming": false,
              "responseType": "StatusResponse",
              "responseLongType": "StatusResponse",
              "responseFullType": "neutrinorpc.StatusResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/neutrino/status",
                  "details": {
                    "operationId": "NeutrinoKit_Status",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/neutrinorpcStatusResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "Status returns the status of the light client neutrino instance,\nalong with height and hash of the best block, and a list of connected\npeers.",
                    "tags": [
                      "NeutrinoKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "AddPeer",
              "description": "AddPeer adds a new peer that has already been connected to the server.",
              "requestType": "AddPeerRequest",
              "requestLongType": "AddPeerRequest",
              "requestFullType": "neutrinorpc.AddPeerRequest",
              "requestStreaming": false,
              "responseType": "AddPeerResponse",
              "responseLongType": "AddPeerResponse",
              "responseFullType": "neutrinorpc.AddPeerResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/neutrino/addpeer",
                  "details": {
                    "operationId": "NeutrinoKit_AddPeer",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/neutrinorpcAddPeerRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/neutrinorpcAddPeerResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "AddPeer adds a new peer that has already been connected to the server.",
                    "tags": [
                      "NeutrinoKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "DisconnectPeer",
              "description": "DisconnectPeer disconnects a peer by target address. Both outbound and\ninbound nodes will be searched for the target node. An error message will\nbe returned if the peer was not found.",
              "requestType": "DisconnectPeerRequest",
              "requestLongType": "DisconnectPeerRequest",
              "requestFullType": "neutrinorpc.DisconnectPeerRequest",
              "requestStreaming": false,
              "responseType": "DisconnectPeerResponse",
              "responseLongType": "DisconnectPeerResponse",
              "responseFullType": "neutrinorpc.DisconnectPeerResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/neutrino/disconnect",
                  "details": {
                    "operationId": "NeutrinoKit_DisconnectPeer",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/neutrinorpcDisconnectPeerRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/neutrinorpcDisconnectPeerResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "DisconnectPeer disconnects a peer by target address. Both outbound and\ninbound nodes will be searched for the target node. An error message will\nbe returned if the peer was not found.",
                    "tags": [
                      "NeutrinoKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "IsBanned",
              "description": "IsBanned returns true if the peer is banned, otherwise false.",
              "requestType": "IsBannedRequest",
              "requestLongType": "IsBannedRequest",
              "requestFullType": "neutrinorpc.IsBannedRequest",
              "requestStreaming": false,
              "responseType": "IsBannedResponse",
              "responseLongType": "IsBannedResponse",
              "responseFullType": "neutrinorpc.IsBannedResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/neutrino/isbanned",
                  "details": {
                    "operationId": "NeutrinoKit_IsBanned",
                    "parameters": [
                      {
                        "description": "Peer to lookup.",
                        "in": "query",
                        "name": "peer_addrs",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/neutrinorpcIsBannedResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "IsBanned returns true if the peer is banned, otherwise false.",
                    "tags": [
                      "NeutrinoKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetBlockHeader",
              "description": "GetBlockHeader returns a block header with a particular block hash.",
              "requestType": "GetBlockHeaderRequest",
              "requestLongType": "GetBlockHeaderRequest",
              "requestFullType": "neutrinorpc.GetBlockHeaderRequest",
              "requestStreaming": false,
              "responseType": "GetBlockHeaderResponse",
              "responseLongType": "GetBlockHeaderResponse",
              "responseFullType": "neutrinorpc.GetBlockHeaderResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/neutrino/blockheader/{hash}",
                  "details": {
                    "operationId": "NeutrinoKit_GetBlockHeader",
                    "parameters": [
                      {
                        "description": "Block hash in hex notation.",
                        "in": "path",
                        "name": "hash",
                        "required": true,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/neutrinorpcGetBlockHeaderResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "GetBlockHeader returns a block header with a particular block hash.",
                    "tags": [
                      "NeutrinoKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetBlock",
              "description": "GetBlock returns a block with a particular block hash.",
              "requestType": "GetBlockRequest",
              "requestLongType": "GetBlockRequest",
              "requestFullType": "neutrinorpc.GetBlockRequest",
              "requestStreaming": false,
              "responseType": "GetBlockResponse",
              "responseLongType": "GetBlockResponse",
              "responseFullType": "neutrinorpc.GetBlockResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/neutrino/block/{hash}",
                  "details": {
                    "operationId": "NeutrinoKit_GetBlock",
                    "parameters": [
                      {
                        "description": "Block hash in hex notation.",
                        "in": "path",
                        "name": "hash",
                        "required": true,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/neutrinorpcGetBlockResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "GetBlock returns a block with a particular block hash.",
                    "tags": [
                      "NeutrinoKit"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetCFilter",
              "description": "GetCFilter returns a compact filter from a block.",
              "requestType": "GetCFilterRequest",
              "requestLongType": "GetCFilterRequest",
              "requestFullType": "neutrinorpc.GetCFilterRequest",
              "requestStreaming": false,
              "responseType": "GetCFilterResponse",
              "responseLongType": "GetCFilterResponse",
              "responseFullType": "neutrinorpc.GetCFilterResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/neutrino/cfilter/{hash}",
                  "details": {
                    "operationId": "NeutrinoKit_GetCFilter",
                    "parameters": [
                      {
                        "description": "Block hash in hex notation.",
                        "in": "path",
                        "name": "hash",
                        "required": true,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/neutrinorpcGetCFilterResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "GetCFilter returns a compact filter from a block.",
                    "tags": [
                      "NeutrinoKit"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "devrpc/dev.proto",
      "description": "",
      "package": "devrpc",
      "hasEnums": false,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [],
      "extensions": [],
      "messages": [
        {
          "name": "ImportGraphResponse",
          "longName": "ImportGraphResponse",
          "fullName": "devrpc.ImportGraphResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        }
      ],
      "services": [
        {
          "name": "Dev",
          "longName": "Dev",
          "fullName": "devrpc.Dev",
          "description": "",
          "methods": [
            {
              "name": "ImportGraph",
              "description": "ImportGraph imports a ChannelGraph into the graph database. Should only be\nused for development.",
              "requestType": "ChannelGraph",
              "requestLongType": ".lnrpc.ChannelGraph",
              "requestFullType": "lnrpc.ChannelGraph",
              "requestStreaming": false,
              "responseType": "ImportGraphResponse",
              "responseLongType": "ImportGraphResponse",
              "responseFullType": "devrpc.ImportGraphResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/dev/importgraph",
                  "details": {
                    "operationId": "Dev_ImportGraph",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcChannelGraph"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/devrpcImportGraphResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ImportGraph imports a ChannelGraph into the graph database. Should only be\nused for development.",
                    "tags": [
                      "Dev"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "lightning.proto",
      "description": "",
      "package": "lnrpc",
      "hasEnums": true,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [
        {
          "name": "AddressType",
          "longName": "AddressType",
          "fullName": "lnrpc.AddressType",
          "description": "`AddressType` has to be one of:\n\n- `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)\n- `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)\n- `p2tr`: Pay to taproot pubkey (`TAPROOT_PUBKEY` = 4)",
          "values": [
            {
              "name": "WITNESS_PUBKEY_HASH",
              "number": "0",
              "description": ""
            },
            {
              "name": "NESTED_PUBKEY_HASH",
              "number": "1",
              "description": ""
            },
            {
              "name": "UNUSED_WITNESS_PUBKEY_HASH",
              "number": "2",
              "description": ""
            },
            {
              "name": "UNUSED_NESTED_PUBKEY_HASH",
              "number": "3",
              "description": ""
            },
            {
              "name": "TAPROOT_PUBKEY",
              "number": "4",
              "description": ""
            },
            {
              "name": "UNUSED_TAPROOT_PUBKEY",
              "number": "5",
              "description": ""
            }
          ]
        },
        {
          "name": "ClosureType",
          "longName": "ChannelCloseSummary.ClosureType",
          "fullName": "lnrpc.ChannelCloseSummary.ClosureType",
          "description": "",
          "values": [
            {
              "name": "COOPERATIVE_CLOSE",
              "number": "0",
              "description": ""
            },
            {
              "name": "LOCAL_FORCE_CLOSE",
              "number": "1",
              "description": ""
            },
            {
              "name": "REMOTE_FORCE_CLOSE",
              "number": "2",
              "description": ""
            },
            {
              "name": "BREACH_CLOSE",
              "number": "3",
              "description": ""
            },
            {
              "name": "FUNDING_CANCELED",
              "number": "4",
              "description": ""
            },
            {
              "name": "ABANDONED",
              "number": "5",
              "description": ""
            }
          ]
        },
        {
          "name": "UpdateType",
          "longName": "ChannelEventUpdate.UpdateType",
          "fullName": "lnrpc.ChannelEventUpdate.UpdateType",
          "description": "",
          "values": [
            {
              "name": "OPEN_CHANNEL",
              "number": "0",
              "description": ""
            },
            {
              "name": "CLOSED_CHANNEL",
              "number": "1",
              "description": ""
            },
            {
              "name": "ACTIVE_CHANNEL",
              "number": "2",
              "description": ""
            },
            {
              "name": "INACTIVE_CHANNEL",
              "number": "3",
              "description": ""
            },
            {
              "name": "PENDING_OPEN_CHANNEL",
              "number": "4",
              "description": ""
            },
            {
              "name": "FULLY_RESOLVED_CHANNEL",
              "number": "5",
              "description": ""
            }
          ]
        },
        {
          "name": "CommitmentType",
          "longName": "CommitmentType",
          "fullName": "lnrpc.CommitmentType",
          "description": "",
          "values": [
            {
              "name": "UNKNOWN_COMMITMENT_TYPE",
              "number": "0",
              "description": "Returned when the commitment type isn't known or unavailable."
            },
            {
              "name": "LEGACY",
              "number": "1",
              "description": "A channel using the legacy commitment format having tweaked to_remote\nkeys."
            },
            {
              "name": "STATIC_REMOTE_KEY",
              "number": "2",
              "description": "A channel that uses the modern commitment format where the key in the\noutput of the remote party does not change each state. This makes back\nup and recovery easier as when the channel is closed, the funds go\ndirectly to that key."
            },
            {
              "name": "ANCHORS",
              "number": "3",
              "description": "A channel that uses a commitment format that has anchor outputs on the\ncommitments, allowing fee bumping after a force close transaction has\nbeen broadcast."
            },
            {
              "name": "SCRIPT_ENFORCED_LEASE",
              "number": "4",
              "description": "A channel that uses a commitment type that builds upon the anchors\ncommitment format, but in addition requires a CLTV clause to spend outputs\npaying to the channel initiator. This is intended for use on leased channels\nto guarantee that the channel initiator has no incentives to close a leased\nchannel before its maturity date."
            }
          ]
        },
        {
          "name": "FailureCode",
          "longName": "Failure.FailureCode",
          "fullName": "lnrpc.Failure.FailureCode",
          "description": "",
          "values": [
            {
              "name": "RESERVED",
              "number": "0",
              "description": "The numbers assigned in this enumeration match the failure codes as\ndefined in BOLT #4. Because protobuf 3 requires enums to start with 0,\na RESERVED value is added."
            },
            {
              "name": "INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS",
              "number": "1",
              "description": ""
            },
            {
              "name": "INCORRECT_PAYMENT_AMOUNT",
              "number": "2",
              "description": ""
            },
            {
              "name": "FINAL_INCORRECT_CLTV_EXPIRY",
              "number": "3",
              "description": ""
            },
            {
              "name": "FINAL_INCORRECT_HTLC_AMOUNT",
              "number": "4",
              "description": ""
            },
            {
              "name": "FINAL_EXPIRY_TOO_SOON",
              "number": "5",
              "description": ""
            },
            {
              "name": "INVALID_REALM",
              "number": "6",
              "description": ""
            },
            {
              "name": "EXPIRY_TOO_SOON",
              "number": "7",
              "description": ""
            },
            {
              "name": "INVALID_ONION_VERSION",
              "number": "8",
              "description": ""
            },
            {
              "name": "INVALID_ONION_HMAC",
              "number": "9",
              "description": ""
            },
            {
              "name": "INVALID_ONION_KEY",
              "number": "10",
              "description": ""
            },
            {
              "name": "AMOUNT_BELOW_MINIMUM",
              "number": "11",
              "description": ""
            },
            {
              "name": "FEE_INSUFFICIENT",
              "number": "12",
              "description": ""
            },
            {
              "name": "INCORRECT_CLTV_EXPIRY",
              "number": "13",
              "description": ""
            },
            {
              "name": "CHANNEL_DISABLED",
              "number": "14",
              "description": ""
            },
            {
              "name": "TEMPORARY_CHANNEL_FAILURE",
              "number": "15",
              "description": ""
            },
            {
              "name": "REQUIRED_NODE_FEATURE_MISSING",
              "number": "16",
              "description": ""
            },
            {
              "name": "REQUIRED_CHANNEL_FEATURE_MISSING",
              "number": "17",
              "description": ""
            },
            {
              "name": "UNKNOWN_NEXT_PEER",
              "number": "18",
              "description": ""
            },
            {
              "name": "TEMPORARY_NODE_FAILURE",
              "number": "19",
              "description": ""
            },
            {
              "name": "PERMANENT_NODE_FAILURE",
              "number": "20",
              "description": ""
            },
            {
              "name": "PERMANENT_CHANNEL_FAILURE",
              "number": "21",
              "description": ""
            },
            {
              "name": "EXPIRY_TOO_FAR",
              "number": "22",
              "description": ""
            },
            {
              "name": "MPP_TIMEOUT",
              "number": "23",
              "description": ""
            },
            {
              "name": "INVALID_ONION_PAYLOAD",
              "number": "24",
              "description": ""
            },
            {
              "name": "INTERNAL_FAILURE",
              "number": "997",
              "description": "An internal error occurred."
            },
            {
              "name": "UNKNOWN_FAILURE",
              "number": "998",
              "description": "The error source is known, but the failure itself couldn't be decoded."
            },
            {
              "name": "UNREADABLE_FAILURE",
              "number": "999",
              "description": "An unreadable failure result is returned if the received failure message\ncannot be decrypted. In that case the error source is unknown."
            }
          ]
        },
        {
          "name": "FeatureBit",
          "longName": "FeatureBit",
          "fullName": "lnrpc.FeatureBit",
          "description": "",
          "values": [
            {
              "name": "DATALOSS_PROTECT_REQ",
              "number": "0",
              "description": ""
            },
            {
              "name": "DATALOSS_PROTECT_OPT",
              "number": "1",
              "description": ""
            },
            {
              "name": "INITIAL_ROUING_SYNC",
              "number": "3",
              "description": ""
            },
            {
              "name": "UPFRONT_SHUTDOWN_SCRIPT_REQ",
              "number": "4",
              "description": ""
            },
            {
              "name": "UPFRONT_SHUTDOWN_SCRIPT_OPT",
              "number": "5",
              "description": ""
            },
            {
              "name": "GOSSIP_QUERIES_REQ",
              "number": "6",
              "description": ""
            },
            {
              "name": "GOSSIP_QUERIES_OPT",
              "number": "7",
              "description": ""
            },
            {
              "name": "TLV_ONION_REQ",
              "number": "8",
              "description": ""
            },
            {
              "name": "TLV_ONION_OPT",
              "number": "9",
              "description": ""
            },
            {
              "name": "EXT_GOSSIP_QUERIES_REQ",
              "number": "10",
              "description": ""
            },
            {
              "name": "EXT_GOSSIP_QUERIES_OPT",
              "number": "11",
              "description": ""
            },
            {
              "name": "STATIC_REMOTE_KEY_REQ",
              "number": "12",
              "description": ""
            },
            {
              "name": "STATIC_REMOTE_KEY_OPT",
              "number": "13",
              "description": ""
            },
            {
              "name": "PAYMENT_ADDR_REQ",
              "number": "14",
              "description": ""
            },
            {
              "name": "PAYMENT_ADDR_OPT",
              "number": "15",
              "description": ""
            },
            {
              "name": "MPP_REQ",
              "number": "16",
              "description": ""
            },
            {
              "name": "MPP_OPT",
              "number": "17",
              "description": ""
            },
            {
              "name": "WUMBO_CHANNELS_REQ",
              "number": "18",
              "description": ""
            },
            {
              "name": "WUMBO_CHANNELS_OPT",
              "number": "19",
              "description": ""
            },
            {
              "name": "ANCHORS_REQ",
              "number": "20",
              "description": ""
            },
            {
              "name": "ANCHORS_OPT",
              "number": "21",
              "description": ""
            },
            {
              "name": "ANCHORS_ZERO_FEE_HTLC_REQ",
              "number": "22",
              "description": ""
            },
            {
              "name": "ANCHORS_ZERO_FEE_HTLC_OPT",
              "number": "23",
              "description": ""
            },
            {
              "name": "AMP_REQ",
              "number": "30",
              "description": ""
            },
            {
              "name": "AMP_OPT",
              "number": "31",
              "description": ""
            }
          ]
        },
        {
          "name": "HTLCStatus",
          "longName": "HTLCAttempt.HTLCStatus",
          "fullName": "lnrpc.HTLCAttempt.HTLCStatus",
          "description": "",
          "values": [
            {
              "name": "IN_FLIGHT",
              "number": "0",
              "description": ""
            },
            {
              "name": "SUCCEEDED",
              "number": "1",
              "description": ""
            },
            {
              "name": "FAILED",
              "number": "2",
              "description": ""
            }
          ]
        },
        {
          "name": "Initiator",
          "longName": "Initiator",
          "fullName": "lnrpc.Initiator",
          "description": "",
          "values": [
            {
              "name": "INITIATOR_UNKNOWN",
              "number": "0",
              "description": ""
            },
            {
              "name": "INITIATOR_LOCAL",
              "number": "1",
              "description": ""
            },
            {
              "name": "INITIATOR_REMOTE",
              "number": "2",
              "description": ""
            },
            {
              "name": "INITIATOR_BOTH",
              "number": "3",
              "description": ""
            }
          ]
        },
        {
          "name": "InvoiceState",
          "longName": "Invoice.InvoiceState",
          "fullName": "lnrpc.Invoice.InvoiceState",
          "description": "",
          "values": [
            {
              "name": "OPEN",
              "number": "0",
              "description": ""
            },
            {
              "name": "SETTLED",
              "number": "1",
              "description": ""
            },
            {
              "name": "CANCELED",
              "number": "2",
              "description": ""
            },
            {
              "name": "ACCEPTED",
              "number": "3",
              "description": ""
            }
          ]
        },
        {
          "name": "InvoiceHTLCState",
          "longName": "InvoiceHTLCState",
          "fullName": "lnrpc.InvoiceHTLCState",
          "description": "",
          "values": [
            {
              "name": "ACCEPTED",
              "number": "0",
              "description": ""
            },
            {
              "name": "SETTLED",
              "number": "1",
              "description": ""
            },
            {
              "name": "CANCELED",
              "number": "2",
              "description": ""
            }
          ]
        },
        {
          "name": "NodeMetricType",
          "longName": "NodeMetricType",
          "fullName": "lnrpc.NodeMetricType",
          "description": "",
          "values": [
            {
              "name": "UNKNOWN",
              "number": "0",
              "description": ""
            },
            {
              "name": "BETWEENNESS_CENTRALITY",
              "number": "1",
              "description": ""
            }
          ]
        },
        {
          "name": "OutputScriptType",
          "longName": "OutputScriptType",
          "fullName": "lnrpc.OutputScriptType",
          "description": "",
          "values": [
            {
              "name": "SCRIPT_TYPE_PUBKEY_HASH",
              "number": "0",
              "description": ""
            },
            {
              "name": "SCRIPT_TYPE_SCRIPT_HASH",
              "number": "1",
              "description": ""
            },
            {
              "name": "SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH",
              "number": "2",
              "description": ""
            },
            {
              "name": "SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH",
              "number": "3",
              "description": ""
            },
            {
              "name": "SCRIPT_TYPE_PUBKEY",
              "number": "4",
              "description": ""
            },
            {
              "name": "SCRIPT_TYPE_MULTISIG",
              "number": "5",
              "description": ""
            },
            {
              "name": "SCRIPT_TYPE_NULLDATA",
              "number": "6",
              "description": ""
            },
            {
              "name": "SCRIPT_TYPE_NON_STANDARD",
              "number": "7",
              "description": ""
            },
            {
              "name": "SCRIPT_TYPE_WITNESS_UNKNOWN",
              "number": "8",
              "description": ""
            }
          ]
        },
        {
          "name": "PaymentStatus",
          "longName": "Payment.PaymentStatus",
          "fullName": "lnrpc.Payment.PaymentStatus",
          "description": "",
          "values": [
            {
              "name": "UNKNOWN",
              "number": "0",
              "description": ""
            },
            {
              "name": "IN_FLIGHT",
              "number": "1",
              "description": ""
            },
            {
              "name": "SUCCEEDED",
              "number": "2",
              "description": ""
            },
            {
              "name": "FAILED",
              "number": "3",
              "description": ""
            }
          ]
        },
        {
          "name": "PaymentFailureReason",
          "longName": "PaymentFailureReason",
          "fullName": "lnrpc.PaymentFailureReason",
          "description": "",
          "values": [
            {
              "name": "FAILURE_REASON_NONE",
              "number": "0",
              "description": "Payment isn't failed (yet)."
            },
            {
              "name": "FAILURE_REASON_TIMEOUT",
              "number": "1",
              "description": "There are more routes to try, but the payment timeout was exceeded."
            },
            {
              "name": "FAILURE_REASON_NO_ROUTE",
              "number": "2",
              "description": "All possible routes were tried and failed permanently. Or were no\nroutes to the destination at all."
            },
            {
              "name": "FAILURE_REASON_ERROR",
              "number": "3",
              "description": "A non-recoverable error has occured."
            },
            {
              "name": "FAILURE_REASON_INCORRECT_PAYMENT_DETAILS",
              "number": "4",
              "description": "Payment details incorrect (unknown hash, invalid amt or\ninvalid final cltv delta)"
            },
            {
              "name": "FAILURE_REASON_INSUFFICIENT_BALANCE",
              "number": "5",
              "description": "Insufficient local balance."
            }
          ]
        },
        {
          "name": "SyncType",
          "longName": "Peer.SyncType",
          "fullName": "lnrpc.Peer.SyncType",
          "description": "",
          "values": [
            {
              "name": "UNKNOWN_SYNC",
              "number": "0",
              "description": "Denotes that we cannot determine the peer's current sync type."
            },
            {
              "name": "ACTIVE_SYNC",
              "number": "1",
              "description": "Denotes that we are actively receiving new graph updates from the peer."
            },
            {
              "name": "PASSIVE_SYNC",
              "number": "2",
              "description": "Denotes that we are not receiving new graph updates from the peer."
            },
            {
              "name": "PINNED_SYNC",
              "number": "3",
              "description": "Denotes that this peer is pinned into an active sync."
            }
          ]
        },
        {
          "name": "EventType",
          "longName": "PeerEvent.EventType",
          "fullName": "lnrpc.PeerEvent.EventType",
          "description": "",
          "values": [
            {
              "name": "PEER_ONLINE",
              "number": "0",
              "description": ""
            },
            {
              "name": "PEER_OFFLINE",
              "number": "1",
              "description": ""
            }
          ]
        },
        {
          "name": "AnchorState",
          "longName": "PendingChannelsResponse.ForceClosedChannel.AnchorState",
          "fullName": "lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState",
          "description": "",
          "values": [
            {
              "name": "LIMBO",
              "number": "0",
              "description": ""
            },
            {
              "name": "RECOVERED",
              "number": "1",
              "description": ""
            },
            {
              "name": "LOST",
              "number": "2",
              "description": ""
            }
          ]
        },
        {
          "name": "ResolutionOutcome",
          "longName": "ResolutionOutcome",
          "fullName": "lnrpc.ResolutionOutcome",
          "description": "",
          "values": [
            {
              "name": "OUTCOME_UNKNOWN",
              "number": "0",
              "description": "Outcome unknown."
            },
            {
              "name": "CLAIMED",
              "number": "1",
              "description": "An output was claimed on chain."
            },
            {
              "name": "UNCLAIMED",
              "number": "2",
              "description": "An output was left unclaimed on chain."
            },
            {
              "name": "ABANDONED",
              "number": "3",
              "description": "ResolverOutcomeAbandoned indicates that an output that we did not\nclaim on chain, for example an anchor that we did not sweep and a\nthird party claimed on chain, or a htlc that we could not decode\nso left unclaimed."
            },
            {
              "name": "FIRST_STAGE",
              "number": "4",
              "description": "If we force closed our channel, our htlcs need to be claimed in two\nstages. This outcome represents the broadcast of a timeout or success\ntransaction for this two stage htlc claim."
            },
            {
              "name": "TIMEOUT",
              "number": "5",
              "description": "A htlc was timed out on chain."
            }
          ]
        },
        {
          "name": "ResolutionType",
          "longName": "ResolutionType",
          "fullName": "lnrpc.ResolutionType",
          "description": "",
          "values": [
            {
              "name": "TYPE_UNKNOWN",
              "number": "0",
              "description": ""
            },
            {
              "name": "ANCHOR",
              "number": "1",
              "description": "We resolved an anchor output."
            },
            {
              "name": "INCOMING_HTLC",
              "number": "2",
              "description": "We are resolving an incoming htlc on chain. This if this htlc is\nclaimed, we swept the incoming htlc with the preimage. If it is timed\nout, our peer swept the timeout path."
            },
            {
              "name": "OUTGOING_HTLC",
              "number": "3",
              "description": "We are resolving an outgoing htlc on chain. If this htlc is claimed,\nthe remote party swept the htlc with the preimage. If it is timed out,\nwe swept it with the timeout path."
            },
            {
              "name": "COMMIT",
              "number": "4",
              "description": "We force closed and need to sweep our time locked commitment output."
            }
          ]
        },
        {
          "name": "UpdateFailure",
          "longName": "UpdateFailure",
          "fullName": "lnrpc.UpdateFailure",
          "description": "",
          "values": [
            {
              "name": "UPDATE_FAILURE_UNKNOWN",
              "number": "0",
              "description": ""
            },
            {
              "name": "UPDATE_FAILURE_PENDING",
              "number": "1",
              "description": ""
            },
            {
              "name": "UPDATE_FAILURE_NOT_FOUND",
              "number": "2",
              "description": ""
            },
            {
              "name": "UPDATE_FAILURE_INTERNAL_ERR",
              "number": "3",
              "description": ""
            },
            {
              "name": "UPDATE_FAILURE_INVALID_PARAMETER",
              "number": "4",
              "description": ""
            }
          ]
        }
      ],
      "extensions": [],
      "messages": [
        {
          "name": "AMP",
          "longName": "AMP",
          "fullName": "lnrpc.AMP",
          "description": "Details specific to AMP HTLCs.",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "root_share",
              "description": "An n-of-n secret share of the root seed from which child payment hashes\nand preimages are derived.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "set_id",
              "description": "An identifier for the HTLC set that this HTLC belongs to.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "child_index",
              "description": "A nonce used to randomize the child preimage and child hash from a given\nroot_share.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "hash",
              "description": "The payment hash of the AMP HTLC.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "preimage",
              "description": "The preimage used to settle this AMP htlc. This field will only be\npopulated if the invoice is in InvoiceState_ACCEPTED or\nInvoiceState_SETTLED.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AMPInvoiceState",
          "longName": "AMPInvoiceState",
          "fullName": "lnrpc.AMPInvoiceState",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "state",
              "description": "The state the HTLCs associated with this setID are in.",
              "label": "",
              "type": "InvoiceHTLCState",
              "longType": "InvoiceHTLCState",
              "fullType": "lnrpc.InvoiceHTLCState",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "settle_index",
              "description": "The settle index of this HTLC set, if the invoice state is settled.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "settle_time",
              "description": "The time this HTLC set was settled expressed in unix epoch.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_paid_msat",
              "description": "The total amount paid for the sub-invoice expressed in milli satoshis.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AMPRecord",
          "longName": "AMPRecord",
          "fullName": "lnrpc.AMPRecord",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "root_share",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "set_id",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "child_index",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AbandonChannelRequest",
          "longName": "AbandonChannelRequest",
          "fullName": "lnrpc.AbandonChannelRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channel_point",
              "description": "",
              "label": "",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_funding_shim_only",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "i_know_what_i_am_doing",
              "description": "Override the requirement for being in dev mode by setting this to true and\nconfirming the user knows what they are doing and this is a potential foot\ngun to lose funds if used on active channels.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AbandonChannelResponse",
          "longName": "AbandonChannelResponse",
          "fullName": "lnrpc.AbandonChannelResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "AddInvoiceResponse",
          "longName": "AddInvoiceResponse",
          "fullName": "lnrpc.AddInvoiceResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "r_hash",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_request",
              "description": "A bare-bones invoice for a payment within the Lightning Network. With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "add_index",
              "description": "The \"add\" index of this invoice. Each newly created invoice will increment\nthis index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all added\ninvoices with an add_index greater than this one.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_addr",
              "description": "The payment address of the generated invoice. This value should be used\nin all payments for this invoice as we require it for end to end\nsecurity.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Amount",
          "longName": "Amount",
          "fullName": "lnrpc.Amount",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "sat",
              "description": "Value denominated in satoshis.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "msat",
              "description": "Value denominated in milli-satoshis.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "BakeMacaroonRequest",
          "longName": "BakeMacaroonRequest",
          "fullName": "lnrpc.BakeMacaroonRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "permissions",
              "description": "The list of permissions the new macaroon should grant.",
              "label": "repeated",
              "type": "MacaroonPermission",
              "longType": "MacaroonPermission",
              "fullType": "lnrpc.MacaroonPermission",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "root_key_id",
              "description": "The root key ID used to create the macaroon, must be a positive integer.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "allow_external_permissions",
              "description": "Informs the RPC on whether to allow external permissions that LND is not\naware of.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "BakeMacaroonResponse",
          "longName": "BakeMacaroonResponse",
          "fullName": "lnrpc.BakeMacaroonResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "macaroon",
              "description": "The hex encoded macaroon, serialized in binary format.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "BatchOpenChannel",
          "longName": "BatchOpenChannel",
          "fullName": "lnrpc.BatchOpenChannel",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "node_pubkey",
              "description": "The pubkey of the node to open a channel with. When using REST, this\nfield must be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "local_funding_amount",
              "description": "The number of satoshis the wallet should commit to the channel.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "push_sat",
              "description": "The number of satoshis to push to the remote side as part of the initial\ncommitment state.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "private",
              "description": "Whether this channel should be private, not announced to the greater\nnetwork.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_htlc_msat",
              "description": "The minimum value in millisatoshi we will require for incoming HTLCs on\nthe channel.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_csv_delay",
              "description": "The delay we require on the remote's commitment transaction. If this is\nnot set, it will be scaled automatically with the channel size.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "close_address",
              "description": "Close address is an optional address which specifies the address to which\nfunds should be paid out to upon cooperative close. This field may only be\nset if the peer supports the option upfront feature bit (call listpeers\nto check). The remote peer will only accept cooperative closes to this\naddress if it is set.\n\nNote: If this value is set on channel creation, you will *not* be able to\ncooperatively close out to a different address.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_chan_id",
              "description": "An optional, unique identifier of 32 random bytes that will be used as the\npending channel ID to identify the channel while it is in the pre-pending\nstate.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "commitment_type",
              "description": "The explicit commitment type to use. Note this field will only be used if\nthe remote peer supports explicit channel negotiation.",
              "label": "",
              "type": "CommitmentType",
              "longType": "CommitmentType",
              "fullType": "lnrpc.CommitmentType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "BatchOpenChannelRequest",
          "longName": "BatchOpenChannelRequest",
          "fullName": "lnrpc.BatchOpenChannelRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channels",
              "description": "The list of channels to open.",
              "label": "repeated",
              "type": "BatchOpenChannel",
              "longType": "BatchOpenChannel",
              "fullType": "lnrpc.BatchOpenChannel",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "target_conf",
              "description": "The target number of blocks that the funding transaction should be\nconfirmed by.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_per_vbyte",
              "description": "A manual fee rate set in sat/vByte that should be used when crafting the\nfunding transaction.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_confs",
              "description": "The minimum number of confirmations each one of your outputs used for\nthe funding transaction must satisfy.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "spend_unconfirmed",
              "description": "Whether unconfirmed outputs should be used as inputs for the funding\ntransaction.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "label",
              "description": "An optional label for the batch transaction, limited to 500 characters.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "BatchOpenChannelResponse",
          "longName": "BatchOpenChannelResponse",
          "fullName": "lnrpc.BatchOpenChannelResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pending_channels",
              "description": "",
              "label": "repeated",
              "type": "PendingUpdate",
              "longType": "PendingUpdate",
              "fullType": "lnrpc.PendingUpdate",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Chain",
          "longName": "Chain",
          "fullName": "lnrpc.Chain",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chain",
              "description": "The blockchain the node is on (eg bitcoin, litecoin)",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "network",
              "description": "The network the node is on (eg regtest, testnet, mainnet)",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChanBackupExportRequest",
          "longName": "ChanBackupExportRequest",
          "fullName": "lnrpc.ChanBackupExportRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "ChanBackupSnapshot",
          "longName": "ChanBackupSnapshot",
          "fullName": "lnrpc.ChanBackupSnapshot",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "single_chan_backups",
              "description": "The set of new channels that have been added since the last channel backup\nsnapshot was requested.",
              "label": "",
              "type": "ChannelBackups",
              "longType": "ChannelBackups",
              "fullType": "lnrpc.ChannelBackups",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "multi_chan_backup",
              "description": "A multi-channel backup that covers all open channels currently known to\nlnd.",
              "label": "",
              "type": "MultiChanBackup",
              "longType": "MultiChanBackup",
              "fullType": "lnrpc.MultiChanBackup",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChanInfoRequest",
          "longName": "ChanInfoRequest",
          "fullName": "lnrpc.ChanInfoRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chan_id",
              "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChanPointShim",
          "longName": "ChanPointShim",
          "fullName": "lnrpc.ChanPointShim",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "amt",
              "description": "The size of the pre-crafted output to be used as the channel point for this\nchannel funding.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_point",
              "description": "The target channel point to refrence in created commitment transactions.",
              "label": "",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "local_key",
              "description": "Our local key to use when creating the multi-sig output.",
              "label": "",
              "type": "KeyDescriptor",
              "longType": "KeyDescriptor",
              "fullType": "lnrpc.KeyDescriptor",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_key",
              "description": "The key of the remote party to use when creating the multi-sig output.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_chan_id",
              "description": "If non-zero, then this will be used as the pending channel ID on the wire\nprotocol to initate the funding request. This is an optional field, and\nshould only be set if the responder is already expecting a specific pending\nchannel ID.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "thaw_height",
              "description": "This uint32 indicates if this channel is to be considered 'frozen'. A frozen\nchannel does not allow a cooperative channel close by the initiator. The\nthaw_height is the height that this restriction stops applying to the\nchannel. The height can be interpreted in two ways: as a relative height if\nthe value is less than 500,000, or as an absolute height otherwise.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Channel",
          "longName": "Channel",
          "fullName": "lnrpc.Channel",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "active",
              "description": "Whether this channel is active or not",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_pubkey",
              "description": "The identity pubkey of the remote node",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "channel_point",
              "description": "The outpoint (txid:index) of the funding transaction. With this value, Bob\nwill be able to generate a signature for Alice's version of the commitment\ntransaction.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_id",
              "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "capacity",
              "description": "The total amount of funds held in this channel",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "local_balance",
              "description": "This node's current balance in this channel",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_balance",
              "description": "The counterparty's current balance in this channel",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "commit_fee",
              "description": "The amount calculated to be paid in fees for the current set of commitment\ntransactions. The fee amount is persisted with the channel in order to\nallow the fee amount to be removed and recalculated with each channel state\nupdate, including updates that happen after a system restart.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "commit_weight",
              "description": "The weight of the commitment transaction",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_per_kw",
              "description": "The required number of satoshis per kilo-weight that the requester will pay\nat all times, for both the funding transaction and commitment transaction.\nThis value can later be updated once the channel is open.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "unsettled_balance",
              "description": "The unsettled balance in this channel",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "total_satoshis_sent",
              "description": "The total number of satoshis we've sent within this channel.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "total_satoshis_received",
              "description": "The total number of satoshis we've received within this channel.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_updates",
              "description": "The total number of updates conducted within this channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_htlcs",
              "description": "The list of active, uncleared HTLCs currently pending within the channel.",
              "label": "repeated",
              "type": "HTLC",
              "longType": "HTLC",
              "fullType": "lnrpc.HTLC",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "csv_delay",
              "description": "Deprecated. The CSV delay expressed in relative blocks. If the channel is\nforce closed, we will need to wait for this many blocks before we can regain\nour funds.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "private",
              "description": "Whether this channel is advertised to the network or not.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "initiator",
              "description": "True if we were the ones that created the channel.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_status_flags",
              "description": "A set of flags showing the current state of the channel.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "local_chan_reserve_sat",
              "description": "Deprecated. The minimum satoshis this node is required to reserve in its\nbalance.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "remote_chan_reserve_sat",
              "description": "Deprecated. The minimum satoshis the other node is required to reserve in\nits balance.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "static_remote_key",
              "description": "Deprecated. Use commitment_type.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "commitment_type",
              "description": "The commitment type used by this channel.",
              "label": "",
              "type": "CommitmentType",
              "longType": "CommitmentType",
              "fullType": "lnrpc.CommitmentType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "lifetime",
              "description": "The number of seconds that the channel has been monitored by the channel\nscoring system. Scores are currently not persisted, so this value may be\nless than the lifetime of the channel [EXPERIMENTAL].",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "uptime",
              "description": "The number of seconds that the remote peer has been observed as being online\nby the channel scoring system over the lifetime of the channel\n[EXPERIMENTAL].",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "close_address",
              "description": "Close address is the address that we will enforce payout to on cooperative\nclose if the channel was opened utilizing option upfront shutdown. This\nvalue can be set on channel open by setting close_address in an open channel\nrequest. If this value is not set, you can still choose a payout address by\ncooperatively closing with the delivery_address field set.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "push_amount_sat",
              "description": "The amount that the initiator of the channel optionally pushed to the remote\nparty on channel open. This amount will be zero if the channel initiator did\nnot push any funds to the remote peer. If the initiator field is true, we\npushed this amount to our peer, if it is false, the remote peer pushed this\namount to us.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "thaw_height",
              "description": "This uint32 indicates if this channel is to be considered 'frozen'. A\nfrozen channel doest not allow a cooperative channel close by the\ninitiator. The thaw_height is the height that this restriction stops\napplying to the channel. This field is optional, not setting it or using a\nvalue of zero will mean the channel has no additional restrictions. The\nheight can be interpreted in two ways: as a relative height if the value is\nless than 500,000, or as an absolute height otherwise.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "local_constraints",
              "description": "List constraints for the local node.",
              "label": "",
              "type": "ChannelConstraints",
              "longType": "ChannelConstraints",
              "fullType": "lnrpc.ChannelConstraints",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_constraints",
              "description": "List constraints for the remote node.",
              "label": "",
              "type": "ChannelConstraints",
              "longType": "ChannelConstraints",
              "fullType": "lnrpc.ChannelConstraints",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelAcceptRequest",
          "longName": "ChannelAcceptRequest",
          "fullName": "lnrpc.ChannelAcceptRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "node_pubkey",
              "description": "The pubkey of the node that wishes to open an inbound channel.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chain_hash",
              "description": "The hash of the genesis block that the proposed channel resides in.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_chan_id",
              "description": "The pending channel id.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "funding_amt",
              "description": "The funding amount in satoshis that initiator wishes to use in the\nchannel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "push_amt",
              "description": "The push amount of the proposed channel in millisatoshis.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dust_limit",
              "description": "The dust limit of the initiator's commitment tx.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_value_in_flight",
              "description": "The maximum amount of coins in millisatoshis that can be pending in this\nchannel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "channel_reserve",
              "description": "The minimum amount of satoshis the initiator requires us to have at all\ntimes.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_htlc",
              "description": "The smallest HTLC in millisatoshis that the initiator will accept.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_per_kw",
              "description": "The initial fee rate that the initiator suggests for both commitment\ntransactions.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "csv_delay",
              "description": "The number of blocks to use for the relative time lock in the pay-to-self\noutput of both commitment transactions.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_accepted_htlcs",
              "description": "The total number of incoming HTLC's that the initiator will accept.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "channel_flags",
              "description": "A bit-field which the initiator uses to specify proposed channel\nbehavior.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "commitment_type",
              "description": "The commitment type the initiator wishes to use for the proposed channel.",
              "label": "",
              "type": "CommitmentType",
              "longType": "CommitmentType",
              "fullType": "lnrpc.CommitmentType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelAcceptResponse",
          "longName": "ChannelAcceptResponse",
          "fullName": "lnrpc.ChannelAcceptResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "accept",
              "description": "Whether or not the client accepts the channel.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_chan_id",
              "description": "The pending channel id to which this response applies.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "error",
              "description": "An optional error to send the initiating party to indicate why the channel\nwas rejected. This field *should not* contain sensitive information, it will\nbe sent to the initiating party. This field should only be set if accept is\nfalse, the channel will be rejected if an error is set with accept=true\nbecause the meaning of this response is ambiguous. Limited to 500\ncharacters.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "upfront_shutdown",
              "description": "The upfront shutdown address to use if the initiating peer supports option\nupfront shutdown script (see ListPeers for the features supported). Note\nthat the channel open will fail if this value is set for a peer that does\nnot support this feature bit.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "csv_delay",
              "description": "The csv delay (in blocks) that we require for the remote party.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "reserve_sat",
              "description": "The reserve amount in satoshis that we require the remote peer to adhere to.\nWe require that the remote peer always have some reserve amount allocated to\nthem so that there is always a disincentive to broadcast old state (if they\nhold 0 sats on their side of the channel, there is nothing to lose).",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "in_flight_max_msat",
              "description": "The maximum amount of funds in millisatoshis that we allow the remote peer\nto have in outstanding htlcs.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_htlc_count",
              "description": "The maximum number of htlcs that the remote peer can offer us.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_htlc_in",
              "description": "The minimum value in millisatoshis for incoming htlcs on the channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_accept_depth",
              "description": "The number of confirmations we require before we consider the channel open.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "zero_conf",
              "description": "Whether the responder wants this to be a zero-conf channel. This will fail\nif either side does not have the scid-alias feature bit set. The minimum\ndepth field must be zero if this is true.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelBackup",
          "longName": "ChannelBackup",
          "fullName": "lnrpc.ChannelBackup",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chan_point",
              "description": "Identifies the channel that this backup belongs to.",
              "label": "",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_backup",
              "description": "Is an encrypted single-chan backup. this can be passed to\nRestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in\norder to trigger the recovery protocol. When using REST, this field must be\nencoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelBackupSubscription",
          "longName": "ChannelBackupSubscription",
          "fullName": "lnrpc.ChannelBackupSubscription",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "ChannelBackups",
          "longName": "ChannelBackups",
          "fullName": "lnrpc.ChannelBackups",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chan_backups",
              "description": "A set of single-chan static channel backups.",
              "label": "repeated",
              "type": "ChannelBackup",
              "longType": "ChannelBackup",
              "fullType": "lnrpc.ChannelBackup",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelBalanceRequest",
          "longName": "ChannelBalanceRequest",
          "fullName": "lnrpc.ChannelBalanceRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "ChannelBalanceResponse",
          "longName": "ChannelBalanceResponse",
          "fullName": "lnrpc.ChannelBalanceResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "balance",
              "description": "Deprecated. Sum of channels balances denominated in satoshis",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "pending_open_balance",
              "description": "Deprecated. Sum of channels pending balances denominated in satoshis",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "local_balance",
              "description": "Sum of channels local balances.",
              "label": "",
              "type": "Amount",
              "longType": "Amount",
              "fullType": "lnrpc.Amount",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_balance",
              "description": "Sum of channels remote balances.",
              "label": "",
              "type": "Amount",
              "longType": "Amount",
              "fullType": "lnrpc.Amount",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "unsettled_local_balance",
              "description": "Sum of channels local unsettled balances.",
              "label": "",
              "type": "Amount",
              "longType": "Amount",
              "fullType": "lnrpc.Amount",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "unsettled_remote_balance",
              "description": "Sum of channels remote unsettled balances.",
              "label": "",
              "type": "Amount",
              "longType": "Amount",
              "fullType": "lnrpc.Amount",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_open_local_balance",
              "description": "Sum of channels pending local balances.",
              "label": "",
              "type": "Amount",
              "longType": "Amount",
              "fullType": "lnrpc.Amount",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_open_remote_balance",
              "description": "Sum of channels pending remote balances.",
              "label": "",
              "type": "Amount",
              "longType": "Amount",
              "fullType": "lnrpc.Amount",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelCloseSummary",
          "longName": "ChannelCloseSummary",
          "fullName": "lnrpc.ChannelCloseSummary",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channel_point",
              "description": "The outpoint (txid:index) of the funding transaction.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_id",
              "description": "The unique channel ID for the channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chain_hash",
              "description": "The hash of the genesis block that this channel resides within.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "closing_tx_hash",
              "description": "The txid of the transaction which ultimately closed this channel.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_pubkey",
              "description": "Public key of the remote peer that we formerly had a channel with.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "capacity",
              "description": "Total capacity of the channel.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "close_height",
              "description": "Height at which the funding transaction was spent.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "settled_balance",
              "description": "Settled balance at the time of channel closure",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "time_locked_balance",
              "description": "The sum of all the time-locked outputs at the time of channel closure",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "close_type",
              "description": "Details on how the channel was closed.",
              "label": "",
              "type": "ClosureType",
              "longType": "ChannelCloseSummary.ClosureType",
              "fullType": "lnrpc.ChannelCloseSummary.ClosureType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "open_initiator",
              "description": "Open initiator is the party that initiated opening the channel. Note that\nthis value may be unknown if the channel was closed before we migrated to\nstore open channel information after close.",
              "label": "",
              "type": "Initiator",
              "longType": "Initiator",
              "fullType": "lnrpc.Initiator",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "close_initiator",
              "description": "Close initiator indicates which party initiated the close. This value will\nbe unknown for channels that were cooperatively closed before we started\ntracking cooperative close initiators. Note that this indicates which party\ninitiated a close, and it is possible for both to initiate cooperative or\nforce closes, although only one party's close will be confirmed on chain.",
              "label": "",
              "type": "Initiator",
              "longType": "Initiator",
              "fullType": "lnrpc.Initiator",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "resolutions",
              "description": "",
              "label": "repeated",
              "type": "Resolution",
              "longType": "Resolution",
              "fullType": "lnrpc.Resolution",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelCloseUpdate",
          "longName": "ChannelCloseUpdate",
          "fullName": "lnrpc.ChannelCloseUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "closing_txid",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "success",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelConstraints",
          "longName": "ChannelConstraints",
          "fullName": "lnrpc.ChannelConstraints",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "csv_delay",
              "description": "The CSV delay expressed in relative blocks. If the channel is force closed,\nwe will need to wait for this many blocks before we can regain our funds.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_reserve_sat",
              "description": "The minimum satoshis this node is required to reserve in its balance.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dust_limit_sat",
              "description": "The dust limit (in satoshis) of the initiator's commitment tx.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_pending_amt_msat",
              "description": "The maximum amount of coins in millisatoshis that can be pending in this\nchannel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_htlc_msat",
              "description": "The smallest HTLC in millisatoshis that the initiator will accept.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_accepted_htlcs",
              "description": "The total number of incoming HTLC's that the initiator will accept.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelEdge",
          "longName": "ChannelEdge",
          "fullName": "lnrpc.ChannelEdge",
          "description": "A fully authenticated channel along with all its unique attributes.\nOnce an authenticated channel announcement has been processed on the network,\nthen an instance of ChannelEdgeInfo encapsulating the channels attributes is\nstored. The other portions relevant to routing policy of a channel are stored\nwithin a ChannelEdgePolicy for each direction of the channel.",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channel_id",
              "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_point",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "last_update",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "node1_pub",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "node2_pub",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "capacity",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "node1_policy",
              "description": "",
              "label": "",
              "type": "RoutingPolicy",
              "longType": "RoutingPolicy",
              "fullType": "lnrpc.RoutingPolicy",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "node2_policy",
              "description": "",
              "label": "",
              "type": "RoutingPolicy",
              "longType": "RoutingPolicy",
              "fullType": "lnrpc.RoutingPolicy",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelEdgeUpdate",
          "longName": "ChannelEdgeUpdate",
          "fullName": "lnrpc.ChannelEdgeUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chan_id",
              "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_point",
              "description": "",
              "label": "",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "capacity",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "routing_policy",
              "description": "",
              "label": "",
              "type": "RoutingPolicy",
              "longType": "RoutingPolicy",
              "fullType": "lnrpc.RoutingPolicy",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "advertising_node",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "connecting_node",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelEventSubscription",
          "longName": "ChannelEventSubscription",
          "fullName": "lnrpc.ChannelEventSubscription",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "ChannelEventUpdate",
          "longName": "ChannelEventUpdate",
          "fullName": "lnrpc.ChannelEventUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "open_channel",
              "description": "",
              "label": "",
              "type": "Channel",
              "longType": "Channel",
              "fullType": "lnrpc.Channel",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "channel",
              "defaultValue": ""
            },
            {
              "name": "closed_channel",
              "description": "",
              "label": "",
              "type": "ChannelCloseSummary",
              "longType": "ChannelCloseSummary",
              "fullType": "lnrpc.ChannelCloseSummary",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "channel",
              "defaultValue": ""
            },
            {
              "name": "active_channel",
              "description": "",
              "label": "",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "channel",
              "defaultValue": ""
            },
            {
              "name": "inactive_channel",
              "description": "",
              "label": "",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "channel",
              "defaultValue": ""
            },
            {
              "name": "pending_open_channel",
              "description": "",
              "label": "",
              "type": "PendingUpdate",
              "longType": "PendingUpdate",
              "fullType": "lnrpc.PendingUpdate",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "channel",
              "defaultValue": ""
            },
            {
              "name": "fully_resolved_channel",
              "description": "",
              "label": "",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "channel",
              "defaultValue": ""
            },
            {
              "name": "type",
              "description": "",
              "label": "",
              "type": "UpdateType",
              "longType": "ChannelEventUpdate.UpdateType",
              "fullType": "lnrpc.ChannelEventUpdate.UpdateType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelFeeReport",
          "longName": "ChannelFeeReport",
          "fullName": "lnrpc.ChannelFeeReport",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chan_id",
              "description": "The short channel id that this fee report belongs to.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "channel_point",
              "description": "The channel that this fee report belongs to.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "base_fee_msat",
              "description": "The base fee charged regardless of the number of milli-satoshis sent.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_per_mil",
              "description": "The amount charged per milli-satoshis transferred expressed in\nmillionths of a satoshi.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_rate",
              "description": "The effective fee rate in milli-satoshis. Computed by dividing the\nfee_per_mil value by 1 million.",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelGraph",
          "longName": "ChannelGraph",
          "fullName": "lnrpc.ChannelGraph",
          "description": "Returns a new instance of the directed channel graph.",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "nodes",
              "description": "The list of `LightningNode`s in this channel graph",
              "label": "repeated",
              "type": "LightningNode",
              "longType": "LightningNode",
              "fullType": "lnrpc.LightningNode",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "edges",
              "description": "The list of `ChannelEdge`s in this channel graph",
              "label": "repeated",
              "type": "ChannelEdge",
              "longType": "ChannelEdge",
              "fullType": "lnrpc.ChannelEdge",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelGraphRequest",
          "longName": "ChannelGraphRequest",
          "fullName": "lnrpc.ChannelGraphRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "include_unannounced",
              "description": "Whether unannounced channels are included in the response or not. If set,\nunannounced channels are included. Unannounced channels are both private\nchannels, and public channels that are not yet announced to the network.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelOpenUpdate",
          "longName": "ChannelOpenUpdate",
          "fullName": "lnrpc.ChannelOpenUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channel_point",
              "description": "",
              "label": "",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelPoint",
          "longName": "ChannelPoint",
          "fullName": "lnrpc.ChannelPoint",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "funding_txid_bytes",
              "description": "Txid of the funding transaction. When using REST, this field must be\nencoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "funding_txid",
              "defaultValue": ""
            },
            {
              "name": "funding_txid_str",
              "description": "Hex-encoded string representing the byte-reversed hash of the funding\ntransaction.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "funding_txid",
              "defaultValue": ""
            },
            {
              "name": "output_index",
              "description": "The index of the output of the funding transaction",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ChannelUpdate",
          "longName": "ChannelUpdate",
          "fullName": "lnrpc.ChannelUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "signature",
              "description": "The signature that validates the announced data and proves the ownership\nof node id.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chain_hash",
              "description": "The target chain that this channel was opened within. This value\nshould be the genesis hash of the target chain. Along with the short\nchannel ID, this uniquely identifies the channel globally in a\nblockchain.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_id",
              "description": "The unique description of the funding transaction.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "timestamp",
              "description": "A timestamp that allows ordering in the case of multiple announcements.\nWe should ignore the message if timestamp is not greater than the\nlast-received.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "message_flags",
              "description": "The bitfield that describes whether optional fields are present in this\nupdate. Currently, the least-significant bit must be set to 1 if the\noptional field MaxHtlc is present.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "channel_flags",
              "description": "The bitfield that describes additional meta-data concerning how the\nupdate is to be interpreted. Currently, the least-significant bit must be\nset to 0 if the creating node corresponds to the first node in the\npreviously sent channel announcement and 1 otherwise. If the second bit\nis set, then the channel is set to be disabled.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "time_lock_delta",
              "description": "The minimum number of blocks this node requires to be added to the expiry\nof HTLCs. This is a security parameter determined by the node operator.\nThis value represents the required gap between the time locks of the\nincoming and outgoing HTLC's set to this node.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "htlc_minimum_msat",
              "description": "The minimum HTLC value which will be accepted.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "base_fee",
              "description": "The base fee that must be used for incoming HTLC's to this particular\nchannel. This value will be tacked onto the required for a payment\nindependent of the size of the payment.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_rate",
              "description": "The fee rate that will be charged per millionth of a satoshi.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "htlc_maximum_msat",
              "description": "The maximum HTLC value which will be accepted.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "extra_opaque_data",
              "description": "The set of data that was appended to this message, some of which we may\nnot actually know how to iterate or parse. By holding onto this data, we\nensure that we're able to properly validate the set of signatures that\ncover these new fields, and ensure we're able to make upgrades to the\nnetwork in a forwards compatible manner.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "CheckMacPermRequest",
          "longName": "CheckMacPermRequest",
          "fullName": "lnrpc.CheckMacPermRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "macaroon",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "permissions",
              "description": "",
              "label": "repeated",
              "type": "MacaroonPermission",
              "longType": "MacaroonPermission",
              "fullType": "lnrpc.MacaroonPermission",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fullMethod",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "CheckMacPermResponse",
          "longName": "CheckMacPermResponse",
          "fullName": "lnrpc.CheckMacPermResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "valid",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "CloseChannelRequest",
          "longName": "CloseChannelRequest",
          "fullName": "lnrpc.CloseChannelRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channel_point",
              "description": "The outpoint (txid:index) of the funding transaction. With this value, Bob\nwill be able to generate a signature for Alice's version of the commitment\ntransaction.",
              "label": "",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "force",
              "description": "If true, then the channel will be closed forcibly. This means the\ncurrent commitment transaction will be signed and broadcast.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "target_conf",
              "description": "The target number of blocks that the closure transaction should be\nconfirmed by.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_per_byte",
              "description": "Deprecated, use sat_per_vbyte.\nA manual fee rate set in sat/vbyte that should be used when crafting the\nclosure transaction.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "delivery_address",
              "description": "An optional address to send funds to in the case of a cooperative close.\nIf the channel was opened with an upfront shutdown script and this field\nis set, the request to close will fail because the channel must pay out\nto the upfront shutdown addresss.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_per_vbyte",
              "description": "A manual fee rate set in sat/vbyte that should be used when crafting the\nclosure transaction.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "CloseStatusUpdate",
          "longName": "CloseStatusUpdate",
          "fullName": "lnrpc.CloseStatusUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "close_pending",
              "description": "",
              "label": "",
              "type": "PendingUpdate",
              "longType": "PendingUpdate",
              "fullType": "lnrpc.PendingUpdate",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "update",
              "defaultValue": ""
            },
            {
              "name": "chan_close",
              "description": "",
              "label": "",
              "type": "ChannelCloseUpdate",
              "longType": "ChannelCloseUpdate",
              "fullType": "lnrpc.ChannelCloseUpdate",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "update",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ClosedChannelUpdate",
          "longName": "ClosedChannelUpdate",
          "fullName": "lnrpc.ClosedChannelUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chan_id",
              "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "capacity",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "closed_height",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_point",
              "description": "",
              "label": "",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ClosedChannelsRequest",
          "longName": "ClosedChannelsRequest",
          "fullName": "lnrpc.ClosedChannelsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "cooperative",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "local_force",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_force",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "breach",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "funding_canceled",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "abandoned",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ClosedChannelsResponse",
          "longName": "ClosedChannelsResponse",
          "fullName": "lnrpc.ClosedChannelsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channels",
              "description": "",
              "label": "repeated",
              "type": "ChannelCloseSummary",
              "longType": "ChannelCloseSummary",
              "fullType": "lnrpc.ChannelCloseSummary",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ConfirmationUpdate",
          "longName": "ConfirmationUpdate",
          "fullName": "lnrpc.ConfirmationUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "block_sha",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "block_height",
              "description": "",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_confs_left",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ConnectPeerRequest",
          "longName": "ConnectPeerRequest",
          "fullName": "lnrpc.ConnectPeerRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "addr",
              "description": "Lightning address of the peer to connect to.",
              "label": "",
              "type": "LightningAddress",
              "longType": "LightningAddress",
              "fullType": "lnrpc.LightningAddress",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "perm",
              "description": "If set, the daemon will attempt to persistently connect to the target\npeer. Otherwise, the call will be synchronous.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "timeout",
              "description": "The connection timeout value (in seconds) for this request. It won't affect\nother requests.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ConnectPeerResponse",
          "longName": "ConnectPeerResponse",
          "fullName": "lnrpc.ConnectPeerResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "CustomMessage",
          "longName": "CustomMessage",
          "fullName": "lnrpc.CustomMessage",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "peer",
              "description": "Peer from which the message originates",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "type",
              "description": "Message type. This value will be in the custom range (\u003e= 32768).",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "data",
              "description": "Raw message data",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "DebugLevelRequest",
          "longName": "DebugLevelRequest",
          "fullName": "lnrpc.DebugLevelRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "show",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "level_spec",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "DebugLevelResponse",
          "longName": "DebugLevelResponse",
          "fullName": "lnrpc.DebugLevelResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "sub_systems",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "DeleteAllPaymentsRequest",
          "longName": "DeleteAllPaymentsRequest",
          "fullName": "lnrpc.DeleteAllPaymentsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "failed_payments_only",
              "description": "Only delete failed payments.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "failed_htlcs_only",
              "description": "Only delete failed HTLCs from payments, not the payment itself.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "DeleteAllPaymentsResponse",
          "longName": "DeleteAllPaymentsResponse",
          "fullName": "lnrpc.DeleteAllPaymentsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "DeleteMacaroonIDRequest",
          "longName": "DeleteMacaroonIDRequest",
          "fullName": "lnrpc.DeleteMacaroonIDRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "root_key_id",
              "description": "The root key ID to be removed.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "DeleteMacaroonIDResponse",
          "longName": "DeleteMacaroonIDResponse",
          "fullName": "lnrpc.DeleteMacaroonIDResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "deleted",
              "description": "A boolean indicates that the deletion is successful.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "DeletePaymentRequest",
          "longName": "DeletePaymentRequest",
          "fullName": "lnrpc.DeletePaymentRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "payment_hash",
              "description": "Payment hash to delete.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "failed_htlcs_only",
              "description": "Only delete failed HTLCs from the payment, not the payment itself.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "DeletePaymentResponse",
          "longName": "DeletePaymentResponse",
          "fullName": "lnrpc.DeletePaymentResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "DisconnectPeerRequest",
          "longName": "DisconnectPeerRequest",
          "fullName": "lnrpc.DisconnectPeerRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pub_key",
              "description": "The pubkey of the node to disconnect from",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "DisconnectPeerResponse",
          "longName": "DisconnectPeerResponse",
          "fullName": "lnrpc.DisconnectPeerResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "EdgeLocator",
          "longName": "EdgeLocator",
          "fullName": "lnrpc.EdgeLocator",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channel_id",
              "description": "The short channel id of this edge.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "direction_reverse",
              "description": "The direction of this edge. If direction_reverse is false, the direction\nof this edge is from the channel endpoint with the lexicographically smaller\npub key to the endpoint with the larger pub key. If direction_reverse is\nis true, the edge goes the other way.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "EstimateFeeRequest",
          "longName": "EstimateFeeRequest",
          "fullName": "lnrpc.EstimateFeeRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "AddrToAmount",
              "description": "The map from addresses to amounts for the transaction.",
              "label": "repeated",
              "type": "AddrToAmountEntry",
              "longType": "EstimateFeeRequest.AddrToAmountEntry",
              "fullType": "lnrpc.EstimateFeeRequest.AddrToAmountEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "target_conf",
              "description": "The target number of blocks that this transaction should be confirmed\nby.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_confs",
              "description": "The minimum number of confirmations each one of your outputs used for\nthe transaction must satisfy.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "spend_unconfirmed",
              "description": "Whether unconfirmed outputs should be used as inputs for the transaction.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AddrToAmountEntry",
          "longName": "EstimateFeeRequest.AddrToAmountEntry",
          "fullName": "lnrpc.EstimateFeeRequest.AddrToAmountEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "EstimateFeeResponse",
          "longName": "EstimateFeeResponse",
          "fullName": "lnrpc.EstimateFeeResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "fee_sat",
              "description": "The total fee in satoshis.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "feerate_sat_per_byte",
              "description": "Deprecated, use sat_per_vbyte.\nThe fee rate in satoshi/vbyte.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "sat_per_vbyte",
              "description": "The fee rate in satoshi/vbyte.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ExportChannelBackupRequest",
          "longName": "ExportChannelBackupRequest",
          "fullName": "lnrpc.ExportChannelBackupRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chan_point",
              "description": "The target channel point to obtain a back up for.",
              "label": "",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FailedUpdate",
          "longName": "FailedUpdate",
          "fullName": "lnrpc.FailedUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "outpoint",
              "description": "The outpoint in format txid:n",
              "label": "",
              "type": "OutPoint",
              "longType": "OutPoint",
              "fullType": "lnrpc.OutPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "reason",
              "description": "Reason for the policy update failure.",
              "label": "",
              "type": "UpdateFailure",
              "longType": "UpdateFailure",
              "fullType": "lnrpc.UpdateFailure",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "update_error",
              "description": "A string representation of the policy update error.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Failure",
          "longName": "Failure",
          "fullName": "lnrpc.Failure",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "code",
              "description": "Failure code as defined in the Lightning spec",
              "label": "",
              "type": "FailureCode",
              "longType": "Failure.FailureCode",
              "fullType": "lnrpc.Failure.FailureCode",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "channel_update",
              "description": "An optional channel update message.",
              "label": "",
              "type": "ChannelUpdate",
              "longType": "ChannelUpdate",
              "fullType": "lnrpc.ChannelUpdate",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "htlc_msat",
              "description": "A failure type-dependent htlc value.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "onion_sha_256",
              "description": "The sha256 sum of the onion payload.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "cltv_expiry",
              "description": "A failure type-dependent cltv expiry value.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "flags",
              "description": "A failure type-dependent flags value.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "failure_source_index",
              "description": "The position in the path of the intermediate or final node that generated\nthe failure message. Position zero is the sender node.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "height",
              "description": "A failure type-dependent block height.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Feature",
          "longName": "Feature",
          "fullName": "lnrpc.Feature",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "name",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "is_required",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "is_known",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FeeLimit",
          "longName": "FeeLimit",
          "fullName": "lnrpc.FeeLimit",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "fixed",
              "description": "The fee limit expressed as a fixed amount of satoshis.\n\nThe fields fixed and fixed_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "limit",
              "defaultValue": ""
            },
            {
              "name": "fixed_msat",
              "description": "The fee limit expressed as a fixed amount of millisatoshis.\n\nThe fields fixed and fixed_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "limit",
              "defaultValue": ""
            },
            {
              "name": "percent",
              "description": "The fee limit expressed as a percentage of the payment amount.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "limit",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FeeReportRequest",
          "longName": "FeeReportRequest",
          "fullName": "lnrpc.FeeReportRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "FeeReportResponse",
          "longName": "FeeReportResponse",
          "fullName": "lnrpc.FeeReportResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channel_fees",
              "description": "An array of channel fee reports which describes the current fee schedule\nfor each channel.",
              "label": "repeated",
              "type": "ChannelFeeReport",
              "longType": "ChannelFeeReport",
              "fullType": "lnrpc.ChannelFeeReport",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "day_fee_sum",
              "description": "The total amount of fee revenue (in satoshis) the switch has collected\nover the past 24 hrs.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "week_fee_sum",
              "description": "The total amount of fee revenue (in satoshis) the switch has collected\nover the past 1 week.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "month_fee_sum",
              "description": "The total amount of fee revenue (in satoshis) the switch has collected\nover the past 1 month.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FloatMetric",
          "longName": "FloatMetric",
          "fullName": "lnrpc.FloatMetric",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "value",
              "description": "Arbitrary float value.",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "normalized_value",
              "description": "The value normalized to [0,1] or [-1,1].",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ForwardingEvent",
          "longName": "ForwardingEvent",
          "fullName": "lnrpc.ForwardingEvent",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "timestamp",
              "description": "Timestamp is the time (unix epoch offset) that this circuit was\ncompleted. Deprecated by timestamp_ns.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "chan_id_in",
              "description": "The incoming channel ID that carried the HTLC that created the circuit.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_id_out",
              "description": "The outgoing channel ID that carried the preimage that completed the\ncircuit.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_in",
              "description": "The total amount (in satoshis) of the incoming HTLC that created half\nthe circuit.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_out",
              "description": "The total amount (in satoshis) of the outgoing HTLC that created the\nsecond half of the circuit.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee",
              "description": "The total fee (in satoshis) that this payment circuit carried.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_msat",
              "description": "The total fee (in milli-satoshis) that this payment circuit carried.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_in_msat",
              "description": "The total amount (in milli-satoshis) of the incoming HTLC that created\nhalf the circuit.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_out_msat",
              "description": "The total amount (in milli-satoshis) of the outgoing HTLC that created\nthe second half of the circuit.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "timestamp_ns",
              "description": "The number of nanoseconds elapsed since January 1, 1970 UTC when this\ncircuit was completed.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ForwardingHistoryRequest",
          "longName": "ForwardingHistoryRequest",
          "fullName": "lnrpc.ForwardingHistoryRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "start_time",
              "description": "Start time is the starting point of the forwarding history request. All\nrecords beyond this point will be included, respecting the end time, and\nthe index offset.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "end_time",
              "description": "End time is the end point of the forwarding history request. The\nresponse will carry at most 50k records between the start time and the\nend time. The index offset can be used to implement pagination.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "index_offset",
              "description": "Index offset is the offset in the time series to start at. As each\nresponse can only contain 50k records, callers can use this to skip\naround within a packed time series.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_max_events",
              "description": "The max number of events to return in the response to this query.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ForwardingHistoryResponse",
          "longName": "ForwardingHistoryResponse",
          "fullName": "lnrpc.ForwardingHistoryResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "forwarding_events",
              "description": "A list of forwarding events from the time slice of the time series\nspecified in the request.",
              "label": "repeated",
              "type": "ForwardingEvent",
              "longType": "ForwardingEvent",
              "fullType": "lnrpc.ForwardingEvent",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "last_offset_index",
              "description": "The index of the last time in the set of returned forwarding events. Can\nbe used to seek further, pagination style.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FundingPsbtFinalize",
          "longName": "FundingPsbtFinalize",
          "fullName": "lnrpc.FundingPsbtFinalize",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "signed_psbt",
              "description": "The funded PSBT that contains all witness data to send the exact channel\ncapacity amount to the PK script returned in the open channel message in a\nprevious step. Cannot be set at the same time as final_raw_tx.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_chan_id",
              "description": "The pending channel ID of the channel to get the PSBT for.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "final_raw_tx",
              "description": "As an alternative to the signed PSBT with all witness data, the final raw\nwire format transaction can also be specified directly. Cannot be set at the\nsame time as signed_psbt.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FundingPsbtVerify",
          "longName": "FundingPsbtVerify",
          "fullName": "lnrpc.FundingPsbtVerify",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "funded_psbt",
              "description": "The funded but not yet signed PSBT that sends the exact channel capacity\namount to the PK script returned in the open channel message in a previous\nstep.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_chan_id",
              "description": "The pending channel ID of the channel to get the PSBT for.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "skip_finalize",
              "description": "Can only be used if the no_publish flag was set to true in the OpenChannel\ncall meaning that the caller is solely responsible for publishing the final\nfunding transaction. If skip_finalize is set to true then lnd will not wait\nfor a FundingPsbtFinalize state step and instead assumes that a transaction\nwith the same TXID as the passed in PSBT will eventually confirm.\nIT IS ABSOLUTELY IMPERATIVE that the TXID of the transaction that is\neventually published does have the _same TXID_ as the verified PSBT. That\nmeans no inputs or outputs can change, only signatures can be added. If the\nTXID changes between this call and the publish step then the channel will\nnever be created and the funds will be in limbo.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FundingShim",
          "longName": "FundingShim",
          "fullName": "lnrpc.FundingShim",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "chan_point_shim",
              "description": "A channel shim where the channel point was fully constructed outside\nof lnd's wallet and the transaction might already be published.",
              "label": "",
              "type": "ChanPointShim",
              "longType": "ChanPointShim",
              "fullType": "lnrpc.ChanPointShim",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "shim",
              "defaultValue": ""
            },
            {
              "name": "psbt_shim",
              "description": "A channel shim that uses a PSBT to fund and sign the channel funding\ntransaction.",
              "label": "",
              "type": "PsbtShim",
              "longType": "PsbtShim",
              "fullType": "lnrpc.PsbtShim",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "shim",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FundingShimCancel",
          "longName": "FundingShimCancel",
          "fullName": "lnrpc.FundingShimCancel",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pending_chan_id",
              "description": "The pending channel ID of the channel to cancel the funding shim for.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FundingStateStepResp",
          "longName": "FundingStateStepResp",
          "fullName": "lnrpc.FundingStateStepResp",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "FundingTransitionMsg",
          "longName": "FundingTransitionMsg",
          "fullName": "lnrpc.FundingTransitionMsg",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "shim_register",
              "description": "The funding shim to register. This should be used before any\nchannel funding has began by the remote party, as it is intended as a\npreparatory step for the full channel funding.",
              "label": "",
              "type": "FundingShim",
              "longType": "FundingShim",
              "fullType": "lnrpc.FundingShim",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "trigger",
              "defaultValue": ""
            },
            {
              "name": "shim_cancel",
              "description": "Used to cancel an existing registered funding shim.",
              "label": "",
              "type": "FundingShimCancel",
              "longType": "FundingShimCancel",
              "fullType": "lnrpc.FundingShimCancel",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "trigger",
              "defaultValue": ""
            },
            {
              "name": "psbt_verify",
              "description": "Used to continue a funding flow that was initiated to be executed\nthrough a PSBT. This step verifies that the PSBT contains the correct\noutputs to fund the channel.",
              "label": "",
              "type": "FundingPsbtVerify",
              "longType": "FundingPsbtVerify",
              "fullType": "lnrpc.FundingPsbtVerify",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "trigger",
              "defaultValue": ""
            },
            {
              "name": "psbt_finalize",
              "description": "Used to continue a funding flow that was initiated to be executed\nthrough a PSBT. This step finalizes the funded and signed PSBT, finishes\nnegotiation with the peer and finally publishes the resulting funding\ntransaction.",
              "label": "",
              "type": "FundingPsbtFinalize",
              "longType": "FundingPsbtFinalize",
              "fullType": "lnrpc.FundingPsbtFinalize",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "trigger",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "GetInfoRequest",
          "longName": "GetInfoRequest",
          "fullName": "lnrpc.GetInfoRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "GetInfoResponse",
          "longName": "GetInfoResponse",
          "fullName": "lnrpc.GetInfoResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "version",
              "description": "The version of the LND software that the node is running.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "commit_hash",
              "description": "The SHA1 commit hash that the daemon is compiled with.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "identity_pubkey",
              "description": "The identity pubkey of the current node.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "alias",
              "description": "If applicable, the alias of the current node, e.g. \"bob\"",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "color",
              "description": "The color of the current node in hex code format",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_pending_channels",
              "description": "Number of pending channels",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_active_channels",
              "description": "Number of active channels",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_inactive_channels",
              "description": "Number of inactive channels",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_peers",
              "description": "Number of peers",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "block_height",
              "description": "The node's current view of the height of the best block",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "block_hash",
              "description": "The node's current view of the hash of the best block",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "best_header_timestamp",
              "description": "Timestamp of the block best known to the wallet",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "synced_to_chain",
              "description": "Whether the wallet's view is synced to the main chain",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "synced_to_graph",
              "description": "Whether we consider ourselves synced with the public channel graph.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "testnet",
              "description": "Whether the current node is connected to testnet. This field is\ndeprecated and the network field should be used instead",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "chains",
              "description": "A list of active chains the node is connected to",
              "label": "repeated",
              "type": "Chain",
              "longType": "Chain",
              "fullType": "lnrpc.Chain",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "uris",
              "description": "The URIs of the current node.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "features",
              "description": "Features that our node has advertised in our init message, node\nannouncements and invoices.",
              "label": "repeated",
              "type": "FeaturesEntry",
              "longType": "GetInfoResponse.FeaturesEntry",
              "fullType": "lnrpc.GetInfoResponse.FeaturesEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "require_htlc_interceptor",
              "description": "Indicates whether the HTLC interceptor API is in always-on mode.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FeaturesEntry",
          "longName": "GetInfoResponse.FeaturesEntry",
          "fullName": "lnrpc.GetInfoResponse.FeaturesEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "Feature",
              "longType": "Feature",
              "fullType": "lnrpc.Feature",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "GetRecoveryInfoRequest",
          "longName": "GetRecoveryInfoRequest",
          "fullName": "lnrpc.GetRecoveryInfoRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "GetRecoveryInfoResponse",
          "longName": "GetRecoveryInfoResponse",
          "fullName": "lnrpc.GetRecoveryInfoResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "recovery_mode",
              "description": "Whether the wallet is in recovery mode",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "recovery_finished",
              "description": "Whether the wallet recovery progress is finished",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "progress",
              "description": "The recovery progress, ranging from 0 to 1.",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "GetTransactionsRequest",
          "longName": "GetTransactionsRequest",
          "fullName": "lnrpc.GetTransactionsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "start_height",
              "description": "The height from which to list transactions, inclusive. If this value is\ngreater than end_height, transactions will be read in reverse.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "end_height",
              "description": "The height until which to list transactions, inclusive. To include\nunconfirmed transactions, this value should be set to -1, which will\nreturn transactions from start_height until the current chain tip and\nunconfirmed transactions. If no end_height is provided, the call will\ndefault to this option.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "account",
              "description": "An optional filter to only include transactions relevant to an account.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "GraphTopologySubscription",
          "longName": "GraphTopologySubscription",
          "fullName": "lnrpc.GraphTopologySubscription",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "GraphTopologyUpdate",
          "longName": "GraphTopologyUpdate",
          "fullName": "lnrpc.GraphTopologyUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "node_updates",
              "description": "",
              "label": "repeated",
              "type": "NodeUpdate",
              "longType": "NodeUpdate",
              "fullType": "lnrpc.NodeUpdate",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "channel_updates",
              "description": "",
              "label": "repeated",
              "type": "ChannelEdgeUpdate",
              "longType": "ChannelEdgeUpdate",
              "fullType": "lnrpc.ChannelEdgeUpdate",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "closed_chans",
              "description": "",
              "label": "repeated",
              "type": "ClosedChannelUpdate",
              "longType": "ClosedChannelUpdate",
              "fullType": "lnrpc.ClosedChannelUpdate",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "HTLC",
          "longName": "HTLC",
          "fullName": "lnrpc.HTLC",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "incoming",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amount",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "hash_lock",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "expiration_height",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "htlc_index",
              "description": "Index identifying the htlc on the channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "forwarding_channel",
              "description": "If this HTLC is involved in a forwarding operation, this field indicates\nthe forwarding channel. For an outgoing htlc, it is the incoming channel.\nFor an incoming htlc, it is the outgoing channel. When the htlc\noriginates from this node or this node is the final destination,\nforwarding_channel will be zero. The forwarding channel will also be zero\nfor htlcs that need to be forwarded but don't have a forwarding decision\npersisted yet.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "forwarding_htlc_index",
              "description": "Index identifying the htlc on the forwarding channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "HTLCAttempt",
          "longName": "HTLCAttempt",
          "fullName": "lnrpc.HTLCAttempt",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "attempt_id",
              "description": "The unique ID that is used for this attempt.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "status",
              "description": "The status of the HTLC.",
              "label": "",
              "type": "HTLCStatus",
              "longType": "HTLCAttempt.HTLCStatus",
              "fullType": "lnrpc.HTLCAttempt.HTLCStatus",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "route",
              "description": "The route taken by this HTLC.",
              "label": "",
              "type": "Route",
              "longType": "Route",
              "fullType": "lnrpc.Route",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "attempt_time_ns",
              "description": "The time in UNIX nanoseconds at which this HTLC was sent.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "resolve_time_ns",
              "description": "The time in UNIX nanoseconds at which this HTLC was settled or failed.\nThis value will not be set if the HTLC is still IN_FLIGHT.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "failure",
              "description": "Detailed htlc failure info.",
              "label": "",
              "type": "Failure",
              "longType": "Failure",
              "fullType": "lnrpc.Failure",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "preimage",
              "description": "The preimage that was used to settle the HTLC.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Hop",
          "longName": "Hop",
          "fullName": "lnrpc.Hop",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chan_id",
              "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_capacity",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "amt_to_forward",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "fee",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "expiry",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_to_forward_msat",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_msat",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pub_key",
              "description": "An optional public key of the hop. If the public key is given, the payment\ncan be executed without relying on a copy of the channel graph.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "tlv_payload",
              "description": "If set to true, then this hop will be encoded using the new variable length\nTLV format. Note that if any custom tlv_records below are specified, then\nthis field MUST be set to true for them to be encoded properly.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "mpp_record",
              "description": "An optional TLV record that signals the use of an MPP payment. If present,\nthe receiver will enforce that the same mpp_record is included in the final\nhop payload of all non-zero payments in the HTLC set. If empty, a regular\nsingle-shot payment is or was attempted.",
              "label": "",
              "type": "MPPRecord",
              "longType": "MPPRecord",
              "fullType": "lnrpc.MPPRecord",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amp_record",
              "description": "An optional TLV record that signals the use of an AMP payment. If present,\nthe receiver will treat all received payments including the same\n(payment_addr, set_id) pair  as being part of one logical payment. The\npayment will be settled by XORing the root_share's together and deriving the\nchild hashes and preimages according to BOLT XX. Must be used in conjunction\nwith mpp_record.",
              "label": "",
              "type": "AMPRecord",
              "longType": "AMPRecord",
              "fullType": "lnrpc.AMPRecord",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "custom_records",
              "description": "An optional set of key-value TLV records. This is useful within the context\nof the SendToRoute call as it allows callers to specify arbitrary K-V pairs\nto drop off at each hop within the onion.",
              "label": "repeated",
              "type": "CustomRecordsEntry",
              "longType": "Hop.CustomRecordsEntry",
              "fullType": "lnrpc.Hop.CustomRecordsEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "metadata",
              "description": "The payment metadata to send along with the payment to the payee.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "CustomRecordsEntry",
          "longName": "Hop.CustomRecordsEntry",
          "fullName": "lnrpc.Hop.CustomRecordsEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "HopHint",
          "longName": "HopHint",
          "fullName": "lnrpc.HopHint",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "node_id",
              "description": "The public key of the node at the start of the channel.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_id",
              "description": "The unique identifier of the channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_base_msat",
              "description": "The base fee of the channel denominated in millisatoshis.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_proportional_millionths",
              "description": "The fee rate of the channel for sending one satoshi across it denominated in\nmillionths of a satoshi.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "cltv_expiry_delta",
              "description": "The time-lock delta of the channel.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "InterceptFeedback",
          "longName": "InterceptFeedback",
          "fullName": "lnrpc.InterceptFeedback",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "error",
              "description": "The error to return to the user. If this is non-empty, the incoming gRPC\nstream/request is aborted and the error is returned to the gRPC client. If\nthis value is empty, it means the middleware accepts the stream/request/\nresponse and the processing of it can continue.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "replace_response",
              "description": "A boolean indicating that the gRPC message should be replaced/overwritten.\nThis boolean is needed because in protobuf an empty message is serialized as\na 0-length or nil byte slice and we wouldn't be able to distinguish between\nan empty replacement message and the \"don't replace anything\" case.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "replacement_serialized",
              "description": "If the replace_response field is set to true, this field must contain the\nbinary serialized gRPC message in the protobuf format.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Invoice",
          "longName": "Invoice",
          "fullName": "lnrpc.Invoice",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "memo",
              "description": "An optional memo to attach along with the invoice. Used for record keeping\npurposes for the invoice's creator, and will also be set in the description\nfield of the encoded payment request if the description_hash field is not\nbeing used.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "r_preimage",
              "description": "The hex-encoded preimage (32 byte) which will allow settling an incoming\nHTLC payable to this preimage. When using REST, this field must be encoded\nas base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "r_hash",
              "description": "The hash of the preimage. When using REST, this field must be encoded as\nbase64.\nNote: Output only, don't specify for creating an invoice.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "The value of this invoice in satoshis\n\nThe fields value and value_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value_msat",
              "description": "The value of this invoice in millisatoshis\n\nThe fields value and value_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "settled",
              "description": "Whether this invoice has been fulfilled",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "creation_date",
              "description": "When this invoice was created.\nNote: Output only, don't specify for creating an invoice.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "settle_date",
              "description": "When this invoice was settled.\nNote: Output only, don't specify for creating an invoice.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_request",
              "description": "A bare-bones invoice for a payment within the Lightning Network. With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient.\nNote: Output only, don't specify for creating an invoice.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "description_hash",
              "description": "Hash (SHA-256) of a description of the payment. Used if the description of\npayment (memo) is too long to naturally fit within the description field\nof an encoded payment request. When using REST, this field must be encoded\nas base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "expiry",
              "description": "Payment request expiry time in seconds. Default is 3600 (1 hour).",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fallback_addr",
              "description": "Fallback on-chain address.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "cltv_expiry",
              "description": "Delta to use for the time-lock of the CLTV extended to the final hop.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "route_hints",
              "description": "Route hints that can each be individually used to assist in reaching the\ninvoice's destination.",
              "label": "repeated",
              "type": "RouteHint",
              "longType": "RouteHint",
              "fullType": "lnrpc.RouteHint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "private",
              "description": "Whether this invoice should include routing hints for private channels.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "add_index",
              "description": "The \"add\" index of this invoice. Each newly created invoice will increment\nthis index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all added\ninvoices with an add_index greater than this one.\nNote: Output only, don't specify for creating an invoice.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "settle_index",
              "description": "The \"settle\" index of this invoice. Each newly settled invoice will\nincrement this index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all\nsettled invoices with an settle_index greater than this one.\nNote: Output only, don't specify for creating an invoice.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_paid",
              "description": "Deprecated, use amt_paid_sat or amt_paid_msat.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "amt_paid_sat",
              "description": "The amount that was accepted for this invoice, in satoshis. This will ONLY\nbe set if this invoice has been settled. We provide this field as if the\ninvoice was created with a zero value, then we need to record what amount\nwas ultimately accepted. Additionally, it's possible that the sender paid\nMORE that was specified in the original invoice. So we'll record that here\nas well.\nNote: Output only, don't specify for creating an invoice.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_paid_msat",
              "description": "The amount that was accepted for this invoice, in millisatoshis. This will\nONLY be set if this invoice has been settled. We provide this field as if\nthe invoice was created with a zero value, then we need to record what\namount was ultimately accepted. Additionally, it's possible that the sender\npaid MORE that was specified in the original invoice. So we'll record that\nhere as well.\nNote: Output only, don't specify for creating an invoice.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "state",
              "description": "The state the invoice is in.\nNote: Output only, don't specify for creating an invoice.",
              "label": "",
              "type": "InvoiceState",
              "longType": "Invoice.InvoiceState",
              "fullType": "lnrpc.Invoice.InvoiceState",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "htlcs",
              "description": "List of HTLCs paying to this invoice [EXPERIMENTAL].\nNote: Output only, don't specify for creating an invoice.",
              "label": "repeated",
              "type": "InvoiceHTLC",
              "longType": "InvoiceHTLC",
              "fullType": "lnrpc.InvoiceHTLC",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "features",
              "description": "List of features advertised on the invoice.\nNote: Output only, don't specify for creating an invoice.",
              "label": "repeated",
              "type": "FeaturesEntry",
              "longType": "Invoice.FeaturesEntry",
              "fullType": "lnrpc.Invoice.FeaturesEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "is_keysend",
              "description": "Indicates if this invoice was a spontaneous payment that arrived via keysend\n[EXPERIMENTAL].\nNote: Output only, don't specify for creating an invoice.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_addr",
              "description": "The payment address of this invoice. This value will be used in MPP\npayments, and also for newer invoices that always require the MPP payload\nfor added end-to-end security.\nNote: Output only, don't specify for creating an invoice.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "is_amp",
              "description": "Signals whether or not this is an AMP invoice.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amp_invoice_state",
              "description": "[EXPERIMENTAL]:\n\nMaps a 32-byte hex-encoded set ID to the sub-invoice AMP state for the\ngiven set ID. This field is always populated for AMP invoices, and can be\nused along side LookupInvoice to obtain the HTLC information related to a\ngiven sub-invoice.\nNote: Output only, don't specify for creating an invoice.",
              "label": "repeated",
              "type": "AmpInvoiceStateEntry",
              "longType": "Invoice.AmpInvoiceStateEntry",
              "fullType": "lnrpc.Invoice.AmpInvoiceStateEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AmpInvoiceStateEntry",
          "longName": "Invoice.AmpInvoiceStateEntry",
          "fullName": "lnrpc.Invoice.AmpInvoiceStateEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "AMPInvoiceState",
              "longType": "AMPInvoiceState",
              "fullType": "lnrpc.AMPInvoiceState",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FeaturesEntry",
          "longName": "Invoice.FeaturesEntry",
          "fullName": "lnrpc.Invoice.FeaturesEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "Feature",
              "longType": "Feature",
              "fullType": "lnrpc.Feature",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "InvoiceHTLC",
          "longName": "InvoiceHTLC",
          "fullName": "lnrpc.InvoiceHTLC",
          "description": "Details of an HTLC that paid to an invoice",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chan_id",
              "description": "Short channel id over which the htlc was received.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "htlc_index",
              "description": "Index identifying the htlc on the channel.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_msat",
              "description": "The amount of the htlc in msat.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "accept_height",
              "description": "Block height at which this htlc was accepted.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "accept_time",
              "description": "Time at which this htlc was accepted.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "resolve_time",
              "description": "Time at which this htlc was settled or canceled.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "expiry_height",
              "description": "Block height at which this htlc expires.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "state",
              "description": "Current state the htlc is in.",
              "label": "",
              "type": "InvoiceHTLCState",
              "longType": "InvoiceHTLCState",
              "fullType": "lnrpc.InvoiceHTLCState",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "custom_records",
              "description": "Custom tlv records.",
              "label": "repeated",
              "type": "CustomRecordsEntry",
              "longType": "InvoiceHTLC.CustomRecordsEntry",
              "fullType": "lnrpc.InvoiceHTLC.CustomRecordsEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "mpp_total_amt_msat",
              "description": "The total amount of the mpp payment in msat.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amp",
              "description": "Details relevant to AMP HTLCs, only populated if this is an AMP HTLC.",
              "label": "",
              "type": "AMP",
              "longType": "AMP",
              "fullType": "lnrpc.AMP",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "CustomRecordsEntry",
          "longName": "InvoiceHTLC.CustomRecordsEntry",
          "fullName": "lnrpc.InvoiceHTLC.CustomRecordsEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "InvoiceSubscription",
          "longName": "InvoiceSubscription",
          "fullName": "lnrpc.InvoiceSubscription",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "add_index",
              "description": "If specified (non-zero), then we'll first start by sending out\nnotifications for all added indexes with an add_index greater than this\nvalue. This allows callers to catch up on any events they missed while they\nweren't connected to the streaming RPC.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "settle_index",
              "description": "If specified (non-zero), then we'll first start by sending out\nnotifications for all settled indexes with an settle_index greater than\nthis value. This allows callers to catch up on any events they missed while\nthey weren't connected to the streaming RPC.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "KeyDescriptor",
          "longName": "KeyDescriptor",
          "fullName": "lnrpc.KeyDescriptor",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "raw_key_bytes",
              "description": "The raw bytes of the key being identified.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "key_loc",
              "description": "The key locator that identifies which key to use for signing.",
              "label": "",
              "type": "KeyLocator",
              "longType": "KeyLocator",
              "fullType": "lnrpc.KeyLocator",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "KeyLocator",
          "longName": "KeyLocator",
          "fullName": "lnrpc.KeyLocator",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key_family",
              "description": "The family of key being identified.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "key_index",
              "description": "The precise index of the key being identified.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "LightningAddress",
          "longName": "LightningAddress",
          "fullName": "lnrpc.LightningAddress",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pubkey",
              "description": "The identity pubkey of the Lightning node.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "host",
              "description": "The network location of the lightning node, e.g. `69.69.69.69:1337` or\n`localhost:10011`.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "LightningNode",
          "longName": "LightningNode",
          "fullName": "lnrpc.LightningNode",
          "description": "An individual vertex/node within the channel graph. A node is\nconnected to other nodes by one or more channel edges emanating from it. As the\ngraph is directed, a node will also have an incoming edge attached to it for\neach outgoing edge.",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "last_update",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pub_key",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "alias",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "addresses",
              "description": "",
              "label": "repeated",
              "type": "NodeAddress",
              "longType": "NodeAddress",
              "fullType": "lnrpc.NodeAddress",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "color",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "features",
              "description": "",
              "label": "repeated",
              "type": "FeaturesEntry",
              "longType": "LightningNode.FeaturesEntry",
              "fullType": "lnrpc.LightningNode.FeaturesEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FeaturesEntry",
          "longName": "LightningNode.FeaturesEntry",
          "fullName": "lnrpc.LightningNode.FeaturesEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "Feature",
              "longType": "Feature",
              "fullType": "lnrpc.Feature",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListChannelsRequest",
          "longName": "ListChannelsRequest",
          "fullName": "lnrpc.ListChannelsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "active_only",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "inactive_only",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "public_only",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "private_only",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "peer",
              "description": "Filters the response for channels with a target peer's pubkey. If peer is\nempty, all channels will be returned.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListChannelsResponse",
          "longName": "ListChannelsResponse",
          "fullName": "lnrpc.ListChannelsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channels",
              "description": "The list of active channels",
              "label": "repeated",
              "type": "Channel",
              "longType": "Channel",
              "fullType": "lnrpc.Channel",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListInvoiceRequest",
          "longName": "ListInvoiceRequest",
          "fullName": "lnrpc.ListInvoiceRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pending_only",
              "description": "If set, only invoices that are not settled and not canceled will be returned\nin the response.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "index_offset",
              "description": "The index of an invoice that will be used as either the start or end of a\nquery to determine which invoices should be returned in the response.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_max_invoices",
              "description": "The max number of invoices to return in the response to this query.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "reversed",
              "description": "If set, the invoices returned will result from seeking backwards from the\nspecified index offset. This can be used to paginate backwards.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListInvoiceResponse",
          "longName": "ListInvoiceResponse",
          "fullName": "lnrpc.ListInvoiceResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "invoices",
              "description": "A list of invoices from the time slice of the time series specified in the\nrequest.",
              "label": "repeated",
              "type": "Invoice",
              "longType": "Invoice",
              "fullType": "lnrpc.Invoice",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "last_index_offset",
              "description": "The index of the last item in the set of returned invoices. This can be used\nto seek further, pagination style.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "first_index_offset",
              "description": "The index of the last item in the set of returned invoices. This can be used\nto seek backwards, pagination style.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListMacaroonIDsRequest",
          "longName": "ListMacaroonIDsRequest",
          "fullName": "lnrpc.ListMacaroonIDsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "ListMacaroonIDsResponse",
          "longName": "ListMacaroonIDsResponse",
          "fullName": "lnrpc.ListMacaroonIDsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "root_key_ids",
              "description": "The list of root key IDs that are in use.",
              "label": "repeated",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListPaymentsRequest",
          "longName": "ListPaymentsRequest",
          "fullName": "lnrpc.ListPaymentsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "include_incomplete",
              "description": "If true, then return payments that have not yet fully completed. This means\nthat pending payments, as well as failed payments will show up if this\nfield is set to true. This flag doesn't change the meaning of the indices,\nwhich are tied to individual payments.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "index_offset",
              "description": "The index of a payment that will be used as either the start or end of a\nquery to determine which payments should be returned in the response. The\nindex_offset is exclusive. In the case of a zero index_offset, the query\nwill start with the oldest payment when paginating forwards, or will end\nwith the most recent payment when paginating backwards.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_payments",
              "description": "The maximal number of payments returned in the response to this query.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "reversed",
              "description": "If set, the payments returned will result from seeking backwards from the\nspecified index offset. This can be used to paginate backwards. The order\nof the returned payments is always oldest first (ascending index order).",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "count_total_payments",
              "description": "If set, all payments (complete and incomplete, independent of the\nmax_payments parameter) will be counted. Note that setting this to true will\nincrease the run time of the call significantly on systems that have a lot\nof payments, as all of them have to be iterated through to be counted.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListPaymentsResponse",
          "longName": "ListPaymentsResponse",
          "fullName": "lnrpc.ListPaymentsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "payments",
              "description": "The list of payments",
              "label": "repeated",
              "type": "Payment",
              "longType": "Payment",
              "fullType": "lnrpc.Payment",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "first_index_offset",
              "description": "The index of the first item in the set of returned payments. This can be\nused as the index_offset to continue seeking backwards in the next request.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "last_index_offset",
              "description": "The index of the last item in the set of returned payments. This can be used\nas the index_offset to continue seeking forwards in the next request.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "total_num_payments",
              "description": "Will only be set if count_total_payments in the request was set. Represents\nthe total number of payments (complete and incomplete, independent of the\nnumber of payments requested in the query) currently present in the payments\ndatabase.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListPeersRequest",
          "longName": "ListPeersRequest",
          "fullName": "lnrpc.ListPeersRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "latest_error",
              "description": "If true, only the last error that our peer sent us will be returned with\nthe peer's information, rather than the full set of historic errors we have\nstored.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListPeersResponse",
          "longName": "ListPeersResponse",
          "fullName": "lnrpc.ListPeersResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "peers",
              "description": "The list of currently connected peers",
              "label": "repeated",
              "type": "Peer",
              "longType": "Peer",
              "fullType": "lnrpc.Peer",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListPermissionsRequest",
          "longName": "ListPermissionsRequest",
          "fullName": "lnrpc.ListPermissionsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "ListPermissionsResponse",
          "longName": "ListPermissionsResponse",
          "fullName": "lnrpc.ListPermissionsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "method_permissions",
              "description": "A map between all RPC method URIs and their required macaroon permissions to\naccess them.",
              "label": "repeated",
              "type": "MethodPermissionsEntry",
              "longType": "ListPermissionsResponse.MethodPermissionsEntry",
              "fullType": "lnrpc.ListPermissionsResponse.MethodPermissionsEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MethodPermissionsEntry",
          "longName": "ListPermissionsResponse.MethodPermissionsEntry",
          "fullName": "lnrpc.ListPermissionsResponse.MethodPermissionsEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "MacaroonPermissionList",
              "longType": "MacaroonPermissionList",
              "fullType": "lnrpc.MacaroonPermissionList",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListUnspentRequest",
          "longName": "ListUnspentRequest",
          "fullName": "lnrpc.ListUnspentRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "min_confs",
              "description": "The minimum number of confirmations to be included.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_confs",
              "description": "The maximum number of confirmations to be included.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "account",
              "description": "An optional filter to only include outputs belonging to an account.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListUnspentResponse",
          "longName": "ListUnspentResponse",
          "fullName": "lnrpc.ListUnspentResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "utxos",
              "description": "A list of utxos",
              "label": "repeated",
              "type": "Utxo",
              "longType": "Utxo",
              "fullType": "lnrpc.Utxo",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MPPRecord",
          "longName": "MPPRecord",
          "fullName": "lnrpc.MPPRecord",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "payment_addr",
              "description": "A unique, random identifier used to authenticate the sender as the intended\npayer of a multi-path payment. The payment_addr must be the same for all\nsubpayments, and match the payment_addr provided in the receiver's invoice.\nThe same payment_addr must be used on all subpayments.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "total_amt_msat",
              "description": "The total amount in milli-satoshis being sent as part of a larger multi-path\npayment. The caller is responsible for ensuring subpayments to the same node\nand payment_hash sum exactly to total_amt_msat. The same\ntotal_amt_msat must be used on all subpayments.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MacaroonId",
          "longName": "MacaroonId",
          "fullName": "lnrpc.MacaroonId",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "nonce",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "storageId",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "ops",
              "description": "",
              "label": "repeated",
              "type": "Op",
              "longType": "Op",
              "fullType": "lnrpc.Op",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MacaroonPermission",
          "longName": "MacaroonPermission",
          "fullName": "lnrpc.MacaroonPermission",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "entity",
              "description": "The entity a permission grants access to.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "action",
              "description": "The action that is granted.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MacaroonPermissionList",
          "longName": "MacaroonPermissionList",
          "fullName": "lnrpc.MacaroonPermissionList",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "permissions",
              "description": "A list of macaroon permissions.",
              "label": "repeated",
              "type": "MacaroonPermission",
              "longType": "MacaroonPermission",
              "fullType": "lnrpc.MacaroonPermission",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MiddlewareRegistration",
          "longName": "MiddlewareRegistration",
          "fullName": "lnrpc.MiddlewareRegistration",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "middleware_name",
              "description": "The name of the middleware to register. The name should be as informative\nas possible and is logged on registration.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "custom_macaroon_caveat_name",
              "description": "The name of the custom macaroon caveat that this middleware is responsible\nfor. Only requests/responses that contain a macaroon with the registered\ncustom caveat are forwarded for interception to the middleware. The\nexception being the read-only mode: All requests/responses are forwarded to\na middleware that requests read-only access but such a middleware won't be\nallowed to _alter_ responses. As a security measure, _no_ middleware can\nchange responses to requests made with _unencumbered_ macaroons!\nNOTE: Cannot be used at the same time as read_only_mode.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "read_only_mode",
              "description": "Instead of defining a custom macaroon caveat name a middleware can register\nitself for read-only access only. In that mode all requests/responses are\nforwarded to the middleware but the middleware isn't allowed to alter any of\nthe responses.\nNOTE: Cannot be used at the same time as custom_macaroon_caveat_name.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "MultiChanBackup",
          "longName": "MultiChanBackup",
          "fullName": "lnrpc.MultiChanBackup",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "chan_points",
              "description": "Is the set of all channels that are included in this multi-channel backup.",
              "label": "repeated",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "multi_chan_backup",
              "description": "A single encrypted blob containing all the static channel backups of the\nchannel listed above. This can be stored as a single file or blob, and\nsafely be replaced with any prior/future versions. When using REST, this\nfield must be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "NetworkInfo",
          "longName": "NetworkInfo",
          "fullName": "lnrpc.NetworkInfo",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "graph_diameter",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "avg_out_degree",
              "description": "",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_out_degree",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_nodes",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_channels",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "total_network_capacity",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "avg_channel_size",
              "description": "",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_channel_size",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_channel_size",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "median_channel_size_sat",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_zombie_chans",
              "description": "The number of edges marked as zombies.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "NetworkInfoRequest",
          "longName": "NetworkInfoRequest",
          "fullName": "lnrpc.NetworkInfoRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "NewAddressRequest",
          "longName": "NewAddressRequest",
          "fullName": "lnrpc.NewAddressRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "type",
              "description": "The type of address to generate.",
              "label": "",
              "type": "AddressType",
              "longType": "AddressType",
              "fullType": "lnrpc.AddressType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "account",
              "description": "The name of the account to generate a new address for. If empty, the\ndefault wallet account is used.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "NewAddressResponse",
          "longName": "NewAddressResponse",
          "fullName": "lnrpc.NewAddressResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "address",
              "description": "The newly generated wallet address",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "NodeAddress",
          "longName": "NodeAddress",
          "fullName": "lnrpc.NodeAddress",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "network",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "addr",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "NodeInfo",
          "longName": "NodeInfo",
          "fullName": "lnrpc.NodeInfo",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "node",
              "description": "An individual vertex/node within the channel graph. A node is\nconnected to other nodes by one or more channel edges emanating from it. As\nthe graph is directed, a node will also have an incoming edge attached to\nit for each outgoing edge.",
              "label": "",
              "type": "LightningNode",
              "longType": "LightningNode",
              "fullType": "lnrpc.LightningNode",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_channels",
              "description": "The total number of channels for the node.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "total_capacity",
              "description": "The sum of all channels capacity for the node, denominated in satoshis.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "channels",
              "description": "A list of all public channels for the node.",
              "label": "repeated",
              "type": "ChannelEdge",
              "longType": "ChannelEdge",
              "fullType": "lnrpc.ChannelEdge",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "NodeInfoRequest",
          "longName": "NodeInfoRequest",
          "fullName": "lnrpc.NodeInfoRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pub_key",
              "description": "The 33-byte hex-encoded compressed public of the target node",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "include_channels",
              "description": "If true, will include all known channels associated with the node.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "NodeMetricsRequest",
          "longName": "NodeMetricsRequest",
          "fullName": "lnrpc.NodeMetricsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "types",
              "description": "The requested node metrics.",
              "label": "repeated",
              "type": "NodeMetricType",
              "longType": "NodeMetricType",
              "fullType": "lnrpc.NodeMetricType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "NodeMetricsResponse",
          "longName": "NodeMetricsResponse",
          "fullName": "lnrpc.NodeMetricsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "betweenness_centrality",
              "description": "Betweenness centrality is the sum of the ratio of shortest paths that pass\nthrough the node for each pair of nodes in the graph (not counting paths\nstarting or ending at this node).\nMap of node pubkey to betweenness centrality of the node. Normalized\nvalues are in the [0,1] closed interval.",
              "label": "repeated",
              "type": "BetweennessCentralityEntry",
              "longType": "NodeMetricsResponse.BetweennessCentralityEntry",
              "fullType": "lnrpc.NodeMetricsResponse.BetweennessCentralityEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "BetweennessCentralityEntry",
          "longName": "NodeMetricsResponse.BetweennessCentralityEntry",
          "fullName": "lnrpc.NodeMetricsResponse.BetweennessCentralityEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "FloatMetric",
              "longType": "FloatMetric",
              "fullType": "lnrpc.FloatMetric",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "NodePair",
          "longName": "NodePair",
          "fullName": "lnrpc.NodePair",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "from",
              "description": "The sending node of the pair. When using REST, this field must be encoded as\nbase64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "to",
              "description": "The receiving node of the pair. When using REST, this field must be encoded\nas base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "NodeUpdate",
          "longName": "NodeUpdate",
          "fullName": "lnrpc.NodeUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "addresses",
              "description": "Deprecated, use node_addresses.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "identity_key",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "global_features",
              "description": "Deprecated, use features.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "alias",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "color",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "node_addresses",
              "description": "",
              "label": "repeated",
              "type": "NodeAddress",
              "longType": "NodeAddress",
              "fullType": "lnrpc.NodeAddress",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "features",
              "description": "Features that the node has advertised in the init message, node\nannouncements and invoices.",
              "label": "repeated",
              "type": "FeaturesEntry",
              "longType": "NodeUpdate.FeaturesEntry",
              "fullType": "lnrpc.NodeUpdate.FeaturesEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FeaturesEntry",
          "longName": "NodeUpdate.FeaturesEntry",
          "fullName": "lnrpc.NodeUpdate.FeaturesEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "Feature",
              "longType": "Feature",
              "fullType": "lnrpc.Feature",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Op",
          "longName": "Op",
          "fullName": "lnrpc.Op",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "entity",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "actions",
              "description": "",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "OpenChannelRequest",
          "longName": "OpenChannelRequest",
          "fullName": "lnrpc.OpenChannelRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "sat_per_vbyte",
              "description": "A manual fee rate set in sat/vbyte that should be used when crafting the\nfunding transaction.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "node_pubkey",
              "description": "The pubkey of the node to open a channel with. When using REST, this field\nmust be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "node_pubkey_string",
              "description": "The hex encoded pubkey of the node to open a channel with. Deprecated now\nthat the REST gateway supports base64 encoding of bytes fields.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "local_funding_amount",
              "description": "The number of satoshis the wallet should commit to the channel",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "push_sat",
              "description": "The number of satoshis to push to the remote side as part of the initial\ncommitment state",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "target_conf",
              "description": "The target number of blocks that the funding transaction should be\nconfirmed by.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_per_byte",
              "description": "Deprecated, use sat_per_vbyte.\nA manual fee rate set in sat/vbyte that should be used when crafting the\nfunding transaction.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "private",
              "description": "Whether this channel should be private, not announced to the greater\nnetwork.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_htlc_msat",
              "description": "The minimum value in millisatoshi we will require for incoming HTLCs on\nthe channel.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_csv_delay",
              "description": "The delay we require on the remote's commitment transaction. If this is\nnot set, it will be scaled automatically with the channel size.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_confs",
              "description": "The minimum number of confirmations each one of your outputs used for\nthe funding transaction must satisfy.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "spend_unconfirmed",
              "description": "Whether unconfirmed outputs should be used as inputs for the funding\ntransaction.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "close_address",
              "description": "Close address is an optional address which specifies the address to which\nfunds should be paid out to upon cooperative close. This field may only be\nset if the peer supports the option upfront feature bit (call listpeers\nto check). The remote peer will only accept cooperative closes to this\naddress if it is set.\n\nNote: If this value is set on channel creation, you will *not* be able to\ncooperatively close out to a different address.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "funding_shim",
              "description": "Funding shims are an optional argument that allow the caller to intercept\ncertain funding functionality. For example, a shim can be provided to use a\nparticular key for the commitment key (ideally cold) rather than use one\nthat is generated by the wallet as normal, or signal that signing will be\ncarried out in an interactive manner (PSBT based).",
              "label": "",
              "type": "FundingShim",
              "longType": "FundingShim",
              "fullType": "lnrpc.FundingShim",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_max_value_in_flight_msat",
              "description": "The maximum amount of coins in millisatoshi that can be pending within\nthe channel. It only applies to the remote party.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_max_htlcs",
              "description": "The maximum number of concurrent HTLCs we will allow the remote party to add\nto the commitment transaction.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_local_csv",
              "description": "Max local csv is the maximum csv delay we will allow for our own commitment\ntransaction.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "commitment_type",
              "description": "The explicit commitment type to use. Note this field will only be used if\nthe remote peer supports explicit channel negotiation.",
              "label": "",
              "type": "CommitmentType",
              "longType": "CommitmentType",
              "fullType": "lnrpc.CommitmentType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "zero_conf",
              "description": "If this is true, then a zero-conf channel open will be attempted.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "scid_alias",
              "description": "If this is true, then an option-scid-alias channel-type open will be\nattempted.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "OpenStatusUpdate",
          "longName": "OpenStatusUpdate",
          "fullName": "lnrpc.OpenStatusUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "chan_pending",
              "description": "Signals that the channel is now fully negotiated and the funding\ntransaction published.",
              "label": "",
              "type": "PendingUpdate",
              "longType": "PendingUpdate",
              "fullType": "lnrpc.PendingUpdate",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "update",
              "defaultValue": ""
            },
            {
              "name": "chan_open",
              "description": "Signals that the channel's funding transaction has now reached the\nrequired number of confirmations on chain and can be used.",
              "label": "",
              "type": "ChannelOpenUpdate",
              "longType": "ChannelOpenUpdate",
              "fullType": "lnrpc.ChannelOpenUpdate",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "update",
              "defaultValue": ""
            },
            {
              "name": "psbt_fund",
              "description": "Signals that the funding process has been suspended and the construction\nof a PSBT that funds the channel PK script is now required.",
              "label": "",
              "type": "ReadyForPsbtFunding",
              "longType": "ReadyForPsbtFunding",
              "fullType": "lnrpc.ReadyForPsbtFunding",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "update",
              "defaultValue": ""
            },
            {
              "name": "pending_chan_id",
              "description": "The pending channel ID of the created channel. This value may be used to\nfurther the funding flow manually via the FundingStateStep method.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "OutPoint",
          "longName": "OutPoint",
          "fullName": "lnrpc.OutPoint",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "txid_bytes",
              "description": "Raw bytes representing the transaction id.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "txid_str",
              "description": "Reversed, hex-encoded string representing the transaction id.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "output_index",
              "description": "The index of the output on the transaction.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "OutputDetail",
          "longName": "OutputDetail",
          "fullName": "lnrpc.OutputDetail",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "output_type",
              "description": "The type of the output",
              "label": "",
              "type": "OutputScriptType",
              "longType": "OutputScriptType",
              "fullType": "lnrpc.OutputScriptType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "address",
              "description": "The address",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pk_script",
              "description": "The pkscript in hex",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "output_index",
              "description": "The output index used in the raw transaction",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amount",
              "description": "The value of the output coin in satoshis",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "is_our_address",
              "description": "Denotes if the output is controlled by the internal wallet",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PayReq",
          "longName": "PayReq",
          "fullName": "lnrpc.PayReq",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "destination",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_hash",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_satoshis",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "timestamp",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "expiry",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "description",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "description_hash",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fallback_addr",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "cltv_expiry",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "route_hints",
              "description": "",
              "label": "repeated",
              "type": "RouteHint",
              "longType": "RouteHint",
              "fullType": "lnrpc.RouteHint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_addr",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_msat",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "features",
              "description": "",
              "label": "repeated",
              "type": "FeaturesEntry",
              "longType": "PayReq.FeaturesEntry",
              "fullType": "lnrpc.PayReq.FeaturesEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FeaturesEntry",
          "longName": "PayReq.FeaturesEntry",
          "fullName": "lnrpc.PayReq.FeaturesEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "Feature",
              "longType": "Feature",
              "fullType": "lnrpc.Feature",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PayReqString",
          "longName": "PayReqString",
          "fullName": "lnrpc.PayReqString",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pay_req",
              "description": "The payment request string to be decoded",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Payment",
          "longName": "Payment",
          "fullName": "lnrpc.Payment",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "payment_hash",
              "description": "The payment hash",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "Deprecated, use value_sat or value_msat.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "creation_date",
              "description": "Deprecated, use creation_time_ns",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "fee",
              "description": "Deprecated, use fee_sat or fee_msat.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "payment_preimage",
              "description": "The payment preimage",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value_sat",
              "description": "The value of the payment in satoshis",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value_msat",
              "description": "The value of the payment in milli-satoshis",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_request",
              "description": "The optional payment request being fulfilled.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "status",
              "description": "The status of the payment.",
              "label": "",
              "type": "PaymentStatus",
              "longType": "Payment.PaymentStatus",
              "fullType": "lnrpc.Payment.PaymentStatus",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_sat",
              "description": "The fee paid for this payment in satoshis",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_msat",
              "description": "The fee paid for this payment in milli-satoshis",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "creation_time_ns",
              "description": "The time in UNIX nanoseconds at which the payment was created.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "htlcs",
              "description": "The HTLCs made in attempt to settle the payment.",
              "label": "repeated",
              "type": "HTLCAttempt",
              "longType": "HTLCAttempt",
              "fullType": "lnrpc.HTLCAttempt",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_index",
              "description": "The creation index of this payment. Each payment can be uniquely identified\nby this index, which may not strictly increment by 1 for payments made in\nolder versions of lnd.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "failure_reason",
              "description": "",
              "label": "",
              "type": "PaymentFailureReason",
              "longType": "PaymentFailureReason",
              "fullType": "lnrpc.PaymentFailureReason",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PaymentHash",
          "longName": "PaymentHash",
          "fullName": "lnrpc.PaymentHash",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "r_hash_str",
              "description": "The hex-encoded payment hash of the invoice to be looked up. The passed\npayment hash must be exactly 32 bytes, otherwise an error is returned.\nDeprecated now that the REST gateway supports base64 encoding of bytes\nfields.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "r_hash",
              "description": "The payment hash of the invoice to be looked up. When using REST, this field\nmust be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Peer",
          "longName": "Peer",
          "fullName": "lnrpc.Peer",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pub_key",
              "description": "The identity pubkey of the peer",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "address",
              "description": "Network address of the peer; eg `127.0.0.1:10011`",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "bytes_sent",
              "description": "Bytes of data transmitted to this peer",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "bytes_recv",
              "description": "Bytes of data transmitted from this peer",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_sent",
              "description": "Satoshis sent to this peer",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_recv",
              "description": "Satoshis received from this peer",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "inbound",
              "description": "A channel is inbound if the counterparty initiated the channel",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "ping_time",
              "description": "Ping time to this peer",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sync_type",
              "description": "The type of sync we are currently performing with this peer.",
              "label": "",
              "type": "SyncType",
              "longType": "Peer.SyncType",
              "fullType": "lnrpc.Peer.SyncType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "features",
              "description": "Features advertised by the remote peer in their init message.",
              "label": "repeated",
              "type": "FeaturesEntry",
              "longType": "Peer.FeaturesEntry",
              "fullType": "lnrpc.Peer.FeaturesEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "errors",
              "description": "The latest errors received from our peer with timestamps, limited to the 10\nmost recent errors. These errors are tracked across peer connections, but\nare not persisted across lnd restarts. Note that these errors are only\nstored for peers that we have channels open with, to prevent peers from\nspamming us with errors at no cost.",
              "label": "repeated",
              "type": "TimestampedError",
              "longType": "TimestampedError",
              "fullType": "lnrpc.TimestampedError",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "flap_count",
              "description": "The number of times we have recorded this peer going offline or coming\nonline, recorded across restarts. Note that this value is decreased over\ntime if the peer has not recently flapped, so that we can forgive peers\nwith historically high flap counts.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "last_flap_ns",
              "description": "The timestamp of the last flap we observed for this peer. If this value is\nzero, we have not observed any flaps for this peer.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "last_ping_payload",
              "description": "The last ping payload the peer has sent to us.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "FeaturesEntry",
          "longName": "Peer.FeaturesEntry",
          "fullName": "lnrpc.Peer.FeaturesEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "Feature",
              "longType": "Feature",
              "fullType": "lnrpc.Feature",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PeerEvent",
          "longName": "PeerEvent",
          "fullName": "lnrpc.PeerEvent",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pub_key",
              "description": "The identity pubkey of the peer.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "type",
              "description": "",
              "label": "",
              "type": "EventType",
              "longType": "PeerEvent.EventType",
              "fullType": "lnrpc.PeerEvent.EventType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PeerEventSubscription",
          "longName": "PeerEventSubscription",
          "fullName": "lnrpc.PeerEventSubscription",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "PendingChannelsRequest",
          "longName": "PendingChannelsRequest",
          "fullName": "lnrpc.PendingChannelsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "PendingChannelsResponse",
          "longName": "PendingChannelsResponse",
          "fullName": "lnrpc.PendingChannelsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "total_limbo_balance",
              "description": "The balance in satoshis encumbered in pending channels",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_open_channels",
              "description": "Channels pending opening",
              "label": "repeated",
              "type": "PendingOpenChannel",
              "longType": "PendingChannelsResponse.PendingOpenChannel",
              "fullType": "lnrpc.PendingChannelsResponse.PendingOpenChannel",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_closing_channels",
              "description": "Deprecated: Channels pending closing previously contained cooperatively\nclosed channels with a single confirmation. These channels are now\nconsidered closed from the time we see them on chain.",
              "label": "repeated",
              "type": "ClosedChannel",
              "longType": "PendingChannelsResponse.ClosedChannel",
              "fullType": "lnrpc.PendingChannelsResponse.ClosedChannel",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "pending_force_closing_channels",
              "description": "Channels pending force closing",
              "label": "repeated",
              "type": "ForceClosedChannel",
              "longType": "PendingChannelsResponse.ForceClosedChannel",
              "fullType": "lnrpc.PendingChannelsResponse.ForceClosedChannel",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "waiting_close_channels",
              "description": "Channels waiting for closing tx to confirm",
              "label": "repeated",
              "type": "WaitingCloseChannel",
              "longType": "PendingChannelsResponse.WaitingCloseChannel",
              "fullType": "lnrpc.PendingChannelsResponse.WaitingCloseChannel",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ClosedChannel",
          "longName": "PendingChannelsResponse.ClosedChannel",
          "fullName": "lnrpc.PendingChannelsResponse.ClosedChannel",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channel",
              "description": "The pending channel to be closed",
              "label": "",
              "type": "PendingChannel",
              "longType": "PendingChannelsResponse.PendingChannel",
              "fullType": "lnrpc.PendingChannelsResponse.PendingChannel",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "closing_txid",
              "description": "The transaction id of the closing transaction",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Commitments",
          "longName": "PendingChannelsResponse.Commitments",
          "fullName": "lnrpc.PendingChannelsResponse.Commitments",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "local_txid",
              "description": "Hash of the local version of the commitment tx.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_txid",
              "description": "Hash of the remote version of the commitment tx.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_pending_txid",
              "description": "Hash of the remote pending version of the commitment tx.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "local_commit_fee_sat",
              "description": "The amount in satoshis calculated to be paid in fees for the local\ncommitment.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_commit_fee_sat",
              "description": "The amount in satoshis calculated to be paid in fees for the remote\ncommitment.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_pending_commit_fee_sat",
              "description": "The amount in satoshis calculated to be paid in fees for the remote\npending commitment.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ForceClosedChannel",
          "longName": "PendingChannelsResponse.ForceClosedChannel",
          "fullName": "lnrpc.PendingChannelsResponse.ForceClosedChannel",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channel",
              "description": "The pending channel to be force closed",
              "label": "",
              "type": "PendingChannel",
              "longType": "PendingChannelsResponse.PendingChannel",
              "fullType": "lnrpc.PendingChannelsResponse.PendingChannel",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "closing_txid",
              "description": "The transaction id of the closing transaction",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "limbo_balance",
              "description": "The balance in satoshis encumbered in this pending channel",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "maturity_height",
              "description": "The height at which funds can be swept into the wallet",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "blocks_til_maturity",
              "description": "Remaining # of blocks until the commitment output can be swept.\nNegative values indicate how many blocks have passed since becoming\nmature.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "recovered_balance",
              "description": "The total value of funds successfully recovered from this channel",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pending_htlcs",
              "description": "",
              "label": "repeated",
              "type": "PendingHTLC",
              "longType": "PendingHTLC",
              "fullType": "lnrpc.PendingHTLC",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "anchor",
              "description": "",
              "label": "",
              "type": "AnchorState",
              "longType": "PendingChannelsResponse.ForceClosedChannel.AnchorState",
              "fullType": "lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PendingChannel",
          "longName": "PendingChannelsResponse.PendingChannel",
          "fullName": "lnrpc.PendingChannelsResponse.PendingChannel",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "remote_node_pub",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "channel_point",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "capacity",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "local_balance",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_balance",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "local_chan_reserve_sat",
              "description": "The minimum satoshis this node is required to reserve in its\nbalance.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "remote_chan_reserve_sat",
              "description": "The minimum satoshis the other node is required to reserve in its\nbalance.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "initiator",
              "description": "The party that initiated opening the channel.",
              "label": "",
              "type": "Initiator",
              "longType": "Initiator",
              "fullType": "lnrpc.Initiator",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "commitment_type",
              "description": "The commitment type used by this channel.",
              "label": "",
              "type": "CommitmentType",
              "longType": "CommitmentType",
              "fullType": "lnrpc.CommitmentType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_forwarding_packages",
              "description": "Total number of forwarding packages created in this channel.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "chan_status_flags",
              "description": "A set of flags showing the current state of the channel.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "private",
              "description": "Whether this channel is advertised to the network or not.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PendingOpenChannel",
          "longName": "PendingChannelsResponse.PendingOpenChannel",
          "fullName": "lnrpc.PendingChannelsResponse.PendingOpenChannel",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channel",
              "description": "The pending channel",
              "label": "",
              "type": "PendingChannel",
              "longType": "PendingChannelsResponse.PendingChannel",
              "fullType": "lnrpc.PendingChannelsResponse.PendingChannel",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "commit_fee",
              "description": "The amount calculated to be paid in fees for the current set of\ncommitment transactions. The fee amount is persisted with the channel\nin order to allow the fee amount to be removed and recalculated with\neach channel state update, including updates that happen after a system\nrestart.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "commit_weight",
              "description": "The weight of the commitment transaction",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_per_kw",
              "description": "The required number of satoshis per kilo-weight that the requester will\npay at all times, for both the funding transaction and commitment\ntransaction. This value can later be updated once the channel is open.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "WaitingCloseChannel",
          "longName": "PendingChannelsResponse.WaitingCloseChannel",
          "fullName": "lnrpc.PendingChannelsResponse.WaitingCloseChannel",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "channel",
              "description": "The pending channel waiting for closing tx to confirm",
              "label": "",
              "type": "PendingChannel",
              "longType": "PendingChannelsResponse.PendingChannel",
              "fullType": "lnrpc.PendingChannelsResponse.PendingChannel",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "limbo_balance",
              "description": "The balance in satoshis encumbered in this channel",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "commitments",
              "description": "A list of valid commitment transactions. Any of these can confirm at\nthis point.",
              "label": "",
              "type": "Commitments",
              "longType": "PendingChannelsResponse.Commitments",
              "fullType": "lnrpc.PendingChannelsResponse.Commitments",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "closing_txid",
              "description": "The transaction id of the closing transaction",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PendingHTLC",
          "longName": "PendingHTLC",
          "fullName": "lnrpc.PendingHTLC",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "incoming",
              "description": "The direction within the channel that the htlc was sent",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amount",
              "description": "The total value of the htlc",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outpoint",
              "description": "The final output to be swept back to the user's wallet",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "maturity_height",
              "description": "The next block height at which we can spend the current stage",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "blocks_til_maturity",
              "description": "The number of blocks remaining until the current stage can be swept.\nNegative values indicate how many blocks have passed since becoming\nmature.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "stage",
              "description": "Indicates whether the htlc is in its first or second stage of recovery",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PendingUpdate",
          "longName": "PendingUpdate",
          "fullName": "lnrpc.PendingUpdate",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "txid",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "output_index",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PolicyUpdateRequest",
          "longName": "PolicyUpdateRequest",
          "fullName": "lnrpc.PolicyUpdateRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "global",
              "description": "If set, then this update applies to all currently active channels.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "scope",
              "defaultValue": ""
            },
            {
              "name": "chan_point",
              "description": "If set, this update will target a specific channel.",
              "label": "",
              "type": "ChannelPoint",
              "longType": "ChannelPoint",
              "fullType": "lnrpc.ChannelPoint",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "scope",
              "defaultValue": ""
            },
            {
              "name": "base_fee_msat",
              "description": "The base fee charged regardless of the number of milli-satoshis sent.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_rate",
              "description": "The effective fee rate in milli-satoshis. The precision of this value\ngoes up to 6 decimal places, so 1e-6.",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_rate_ppm",
              "description": "The effective fee rate in micro-satoshis (parts per million).",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "time_lock_delta",
              "description": "The required timelock delta for HTLCs forwarded over the channel.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_htlc_msat",
              "description": "If set, the maximum HTLC size in milli-satoshis. If unset, the maximum\nHTLC will be unchanged.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_htlc_msat",
              "description": "The minimum HTLC size in milli-satoshis. Only applied if\nmin_htlc_msat_specified is true.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_htlc_msat_specified",
              "description": "If true, min_htlc_msat is applied.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PolicyUpdateResponse",
          "longName": "PolicyUpdateResponse",
          "fullName": "lnrpc.PolicyUpdateResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "failed_updates",
              "description": "List of failed policy updates.",
              "label": "repeated",
              "type": "FailedUpdate",
              "longType": "FailedUpdate",
              "fullType": "lnrpc.FailedUpdate",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PreviousOutPoint",
          "longName": "PreviousOutPoint",
          "fullName": "lnrpc.PreviousOutPoint",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "outpoint",
              "description": "The outpoint in format txid:n.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "is_our_output",
              "description": "Denotes if the outpoint is controlled by the internal wallet.\nThe flag will only detect p2wkh, np2wkh and p2tr inputs as its own.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PsbtShim",
          "longName": "PsbtShim",
          "fullName": "lnrpc.PsbtShim",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pending_chan_id",
              "description": "A unique identifier of 32 random bytes that will be used as the pending\nchannel ID to identify the PSBT state machine when interacting with it and\non the wire protocol to initiate the funding request.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "base_psbt",
              "description": "An optional base PSBT the new channel output will be added to. If this is\nnon-empty, it must be a binary serialized PSBT.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "no_publish",
              "description": "If a channel should be part of a batch (multiple channel openings in one\ntransaction), it can be dangerous if the whole batch transaction is\npublished too early before all channel opening negotiations are completed.\nThis flag prevents this particular channel from broadcasting the transaction\nafter the negotiation with the remote peer. In a batch of channel openings\nthis flag should be set to true for every channel but the very last.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "QueryRoutesRequest",
          "longName": "QueryRoutesRequest",
          "fullName": "lnrpc.QueryRoutesRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pub_key",
              "description": "The 33-byte hex-encoded public key for the payment destination",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt",
              "description": "The amount to send expressed in satoshis.\n\nThe fields amt and amt_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_msat",
              "description": "The amount to send expressed in millisatoshis.\n\nThe fields amt and amt_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "final_cltv_delta",
              "description": "An optional CLTV delta from the current height that should be used for the\ntimelock of the final hop. Note that unlike SendPayment, QueryRoutes does\nnot add any additional block padding on top of final_ctlv_delta. This\npadding of a few blocks needs to be added manually or otherwise failures may\nhappen when a block comes in while the payment is in flight.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_limit",
              "description": "The maximum number of satoshis that will be paid as a fee of the payment.\nThis value can be represented either as a percentage of the amount being\nsent, or as a fixed amount of the maximum fee the user is willing the pay to\nsend the payment. If not specified, lnd will use a default value of 100%\nfees for small amounts (\u003c=1k sat) or 5% fees for larger amounts.",
              "label": "",
              "type": "FeeLimit",
              "longType": "FeeLimit",
              "fullType": "lnrpc.FeeLimit",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "ignored_nodes",
              "description": "A list of nodes to ignore during path finding. When using REST, these fields\nmust be encoded as base64.",
              "label": "repeated",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "ignored_edges",
              "description": "Deprecated. A list of edges to ignore during path finding.",
              "label": "repeated",
              "type": "EdgeLocator",
              "longType": "EdgeLocator",
              "fullType": "lnrpc.EdgeLocator",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "source_pub_key",
              "description": "The source node where the request route should originated from. If empty,\nself is assumed.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "use_mission_control",
              "description": "If set to true, edge probabilities from mission control will be used to get\nthe optimal route.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "ignored_pairs",
              "description": "A list of directed node pairs that will be ignored during path finding.",
              "label": "repeated",
              "type": "NodePair",
              "longType": "NodePair",
              "fullType": "lnrpc.NodePair",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "cltv_limit",
              "description": "An optional maximum total time lock for the route. If the source is empty or\nourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If\nzero, then the value of `--max-cltv-expiry` is used as the limit.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dest_custom_records",
              "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto a peer which understands the new records. This can be used to pass\napplication specific data during the payment attempt. If the destination\ndoes not support the specified records, an error will be returned.\nRecord types are required to be in the custom range \u003e= 65536. When using\nREST, the values must be encoded as base64.",
              "label": "repeated",
              "type": "DestCustomRecordsEntry",
              "longType": "QueryRoutesRequest.DestCustomRecordsEntry",
              "fullType": "lnrpc.QueryRoutesRequest.DestCustomRecordsEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outgoing_chan_id",
              "description": "The channel id of the channel that must be taken to the first hop. If zero,\nany channel may be used.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "last_hop_pubkey",
              "description": "The pubkey of the last hop of the route. If empty, any hop may be used.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "route_hints",
              "description": "Optional route hints to reach the destination through private channels.",
              "label": "repeated",
              "type": "RouteHint",
              "longType": "RouteHint",
              "fullType": "lnrpc.RouteHint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dest_features",
              "description": "Features assumed to be supported by the final node. All transitive feature\ndependencies must also be set properly. For a given feature bit pair, either\noptional or remote may be set, but not both. If this field is nil or empty,\nthe router will try to load destination features from the graph as a\nfallback.",
              "label": "repeated",
              "type": "FeatureBit",
              "longType": "FeatureBit",
              "fullType": "lnrpc.FeatureBit",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "time_pref",
              "description": "The time preference for this payment. Set to -1 to optimize for fees\nonly, to 1 to optimize for reliability only or a value inbetween for a mix.",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "DestCustomRecordsEntry",
          "longName": "QueryRoutesRequest.DestCustomRecordsEntry",
          "fullName": "lnrpc.QueryRoutesRequest.DestCustomRecordsEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "QueryRoutesResponse",
          "longName": "QueryRoutesResponse",
          "fullName": "lnrpc.QueryRoutesResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "routes",
              "description": "The route that results from the path finding operation. This is still a\nrepeated field to retain backwards compatibility.",
              "label": "repeated",
              "type": "Route",
              "longType": "Route",
              "fullType": "lnrpc.Route",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "success_prob",
              "description": "The success probability of the returned route based on the current mission\ncontrol state. [EXPERIMENTAL]",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "RPCMessage",
          "longName": "RPCMessage",
          "fullName": "lnrpc.RPCMessage",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "method_full_uri",
              "description": "The full URI (in the format /\u003crpcpackage\u003e.\u003cServiceName\u003e/MethodName, for\nexample /lnrpc.Lightning/GetInfo) of the RPC method the message was sent\nto/from.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "stream_rpc",
              "description": "Indicates whether the message was sent over a streaming RPC method or not.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "type_name",
              "description": "The full canonical gRPC name of the message type (in the format\n\u003crpcpackage\u003e.TypeName, for example lnrpc.GetInfoRequest). In case of an\nerror being returned from lnd, this simply contains the string \"error\".",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "serialized",
              "description": "The full content of the gRPC message, serialized in the binary protobuf\nformat.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "is_error",
              "description": "Indicates that the response from lnd was an error, not a gRPC response. If\nthis is set to true then the type_name contains the string \"error\" and\nserialized contains the error string.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "RPCMiddlewareRequest",
          "longName": "RPCMiddlewareRequest",
          "fullName": "lnrpc.RPCMiddlewareRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "request_id",
              "description": "The unique ID of the intercepted original gRPC request. Useful for mapping\nrequest to response when implementing full duplex message interception. For\nstreaming requests, this will be the same ID for all incoming and outgoing\nmiddleware intercept messages of the _same_ stream.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "raw_macaroon",
              "description": "The raw bytes of the complete macaroon as sent by the gRPC client in the\noriginal request. This might be empty for a request that doesn't require\nmacaroons such as the wallet unlocker RPCs.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "custom_caveat_condition",
              "description": "The parsed condition of the macaroon's custom caveat for convenient access.\nThis field only contains the value of the custom caveat that the handling\nmiddleware has registered itself for. The condition _must_ be validated for\nmessages of intercept_type stream_auth and request!",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "stream_auth",
              "description": "Intercept stream authentication: each new streaming RPC call that is\ninitiated against lnd and contains the middleware's custom macaroon\ncaveat can be approved or denied based upon the macaroon in the stream\nheader. This message will only be sent for streaming RPCs, unary RPCs\nmust handle the macaroon authentication in the request interception to\navoid an additional message round trip between lnd and the middleware.",
              "label": "",
              "type": "StreamAuth",
              "longType": "StreamAuth",
              "fullType": "lnrpc.StreamAuth",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "intercept_type",
              "defaultValue": ""
            },
            {
              "name": "request",
              "description": "Intercept incoming gRPC client request message: all incoming messages,\nboth on streaming and unary RPCs, are forwarded to the middleware for\ninspection. For unary RPC messages the middleware is also expected to\nvalidate the custom macaroon caveat of the request.",
              "label": "",
              "type": "RPCMessage",
              "longType": "RPCMessage",
              "fullType": "lnrpc.RPCMessage",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "intercept_type",
              "defaultValue": ""
            },
            {
              "name": "response",
              "description": "Intercept outgoing gRPC response message: all outgoing messages, both on\nstreaming and unary RPCs, are forwarded to the middleware for inspection\nand amendment. The response in this message is the original response as\nit was generated by the main RPC server. It can either be accepted\n(=forwarded to the client), replaced/overwritten with a new message of\nthe same type, or replaced by an error message.",
              "label": "",
              "type": "RPCMessage",
              "longType": "RPCMessage",
              "fullType": "lnrpc.RPCMessage",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "intercept_type",
              "defaultValue": ""
            },
            {
              "name": "msg_id",
              "description": "The unique message ID of this middleware intercept message. There can be\nmultiple middleware intercept messages per single gRPC request (one for the\nincoming request and one for the outgoing response) or gRPC stream (one for\neach incoming message and one for each outgoing response). This message ID\nmust be referenced when responding (accepting/rejecting/modifying) to an\nintercept message.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "RPCMiddlewareResponse",
          "longName": "RPCMiddlewareResponse",
          "fullName": "lnrpc.RPCMiddlewareResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "ref_msg_id",
              "description": "The request message ID this response refers to. Must always be set when\ngiving feedback to an intercept but is ignored for the initial registration\nmessage.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "register",
              "description": "The registration message identifies the middleware that's being\nregistered in lnd. The registration message must be sent immediately\nafter initiating the RegisterRpcMiddleware stream, otherwise lnd will\ntime out the attempt and terminate the request. NOTE: The middleware\nwill only receive interception messages for requests that contain a\nmacaroon with the custom caveat that the middleware declares it is\nresponsible for handling in the registration message! As a security\nmeasure, _no_ middleware can intercept requests made with _unencumbered_\nmacaroons!",
              "label": "",
              "type": "MiddlewareRegistration",
              "longType": "MiddlewareRegistration",
              "fullType": "lnrpc.MiddlewareRegistration",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "middleware_message",
              "defaultValue": ""
            },
            {
              "name": "feedback",
              "description": "The middleware received an interception request and gives feedback to\nit. The request_id indicates what message the feedback refers to.",
              "label": "",
              "type": "InterceptFeedback",
              "longType": "InterceptFeedback",
              "fullType": "lnrpc.InterceptFeedback",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "middleware_message",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ReadyForPsbtFunding",
          "longName": "ReadyForPsbtFunding",
          "fullName": "lnrpc.ReadyForPsbtFunding",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "funding_address",
              "description": "The P2WSH address of the channel funding multisig address that the below\nspecified amount in satoshis needs to be sent to.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "funding_amount",
              "description": "The exact amount in satoshis that needs to be sent to the above address to\nfund the pending channel.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "psbt",
              "description": "A raw PSBT that contains the pending channel output. If a base PSBT was\nprovided in the PsbtShim, this is the base PSBT with one additional output.\nIf no base PSBT was specified, this is an otherwise empty PSBT with exactly\none output.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Resolution",
          "longName": "Resolution",
          "fullName": "lnrpc.Resolution",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "resolution_type",
              "description": "The type of output we are resolving.",
              "label": "",
              "type": "ResolutionType",
              "longType": "ResolutionType",
              "fullType": "lnrpc.ResolutionType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outcome",
              "description": "The outcome of our on chain action that resolved the outpoint.",
              "label": "",
              "type": "ResolutionOutcome",
              "longType": "ResolutionOutcome",
              "fullType": "lnrpc.ResolutionOutcome",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outpoint",
              "description": "The outpoint that was spent by the resolution.",
              "label": "",
              "type": "OutPoint",
              "longType": "OutPoint",
              "fullType": "lnrpc.OutPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amount_sat",
              "description": "The amount that was claimed by the resolution.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sweep_txid",
              "description": "The hex-encoded transaction ID of the sweep transaction that spent the\noutput.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "RestoreBackupResponse",
          "longName": "RestoreBackupResponse",
          "fullName": "lnrpc.RestoreBackupResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "RestoreChanBackupRequest",
          "longName": "RestoreChanBackupRequest",
          "fullName": "lnrpc.RestoreChanBackupRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": true,
          "extensions": [],
          "fields": [
            {
              "name": "chan_backups",
              "description": "The channels to restore as a list of channel/backup pairs.",
              "label": "",
              "type": "ChannelBackups",
              "longType": "ChannelBackups",
              "fullType": "lnrpc.ChannelBackups",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "backup",
              "defaultValue": ""
            },
            {
              "name": "multi_chan_backup",
              "description": "The channels to restore in the packed multi backup format. When using\nREST, this field must be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": true,
              "oneofdecl": "backup",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Route",
          "longName": "Route",
          "fullName": "lnrpc.Route",
          "description": "A path through the channel graph which runs over one or more channels in\nsuccession. This struct carries all the information required to craft the\nSphinx onion packet, and send the payment along the first hop in the path. A\nroute is only selected as valid if all the channels have sufficient capacity to\ncarry the initial payment amount after fees are accounted for.",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "total_time_lock",
              "description": "The cumulative (final) time lock across the entire route. This is the CLTV\nvalue that should be extended to the first hop in the route. All other hops\nwill decrement the time-lock as advertised, leaving enough time for all\nhops to wait for or present the payment preimage to complete the payment.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "total_fees",
              "description": "The sum of the fees paid at each hop within the final route. In the case\nof a one-hop payment, this value will be zero as we don't need to pay a fee\nto ourselves.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "total_amt",
              "description": "The total amount of funds required to complete a payment over this route.\nThis value includes the cumulative fees at each hop. As a result, the HTLC\nextended to the first-hop in the route will need to have at least this many\nsatoshis, otherwise the route will fail at an intermediate node due to an\ninsufficient amount of fees.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "hops",
              "description": "Contains details concerning the specific forwarding details at each hop.",
              "label": "repeated",
              "type": "Hop",
              "longType": "Hop",
              "fullType": "lnrpc.Hop",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "total_fees_msat",
              "description": "The total fees in millisatoshis.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "total_amt_msat",
              "description": "The total amount in millisatoshis.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "RouteHint",
          "longName": "RouteHint",
          "fullName": "lnrpc.RouteHint",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "hop_hints",
              "description": "A list of hop hints that when chained together can assist in reaching a\nspecific destination.",
              "label": "repeated",
              "type": "HopHint",
              "longType": "HopHint",
              "fullType": "lnrpc.HopHint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "RoutingPolicy",
          "longName": "RoutingPolicy",
          "fullName": "lnrpc.RoutingPolicy",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "time_lock_delta",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_htlc",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_base_msat",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_rate_milli_msat",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "disabled",
              "description": "",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_htlc_msat",
              "description": "",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "last_update",
              "description": "",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendCoinsRequest",
          "longName": "SendCoinsRequest",
          "fullName": "lnrpc.SendCoinsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "addr",
              "description": "The address to send coins to",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amount",
              "description": "The amount in satoshis to send",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "target_conf",
              "description": "The target number of blocks that this transaction should be confirmed\nby.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_per_vbyte",
              "description": "A manual fee rate set in sat/vbyte that should be used when crafting the\ntransaction.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_per_byte",
              "description": "Deprecated, use sat_per_vbyte.\nA manual fee rate set in sat/vbyte that should be used when crafting the\ntransaction.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "send_all",
              "description": "If set, then the amount field will be ignored, and lnd will attempt to\nsend all the coins under control of the internal wallet to the specified\naddress.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "label",
              "description": "An optional label for the transaction, limited to 500 characters.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_confs",
              "description": "The minimum number of confirmations each one of your outputs used for\nthe transaction must satisfy.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "spend_unconfirmed",
              "description": "Whether unconfirmed outputs should be used as inputs for the transaction.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendCoinsResponse",
          "longName": "SendCoinsResponse",
          "fullName": "lnrpc.SendCoinsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "txid",
              "description": "The transaction ID of the transaction",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendCustomMessageRequest",
          "longName": "SendCustomMessageRequest",
          "fullName": "lnrpc.SendCustomMessageRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "peer",
              "description": "Peer to send the message to",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "type",
              "description": "Message type. This value needs to be in the custom range (\u003e= 32768).",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "data",
              "description": "Raw message data.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendCustomMessageResponse",
          "longName": "SendCustomMessageResponse",
          "fullName": "lnrpc.SendCustomMessageResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "SendManyRequest",
          "longName": "SendManyRequest",
          "fullName": "lnrpc.SendManyRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "AddrToAmount",
              "description": "The map from addresses to amounts",
              "label": "repeated",
              "type": "AddrToAmountEntry",
              "longType": "SendManyRequest.AddrToAmountEntry",
              "fullType": "lnrpc.SendManyRequest.AddrToAmountEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "target_conf",
              "description": "The target number of blocks that this transaction should be confirmed\nby.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_per_vbyte",
              "description": "A manual fee rate set in sat/vbyte that should be used when crafting the\ntransaction.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sat_per_byte",
              "description": "Deprecated, use sat_per_vbyte.\nA manual fee rate set in sat/vbyte that should be used when crafting the\ntransaction.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "label",
              "description": "An optional label for the transaction, limited to 500 characters.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "min_confs",
              "description": "The minimum number of confirmations each one of your outputs used for\nthe transaction must satisfy.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "spend_unconfirmed",
              "description": "Whether unconfirmed outputs should be used as inputs for the transaction.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AddrToAmountEntry",
          "longName": "SendManyRequest.AddrToAmountEntry",
          "fullName": "lnrpc.SendManyRequest.AddrToAmountEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendManyResponse",
          "longName": "SendManyResponse",
          "fullName": "lnrpc.SendManyResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "txid",
              "description": "The id of the transaction",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendRequest",
          "longName": "SendRequest",
          "fullName": "lnrpc.SendRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "dest",
              "description": "The identity pubkey of the payment recipient. When using REST, this field\nmust be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dest_string",
              "description": "The hex-encoded identity pubkey of the payment recipient. Deprecated now\nthat the REST gateway supports base64 encoding of bytes fields.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "amt",
              "description": "The amount to send expressed in satoshis.\n\nThe fields amt and amt_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amt_msat",
              "description": "The amount to send expressed in millisatoshis.\n\nThe fields amt and amt_msat are mutually exclusive.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_hash",
              "description": "The hash to use within the payment's HTLC. When using REST, this field\nmust be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_hash_string",
              "description": "The hex-encoded hash to use within the payment's HTLC. Deprecated now\nthat the REST gateway supports base64 encoding of bytes fields.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "payment_request",
              "description": "A bare-bones invoice for a payment within the Lightning Network. With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "final_cltv_delta",
              "description": "The CLTV delta from the current height that should be used to set the\ntimelock for the final hop.",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "fee_limit",
              "description": "The maximum number of satoshis that will be paid as a fee of the payment.\nThis value can be represented either as a percentage of the amount being\nsent, or as a fixed amount of the maximum fee the user is willing the pay to\nsend the payment. If not specified, lnd will use a default value of 100%\nfees for small amounts (\u003c=1k sat) or 5% fees for larger amounts.",
              "label": "",
              "type": "FeeLimit",
              "longType": "FeeLimit",
              "fullType": "lnrpc.FeeLimit",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outgoing_chan_id",
              "description": "The channel id of the channel that must be taken to the first hop. If zero,\nany channel may be used.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "last_hop_pubkey",
              "description": "The pubkey of the last hop of the route. If empty, any hop may be used.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "cltv_limit",
              "description": "An optional maximum total time lock for the route. This should not exceed\nlnd's `--max-cltv-expiry` setting. If zero, then the value of\n`--max-cltv-expiry` is enforced.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dest_custom_records",
              "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto a peer which understands the new records. This can be used to pass\napplication specific data during the payment attempt. Record types are\nrequired to be in the custom range \u003e= 65536. When using REST, the values\nmust be encoded as base64.",
              "label": "repeated",
              "type": "DestCustomRecordsEntry",
              "longType": "SendRequest.DestCustomRecordsEntry",
              "fullType": "lnrpc.SendRequest.DestCustomRecordsEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "allow_self_payment",
              "description": "If set, circular payments to self are permitted.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dest_features",
              "description": "Features assumed to be supported by the final node. All transitive feature\ndependencies must also be set properly. For a given feature bit pair, either\noptional or remote may be set, but not both. If this field is nil or empty,\nthe router will try to load destination features from the graph as a\nfallback.",
              "label": "repeated",
              "type": "FeatureBit",
              "longType": "FeatureBit",
              "fullType": "lnrpc.FeatureBit",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_addr",
              "description": "The payment address of the generated invoice.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "DestCustomRecordsEntry",
          "longName": "SendRequest.DestCustomRecordsEntry",
          "fullName": "lnrpc.SendRequest.DestCustomRecordsEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendResponse",
          "longName": "SendResponse",
          "fullName": "lnrpc.SendResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "payment_error",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_preimage",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_route",
              "description": "",
              "label": "",
              "type": "Route",
              "longType": "Route",
              "fullType": "lnrpc.Route",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_hash",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SendToRouteRequest",
          "longName": "SendToRouteRequest",
          "fullName": "lnrpc.SendToRouteRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "payment_hash",
              "description": "The payment hash to use for the HTLC. When using REST, this field must be\nencoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "payment_hash_string",
              "description": "An optional hex-encoded payment hash to be used for the HTLC. Deprecated now\nthat the REST gateway supports base64 encoding of bytes fields.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "route",
              "description": "Route that should be used to attempt to complete the payment.",
              "label": "",
              "type": "Route",
              "longType": "Route",
              "fullType": "lnrpc.Route",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SetID",
          "longName": "SetID",
          "fullName": "lnrpc.SetID",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "set_id",
              "description": "",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SignMessageRequest",
          "longName": "SignMessageRequest",
          "fullName": "lnrpc.SignMessageRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "msg",
              "description": "The message to be signed. When using REST, this field must be encoded as\nbase64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "single_hash",
              "description": "Instead of the default double-SHA256 hashing of the message before signing,\nonly use one round of hashing instead.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SignMessageResponse",
          "longName": "SignMessageResponse",
          "fullName": "lnrpc.SignMessageResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "signature",
              "description": "The signature for the given message",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "StopRequest",
          "longName": "StopRequest",
          "fullName": "lnrpc.StopRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "StopResponse",
          "longName": "StopResponse",
          "fullName": "lnrpc.StopResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "StreamAuth",
          "longName": "StreamAuth",
          "fullName": "lnrpc.StreamAuth",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "method_full_uri",
              "description": "The full URI (in the format /\u003crpcpackage\u003e.\u003cServiceName\u003e/MethodName, for\nexample /lnrpc.Lightning/GetInfo) of the streaming RPC method that was just\nestablished.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SubscribeCustomMessagesRequest",
          "longName": "SubscribeCustomMessagesRequest",
          "fullName": "lnrpc.SubscribeCustomMessagesRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "TimestampedError",
          "longName": "TimestampedError",
          "fullName": "lnrpc.TimestampedError",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "timestamp",
              "description": "The unix timestamp in seconds when the error occurred.",
              "label": "",
              "type": "uint64",
              "longType": "uint64",
              "fullType": "uint64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "error",
              "description": "The string representation of the error sent by our peer.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Transaction",
          "longName": "Transaction",
          "fullName": "lnrpc.Transaction",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "tx_hash",
              "description": "The transaction hash",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amount",
              "description": "The transaction amount, denominated in satoshis",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_confirmations",
              "description": "The number of confirmations",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "block_hash",
              "description": "The hash of the block this transaction was included in",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "block_height",
              "description": "The height of the block this transaction was included in",
              "label": "",
              "type": "int32",
              "longType": "int32",
              "fullType": "int32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "time_stamp",
              "description": "Timestamp of this transaction",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "total_fees",
              "description": "Fees paid for this transaction",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "dest_addresses",
              "description": "Addresses that received funds for this transaction. Deprecated as it is\nnow incorporated in the output_details field.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "output_details",
              "description": "Outputs that received funds for this transaction",
              "label": "repeated",
              "type": "OutputDetail",
              "longType": "OutputDetail",
              "fullType": "lnrpc.OutputDetail",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "raw_tx_hex",
              "description": "The raw transaction hex.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "label",
              "description": "A label that was optionally set on transaction broadcast.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "previous_outpoints",
              "description": "PreviousOutpoints/Inputs of this transaction.",
              "label": "repeated",
              "type": "PreviousOutPoint",
              "longType": "PreviousOutPoint",
              "fullType": "lnrpc.PreviousOutPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "TransactionDetails",
          "longName": "TransactionDetails",
          "fullName": "lnrpc.TransactionDetails",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "transactions",
              "description": "The list of transactions relevant to the wallet.",
              "label": "repeated",
              "type": "Transaction",
              "longType": "Transaction",
              "fullType": "lnrpc.Transaction",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Utxo",
          "longName": "Utxo",
          "fullName": "lnrpc.Utxo",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "address_type",
              "description": "The type of address",
              "label": "",
              "type": "AddressType",
              "longType": "AddressType",
              "fullType": "lnrpc.AddressType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "address",
              "description": "The address",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "amount_sat",
              "description": "The value of the unspent coin in satoshis",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pk_script",
              "description": "The pkscript in hex",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "outpoint",
              "description": "The outpoint in format txid:n",
              "label": "",
              "type": "OutPoint",
              "longType": "OutPoint",
              "fullType": "lnrpc.OutPoint",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "confirmations",
              "description": "The number of confirmations for the Utxo",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "VerifyChanBackupResponse",
          "longName": "VerifyChanBackupResponse",
          "fullName": "lnrpc.VerifyChanBackupResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "VerifyMessageRequest",
          "longName": "VerifyMessageRequest",
          "fullName": "lnrpc.VerifyMessageRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "msg",
              "description": "The message over which the signature is to be verified. When using REST,\nthis field must be encoded as base64.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "signature",
              "description": "The signature to be verified over the given message",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "VerifyMessageResponse",
          "longName": "VerifyMessageResponse",
          "fullName": "lnrpc.VerifyMessageResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "valid",
              "description": "Whether the signature was valid over the given message",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "pubkey",
              "description": "The pubkey recovered from the signature",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "WalletAccountBalance",
          "longName": "WalletAccountBalance",
          "fullName": "lnrpc.WalletAccountBalance",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "confirmed_balance",
              "description": "The confirmed balance of the account (with \u003e= 1 confirmations).",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "unconfirmed_balance",
              "description": "The unconfirmed balance of the account (with 0 confirmations).",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "WalletBalanceRequest",
          "longName": "WalletBalanceRequest",
          "fullName": "lnrpc.WalletBalanceRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "WalletBalanceResponse",
          "longName": "WalletBalanceResponse",
          "fullName": "lnrpc.WalletBalanceResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "total_balance",
              "description": "The balance of the wallet",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "confirmed_balance",
              "description": "The confirmed balance of a wallet(with \u003e= 1 confirmations)",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "unconfirmed_balance",
              "description": "The unconfirmed balance of a wallet(with 0 confirmations)",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "locked_balance",
              "description": "The total amount of wallet UTXOs held in outputs that are locked for\nother usage.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "reserved_balance_anchor_chan",
              "description": "The amount of reserve required.",
              "label": "",
              "type": "int64",
              "longType": "int64",
              "fullType": "int64",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "account_balance",
              "description": "A mapping of each wallet account's name to its balance.",
              "label": "repeated",
              "type": "AccountBalanceEntry",
              "longType": "WalletBalanceResponse.AccountBalanceEntry",
              "fullType": "lnrpc.WalletBalanceResponse.AccountBalanceEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AccountBalanceEntry",
          "longName": "WalletBalanceResponse.AccountBalanceEntry",
          "fullName": "lnrpc.WalletBalanceResponse.AccountBalanceEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "WalletAccountBalance",
              "longType": "WalletAccountBalance",
              "fullType": "lnrpc.WalletAccountBalance",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": [
        {
          "name": "Lightning",
          "longName": "Lightning",
          "fullName": "lnrpc.Lightning",
          "description": "Lightning is the main RPC server of the daemon.",
          "methods": [
            {
              "name": "WalletBalance",
              "description": "lncli: `walletbalance`\nWalletBalance returns total unspent outputs(confirmed and unconfirmed), all\nconfirmed unspent outputs and all unconfirmed unspent outputs under control\nof the wallet.",
              "requestType": "WalletBalanceRequest",
              "requestLongType": "WalletBalanceRequest",
              "requestFullType": "lnrpc.WalletBalanceRequest",
              "requestStreaming": false,
              "responseType": "WalletBalanceResponse",
              "responseLongType": "WalletBalanceResponse",
              "responseFullType": "lnrpc.WalletBalanceResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/balance/blockchain",
                  "details": {
                    "operationId": "Lightning_WalletBalance",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcWalletBalanceResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `walletbalance`\nWalletBalance returns total unspent outputs(confirmed and unconfirmed), all\nconfirmed unspent outputs and all unconfirmed unspent outputs under control\nof the wallet.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ChannelBalance",
              "description": "lncli: `channelbalance`\nChannelBalance returns a report on the total funds across all open channels,\ncategorized in local/remote, pending local/remote and unsettled local/remote\nbalances.",
              "requestType": "ChannelBalanceRequest",
              "requestLongType": "ChannelBalanceRequest",
              "requestFullType": "lnrpc.ChannelBalanceRequest",
              "requestStreaming": false,
              "responseType": "ChannelBalanceResponse",
              "responseLongType": "ChannelBalanceResponse",
              "responseFullType": "lnrpc.ChannelBalanceResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/balance/channels",
                  "details": {
                    "operationId": "Lightning_ChannelBalance",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcChannelBalanceResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `channelbalance`\nChannelBalance returns a report on the total funds across all open channels,\ncategorized in local/remote, pending local/remote and unsettled local/remote\nbalances.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetTransactions",
              "description": "lncli: `listchaintxns`\nGetTransactions returns a list describing all the known transactions\nrelevant to the wallet.",
              "requestType": "GetTransactionsRequest",
              "requestLongType": "GetTransactionsRequest",
              "requestFullType": "lnrpc.GetTransactionsRequest",
              "requestStreaming": false,
              "responseType": "TransactionDetails",
              "responseLongType": "TransactionDetails",
              "responseFullType": "lnrpc.TransactionDetails",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/transactions",
                  "details": {
                    "operationId": "Lightning_GetTransactions",
                    "parameters": [
                      {
                        "description": "The height from which to list transactions, inclusive. If this value is\ngreater than end_height, transactions will be read in reverse.",
                        "format": "int32",
                        "in": "query",
                        "name": "start_height",
                        "required": false,
                        "type": "integer"
                      },
                      {
                        "description": "The height until which to list transactions, inclusive. To include\nunconfirmed transactions, this value should be set to -1, which will\nreturn transactions from start_height until the current chain tip and\nunconfirmed transactions. If no end_height is provided, the call will\ndefault to this option.",
                        "format": "int32",
                        "in": "query",
                        "name": "end_height",
                        "required": false,
                        "type": "integer"
                      },
                      {
                        "description": "An optional filter to only include transactions relevant to an account.",
                        "in": "query",
                        "name": "account",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcTransactionDetails"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `listchaintxns`\nGetTransactions returns a list describing all the known transactions\nrelevant to the wallet.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "EstimateFee",
              "description": "lncli: `estimatefee`\nEstimateFee asks the chain backend to estimate the fee rate and total fees\nfor a transaction that pays to multiple specified outputs.\n\nWhen using REST, the `AddrToAmount` map type can be set by appending\n`\u0026AddrToAmount[\u003caddress\u003e]=\u003camount_to_send\u003e` to the URL. Unfortunately this\nmap type doesn't appear in the REST API documentation because of a bug in\nthe grpc-gateway library.",
              "requestType": "EstimateFeeRequest",
              "requestLongType": "EstimateFeeRequest",
              "requestFullType": "lnrpc.EstimateFeeRequest",
              "requestStreaming": false,
              "responseType": "EstimateFeeResponse",
              "responseLongType": "EstimateFeeResponse",
              "responseFullType": "lnrpc.EstimateFeeResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/transactions/fee",
                  "details": {
                    "description": "When using REST, the `AddrToAmount` map type can be set by appending\n`\u0026AddrToAmount[\u003caddress\u003e]=\u003camount_to_send\u003e` to the URL. Unfortunately this\nmap type doesn't appear in the REST API documentation because of a bug in\nthe grpc-gateway library.",
                    "operationId": "Lightning_EstimateFee",
                    "parameters": [
                      {
                        "description": "The target number of blocks that this transaction should be confirmed\nby.",
                        "format": "int32",
                        "in": "query",
                        "name": "target_conf",
                        "required": false,
                        "type": "integer"
                      },
                      {
                        "description": "The minimum number of confirmations each one of your outputs used for\nthe transaction must satisfy.",
                        "format": "int32",
                        "in": "query",
                        "name": "min_confs",
                        "required": false,
                        "type": "integer"
                      },
                      {
                        "description": "Whether unconfirmed outputs should be used as inputs for the transaction.",
                        "in": "query",
                        "name": "spend_unconfirmed",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcEstimateFeeResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `estimatefee`\nEstimateFee asks the chain backend to estimate the fee rate and total fees\nfor a transaction that pays to multiple specified outputs.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SendCoins",
              "description": "lncli: `sendcoins`\nSendCoins executes a request to send coins to a particular address. Unlike\nSendMany, this RPC call only allows creating a single output at a time. If\nneither target_conf, or sat_per_vbyte are set, then the internal wallet will\nconsult its fee model to determine a fee for the default confirmation\ntarget.",
              "requestType": "SendCoinsRequest",
              "requestLongType": "SendCoinsRequest",
              "requestFullType": "lnrpc.SendCoinsRequest",
              "requestStreaming": false,
              "responseType": "SendCoinsResponse",
              "responseLongType": "SendCoinsResponse",
              "responseFullType": "lnrpc.SendCoinsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/transactions",
                  "details": {
                    "operationId": "Lightning_SendCoins",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcSendCoinsRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcSendCoinsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `sendcoins`\nSendCoins executes a request to send coins to a particular address. Unlike\nSendMany, this RPC call only allows creating a single output at a time. If\nneither target_conf, or sat_per_vbyte are set, then the internal wallet will\nconsult its fee model to determine a fee for the default confirmation\ntarget.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ListUnspent",
              "description": "lncli: `listunspent`\nDeprecated, use walletrpc.ListUnspent instead.\n\nListUnspent returns a list of all utxos spendable by the wallet with a\nnumber of confirmations between the specified minimum and maximum.",
              "requestType": "ListUnspentRequest",
              "requestLongType": "ListUnspentRequest",
              "requestFullType": "lnrpc.ListUnspentRequest",
              "requestStreaming": false,
              "responseType": "ListUnspentResponse",
              "responseLongType": "ListUnspentResponse",
              "responseFullType": "lnrpc.ListUnspentResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/utxos",
                  "details": {
                    "description": "ListUnspent returns a list of all utxos spendable by the wallet with a\nnumber of confirmations between the specified minimum and maximum.",
                    "operationId": "Lightning_ListUnspent",
                    "parameters": [
                      {
                        "description": "The minimum number of confirmations to be included.",
                        "format": "int32",
                        "in": "query",
                        "name": "min_confs",
                        "required": false,
                        "type": "integer"
                      },
                      {
                        "description": "The maximum number of confirmations to be included.",
                        "format": "int32",
                        "in": "query",
                        "name": "max_confs",
                        "required": false,
                        "type": "integer"
                      },
                      {
                        "description": "An optional filter to only include outputs belonging to an account.",
                        "in": "query",
                        "name": "account",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcListUnspentResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `listunspent`\nDeprecated, use walletrpc.ListUnspent instead.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SubscribeTransactions",
              "description": "SubscribeTransactions creates a uni-directional stream from the server to\nthe client in which any newly discovered transactions relevant to the\nwallet are sent over.",
              "requestType": "GetTransactionsRequest",
              "requestLongType": "GetTransactionsRequest",
              "requestFullType": "lnrpc.GetTransactionsRequest",
              "requestStreaming": false,
              "responseType": "Transaction",
              "responseLongType": "Transaction",
              "responseFullType": "lnrpc.Transaction",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/transactions/subscribe",
                  "details": {
                    "operationId": "Lightning_SubscribeTransactions",
                    "parameters": [
                      {
                        "description": "The height from which to list transactions, inclusive. If this value is\ngreater than end_height, transactions will be read in reverse.",
                        "format": "int32",
                        "in": "query",
                        "name": "start_height",
                        "required": false,
                        "type": "integer"
                      },
                      {
                        "description": "The height until which to list transactions, inclusive. To include\nunconfirmed transactions, this value should be set to -1, which will\nreturn transactions from start_height until the current chain tip and\nunconfirmed transactions. If no end_height is provided, the call will\ndefault to this option.",
                        "format": "int32",
                        "in": "query",
                        "name": "end_height",
                        "required": false,
                        "type": "integer"
                      },
                      {
                        "description": "An optional filter to only include transactions relevant to an account.",
                        "in": "query",
                        "name": "account",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcTransaction"
                            }
                          },
                          "title": "Stream result of lnrpcTransaction",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SubscribeTransactions creates a uni-directional stream from the server to\nthe client in which any newly discovered transactions relevant to the\nwallet are sent over.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SendMany",
              "description": "lncli: `sendmany`\nSendMany handles a request for a transaction that creates multiple specified\noutputs in parallel. If neither target_conf, or sat_per_vbyte are set, then\nthe internal wallet will consult its fee model to determine a fee for the\ndefault confirmation target.",
              "requestType": "SendManyRequest",
              "requestLongType": "SendManyRequest",
              "requestFullType": "lnrpc.SendManyRequest",
              "requestStreaming": false,
              "responseType": "SendManyResponse",
              "responseLongType": "SendManyResponse",
              "responseFullType": "lnrpc.SendManyResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/transactions/many",
                  "details": {
                    "operationId": "Lightning_SendMany",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcSendManyRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcSendManyResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `sendmany`\nSendMany handles a request for a transaction that creates multiple specified\noutputs in parallel. If neither target_conf, or sat_per_vbyte are set, then\nthe internal wallet will consult its fee model to determine a fee for the\ndefault confirmation target.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "NewAddress",
              "description": "lncli: `newaddress`\nNewAddress creates a new address under control of the local wallet.",
              "requestType": "NewAddressRequest",
              "requestLongType": "NewAddressRequest",
              "requestFullType": "lnrpc.NewAddressRequest",
              "requestStreaming": false,
              "responseType": "NewAddressResponse",
              "responseLongType": "NewAddressResponse",
              "responseFullType": "lnrpc.NewAddressResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/newaddress",
                  "details": {
                    "operationId": "Lightning_NewAddress",
                    "parameters": [
                      {
                        "default": "WITNESS_PUBKEY_HASH",
                        "description": "The type of address to generate.",
                        "enum": [
                          "WITNESS_PUBKEY_HASH",
                          "NESTED_PUBKEY_HASH",
                          "UNUSED_WITNESS_PUBKEY_HASH",
                          "UNUSED_NESTED_PUBKEY_HASH",
                          "TAPROOT_PUBKEY",
                          "UNUSED_TAPROOT_PUBKEY"
                        ],
                        "in": "query",
                        "name": "type",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "The name of the account to generate a new address for. If empty, the\ndefault wallet account is used.",
                        "in": "query",
                        "name": "account",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcNewAddressResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `newaddress`\nNewAddress creates a new address under control of the local wallet.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SignMessage",
              "description": "lncli: `signmessage`\nSignMessage signs a message with this node's private key. The returned\nsignature string is `zbase32` encoded and pubkey recoverable, meaning that\nonly the message digest and signature are needed for verification.",
              "requestType": "SignMessageRequest",
              "requestLongType": "SignMessageRequest",
              "requestFullType": "lnrpc.SignMessageRequest",
              "requestStreaming": false,
              "responseType": "SignMessageResponse",
              "responseLongType": "SignMessageResponse",
              "responseFullType": "lnrpc.SignMessageResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/signmessage",
                  "details": {
                    "operationId": "Lightning_SignMessage",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcSignMessageRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcSignMessageResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `signmessage`\nSignMessage signs a message with this node's private key. The returned\nsignature string is `zbase32` encoded and pubkey recoverable, meaning that\nonly the message digest and signature are needed for verification.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "VerifyMessage",
              "description": "lncli: `verifymessage`\nVerifyMessage verifies a signature over a msg. The signature must be\nzbase32 encoded and signed by an active node in the resident node's\nchannel database. In addition to returning the validity of the signature,\nVerifyMessage also returns the recovered pubkey from the signature.",
              "requestType": "VerifyMessageRequest",
              "requestLongType": "VerifyMessageRequest",
              "requestFullType": "lnrpc.VerifyMessageRequest",
              "requestStreaming": false,
              "responseType": "VerifyMessageResponse",
              "responseLongType": "VerifyMessageResponse",
              "responseFullType": "lnrpc.VerifyMessageResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/verifymessage",
                  "details": {
                    "operationId": "Lightning_VerifyMessage",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcVerifyMessageRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcVerifyMessageResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `verifymessage`\nVerifyMessage verifies a signature over a msg. The signature must be\nzbase32 encoded and signed by an active node in the resident node's\nchannel database. In addition to returning the validity of the signature,\nVerifyMessage also returns the recovered pubkey from the signature.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ConnectPeer",
              "description": "lncli: `connect`\nConnectPeer attempts to establish a connection to a remote peer. This is at\nthe networking level, and is used for communication between nodes. This is\ndistinct from establishing a channel with a peer.",
              "requestType": "ConnectPeerRequest",
              "requestLongType": "ConnectPeerRequest",
              "requestFullType": "lnrpc.ConnectPeerRequest",
              "requestStreaming": false,
              "responseType": "ConnectPeerResponse",
              "responseLongType": "ConnectPeerResponse",
              "responseFullType": "lnrpc.ConnectPeerResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/peers",
                  "details": {
                    "operationId": "Lightning_ConnectPeer",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcConnectPeerRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcConnectPeerResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `connect`\nConnectPeer attempts to establish a connection to a remote peer. This is at\nthe networking level, and is used for communication between nodes. This is\ndistinct from establishing a channel with a peer.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "DisconnectPeer",
              "description": "lncli: `disconnect`\nDisconnectPeer attempts to disconnect one peer from another identified by a\ngiven pubKey. In the case that we currently have a pending or active channel\nwith the target peer, then this action will be not be allowed.",
              "requestType": "DisconnectPeerRequest",
              "requestLongType": "DisconnectPeerRequest",
              "requestFullType": "lnrpc.DisconnectPeerRequest",
              "requestStreaming": false,
              "responseType": "DisconnectPeerResponse",
              "responseLongType": "DisconnectPeerResponse",
              "responseFullType": "lnrpc.DisconnectPeerResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "DELETE",
                  "path": "/v1/peers/{pub_key}",
                  "details": {
                    "operationId": "Lightning_DisconnectPeer",
                    "parameters": [
                      {
                        "description": "The pubkey of the node to disconnect from",
                        "in": "path",
                        "name": "pub_key",
                        "required": true,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcDisconnectPeerResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `disconnect`\nDisconnectPeer attempts to disconnect one peer from another identified by a\ngiven pubKey. In the case that we currently have a pending or active channel\nwith the target peer, then this action will be not be allowed.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ListPeers",
              "description": "lncli: `listpeers`\nListPeers returns a verbose listing of all currently active peers.",
              "requestType": "ListPeersRequest",
              "requestLongType": "ListPeersRequest",
              "requestFullType": "lnrpc.ListPeersRequest",
              "requestStreaming": false,
              "responseType": "ListPeersResponse",
              "responseLongType": "ListPeersResponse",
              "responseFullType": "lnrpc.ListPeersResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/peers",
                  "details": {
                    "operationId": "Lightning_ListPeers",
                    "parameters": [
                      {
                        "description": "If true, only the last error that our peer sent us will be returned with\nthe peer's information, rather than the full set of historic errors we have\nstored.",
                        "in": "query",
                        "name": "latest_error",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcListPeersResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `listpeers`\nListPeers returns a verbose listing of all currently active peers.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SubscribePeerEvents",
              "description": "SubscribePeerEvents creates a uni-directional stream from the server to\nthe client in which any events relevant to the state of peers are sent\nover. Events include peers going online and offline.",
              "requestType": "PeerEventSubscription",
              "requestLongType": "PeerEventSubscription",
              "requestFullType": "lnrpc.PeerEventSubscription",
              "requestStreaming": false,
              "responseType": "PeerEvent",
              "responseLongType": "PeerEvent",
              "responseFullType": "lnrpc.PeerEvent",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/peers/subscribe",
                  "details": {
                    "operationId": "Lightning_SubscribePeerEvents",
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcPeerEvent"
                            }
                          },
                          "title": "Stream result of lnrpcPeerEvent",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SubscribePeerEvents creates a uni-directional stream from the server to\nthe client in which any events relevant to the state of peers are sent\nover. Events include peers going online and offline.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetInfo",
              "description": "lncli: `getinfo`\nGetInfo returns general information concerning the lightning node including\nit's identity pubkey, alias, the chains it is connected to, and information\nconcerning the number of open+pending channels.",
              "requestType": "GetInfoRequest",
              "requestLongType": "GetInfoRequest",
              "requestFullType": "lnrpc.GetInfoRequest",
              "requestStreaming": false,
              "responseType": "GetInfoResponse",
              "responseLongType": "GetInfoResponse",
              "responseFullType": "lnrpc.GetInfoResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/getinfo",
                  "details": {
                    "operationId": "Lightning_GetInfo",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcGetInfoResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `getinfo`\nGetInfo returns general information concerning the lightning node including\nit's identity pubkey, alias, the chains it is connected to, and information\nconcerning the number of open+pending channels.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetRecoveryInfo",
              "description": "lncli: `getrecoveryinfo`\nGetRecoveryInfo returns information concerning the recovery mode including\nwhether it's in a recovery mode, whether the recovery is finished, and the\nprogress made so far.",
              "requestType": "GetRecoveryInfoRequest",
              "requestLongType": "GetRecoveryInfoRequest",
              "requestFullType": "lnrpc.GetRecoveryInfoRequest",
              "requestStreaming": false,
              "responseType": "GetRecoveryInfoResponse",
              "responseLongType": "GetRecoveryInfoResponse",
              "responseFullType": "lnrpc.GetRecoveryInfoResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/getrecoveryinfo",
                  "details": {
                    "operationId": "Lightning_GetRecoveryInfo",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcGetRecoveryInfoResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "* lncli: `getrecoveryinfo`\nGetRecoveryInfo returns information concerning the recovery mode including\nwhether it's in a recovery mode, whether the recovery is finished, and the\nprogress made so far.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "PendingChannels",
              "description": "lncli: `pendingchannels`\nPendingChannels returns a list of all the channels that are currently\nconsidered \"pending\". A channel is pending if it has finished the funding\nworkflow and is waiting for confirmations for the funding txn, or is in the\nprocess of closure, either initiated cooperatively or non-cooperatively.",
              "requestType": "PendingChannelsRequest",
              "requestLongType": "PendingChannelsRequest",
              "requestFullType": "lnrpc.PendingChannelsRequest",
              "requestStreaming": false,
              "responseType": "PendingChannelsResponse",
              "responseLongType": "PendingChannelsResponse",
              "responseFullType": "lnrpc.PendingChannelsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/channels/pending",
                  "details": {
                    "operationId": "Lightning_PendingChannels",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcPendingChannelsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `pendingchannels`\nPendingChannels returns a list of all the channels that are currently\nconsidered \"pending\". A channel is pending if it has finished the funding\nworkflow and is waiting for confirmations for the funding txn, or is in the\nprocess of closure, either initiated cooperatively or non-cooperatively.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ListChannels",
              "description": "lncli: `listchannels`\nListChannels returns a description of all the open channels that this node\nis a participant in.",
              "requestType": "ListChannelsRequest",
              "requestLongType": "ListChannelsRequest",
              "requestFullType": "lnrpc.ListChannelsRequest",
              "requestStreaming": false,
              "responseType": "ListChannelsResponse",
              "responseLongType": "ListChannelsResponse",
              "responseFullType": "lnrpc.ListChannelsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/channels",
                  "details": {
                    "operationId": "Lightning_ListChannels",
                    "parameters": [
                      {
                        "in": "query",
                        "name": "active_only",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "in": "query",
                        "name": "inactive_only",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "in": "query",
                        "name": "public_only",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "in": "query",
                        "name": "private_only",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "description": "Filters the response for channels with a target peer's pubkey. If peer is\nempty, all channels will be returned.",
                        "format": "byte",
                        "in": "query",
                        "name": "peer",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcListChannelsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `listchannels`\nListChannels returns a description of all the open channels that this node\nis a participant in.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SubscribeChannelEvents",
              "description": "SubscribeChannelEvents creates a uni-directional stream from the server to\nthe client in which any updates relevant to the state of the channels are\nsent over. Events include new active channels, inactive channels, and closed\nchannels.",
              "requestType": "ChannelEventSubscription",
              "requestLongType": "ChannelEventSubscription",
              "requestFullType": "lnrpc.ChannelEventSubscription",
              "requestStreaming": false,
              "responseType": "ChannelEventUpdate",
              "responseLongType": "ChannelEventUpdate",
              "responseFullType": "lnrpc.ChannelEventUpdate",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/channels/subscribe",
                  "details": {
                    "operationId": "Lightning_SubscribeChannelEvents",
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcChannelEventUpdate"
                            }
                          },
                          "title": "Stream result of lnrpcChannelEventUpdate",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SubscribeChannelEvents creates a uni-directional stream from the server to\nthe client in which any updates relevant to the state of the channels are\nsent over. Events include new active channels, inactive channels, and closed\nchannels.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ClosedChannels",
              "description": "lncli: `closedchannels`\nClosedChannels returns a description of all the closed channels that\nthis node was a participant in.",
              "requestType": "ClosedChannelsRequest",
              "requestLongType": "ClosedChannelsRequest",
              "requestFullType": "lnrpc.ClosedChannelsRequest",
              "requestStreaming": false,
              "responseType": "ClosedChannelsResponse",
              "responseLongType": "ClosedChannelsResponse",
              "responseFullType": "lnrpc.ClosedChannelsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/channels/closed",
                  "details": {
                    "operationId": "Lightning_ClosedChannels",
                    "parameters": [
                      {
                        "in": "query",
                        "name": "cooperative",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "in": "query",
                        "name": "local_force",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "in": "query",
                        "name": "remote_force",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "in": "query",
                        "name": "breach",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "in": "query",
                        "name": "funding_canceled",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "in": "query",
                        "name": "abandoned",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcClosedChannelsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `closedchannels`\nClosedChannels returns a description of all the closed channels that\nthis node was a participant in.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "OpenChannelSync",
              "description": "OpenChannelSync is a synchronous version of the OpenChannel RPC call. This\ncall is meant to be consumed by clients to the REST proxy. As with all\nother sync calls, all byte slices are intended to be populated as hex\nencoded strings.",
              "requestType": "OpenChannelRequest",
              "requestLongType": "OpenChannelRequest",
              "requestFullType": "lnrpc.OpenChannelRequest",
              "requestStreaming": false,
              "responseType": "ChannelPoint",
              "responseLongType": "ChannelPoint",
              "responseFullType": "lnrpc.ChannelPoint",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/channels",
                  "details": {
                    "operationId": "Lightning_OpenChannelSync",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcOpenChannelRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcChannelPoint"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "OpenChannelSync is a synchronous version of the OpenChannel RPC call. This\ncall is meant to be consumed by clients to the REST proxy. As with all\nother sync calls, all byte slices are intended to be populated as hex\nencoded strings.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "OpenChannel",
              "description": "lncli: `openchannel`\nOpenChannel attempts to open a singly funded channel specified in the\nrequest to a remote peer. Users are able to specify a target number of\nblocks that the funding transaction should be confirmed in, or a manual fee\nrate to us for the funding transaction. If neither are specified, then a\nlax block confirmation target is used. Each OpenStatusUpdate will return\nthe pending channel ID of the in-progress channel. Depending on the\narguments specified in the OpenChannelRequest, this pending channel ID can\nthen be used to manually progress the channel funding flow.",
              "requestType": "OpenChannelRequest",
              "requestLongType": "OpenChannelRequest",
              "requestFullType": "lnrpc.OpenChannelRequest",
              "requestStreaming": false,
              "responseType": "OpenStatusUpdate",
              "responseLongType": "OpenStatusUpdate",
              "responseFullType": "lnrpc.OpenStatusUpdate",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/channels/stream",
                  "details": {
                    "operationId": "Lightning_OpenChannel",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcOpenChannelRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcOpenStatusUpdate"
                            }
                          },
                          "title": "Stream result of lnrpcOpenStatusUpdate",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `openchannel`\nOpenChannel attempts to open a singly funded channel specified in the\nrequest to a remote peer. Users are able to specify a target number of\nblocks that the funding transaction should be confirmed in, or a manual fee\nrate to us for the funding transaction. If neither are specified, then a\nlax block confirmation target is used. Each OpenStatusUpdate will return\nthe pending channel ID of the in-progress channel. Depending on the\narguments specified in the OpenChannelRequest, this pending channel ID can\nthen be used to manually progress the channel funding flow.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "BatchOpenChannel",
              "description": "lncli: `batchopenchannel`\nBatchOpenChannel attempts to open multiple single-funded channels in a\nsingle transaction in an atomic way. This means either all channel open\nrequests succeed at once or all attempts are aborted if any of them fail.\nThis is the safer variant of using PSBTs to manually fund a batch of\nchannels through the OpenChannel RPC.",
              "requestType": "BatchOpenChannelRequest",
              "requestLongType": "BatchOpenChannelRequest",
              "requestFullType": "lnrpc.BatchOpenChannelRequest",
              "requestStreaming": false,
              "responseType": "BatchOpenChannelResponse",
              "responseLongType": "BatchOpenChannelResponse",
              "responseFullType": "lnrpc.BatchOpenChannelResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/channels/batch",
                  "details": {
                    "operationId": "Lightning_BatchOpenChannel",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcBatchOpenChannelRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcBatchOpenChannelResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `batchopenchannel`\nBatchOpenChannel attempts to open multiple single-funded channels in a\nsingle transaction in an atomic way. This means either all channel open\nrequests succeed at once or all attempts are aborted if any of them fail.\nThis is the safer variant of using PSBTs to manually fund a batch of\nchannels through the OpenChannel RPC.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "FundingStateStep",
              "description": "FundingStateStep is an advanced funding related call that allows the caller\nto either execute some preparatory steps for a funding workflow, or\nmanually progress a funding workflow. The primary way a funding flow is\nidentified is via its pending channel ID. As an example, this method can be\nused to specify that we're expecting a funding flow for a particular\npending channel ID, for which we need to use specific parameters.\nAlternatively, this can be used to interactively drive PSBT signing for\nfunding for partially complete funding transactions.",
              "requestType": "FundingTransitionMsg",
              "requestLongType": "FundingTransitionMsg",
              "requestFullType": "lnrpc.FundingTransitionMsg",
              "requestStreaming": false,
              "responseType": "FundingStateStepResp",
              "responseLongType": "FundingStateStepResp",
              "responseFullType": "lnrpc.FundingStateStepResp",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/funding/step",
                  "details": {
                    "operationId": "Lightning_FundingStateStep",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcFundingTransitionMsg"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcFundingStateStepResp"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "FundingStateStep is an advanced funding related call that allows the caller\nto either execute some preparatory steps for a funding workflow, or\nmanually progress a funding workflow. The primary way a funding flow is\nidentified is via its pending channel ID. As an example, this method can be\nused to specify that we're expecting a funding flow for a particular\npending channel ID, for which we need to use specific parameters.\nAlternatively, this can be used to interactively drive PSBT signing for\nfunding for partially complete funding transactions.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ChannelAcceptor",
              "description": "ChannelAcceptor dispatches a bi-directional streaming RPC in which\nOpenChannel requests are sent to the client and the client responds with\na boolean that tells LND whether or not to accept the channel. This allows\nnode operators to specify their own criteria for accepting inbound channels\nthrough a single persistent connection.",
              "requestType": "ChannelAcceptResponse",
              "requestLongType": "ChannelAcceptResponse",
              "requestFullType": "lnrpc.ChannelAcceptResponse",
              "requestStreaming": true,
              "responseType": "ChannelAcceptRequest",
              "responseLongType": "ChannelAcceptRequest",
              "responseFullType": "lnrpc.ChannelAcceptRequest",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/channels/acceptor",
                  "details": {
                    "operationId": "Lightning_ChannelAcceptor",
                    "parameters": [
                      {
                        "description": " (streaming inputs)",
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcChannelAcceptResponse"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcChannelAcceptRequest"
                            }
                          },
                          "title": "Stream result of lnrpcChannelAcceptRequest",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ChannelAcceptor dispatches a bi-directional streaming RPC in which\nOpenChannel requests are sent to the client and the client responds with\na boolean that tells LND whether or not to accept the channel. This allows\nnode operators to specify their own criteria for accepting inbound channels\nthrough a single persistent connection.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "CloseChannel",
              "description": "lncli: `closechannel`\nCloseChannel attempts to close an active channel identified by its channel\noutpoint (ChannelPoint). The actions of this method can additionally be\naugmented to attempt a force close after a timeout period in the case of an\ninactive peer. If a non-force close (cooperative closure) is requested,\nthen the user can specify either a target number of blocks until the\nclosure transaction is confirmed, or a manual fee rate. If neither are\nspecified, then a default lax, block confirmation target is used.",
              "requestType": "CloseChannelRequest",
              "requestLongType": "CloseChannelRequest",
              "requestFullType": "lnrpc.CloseChannelRequest",
              "requestStreaming": false,
              "responseType": "CloseStatusUpdate",
              "responseLongType": "CloseStatusUpdate",
              "responseFullType": "lnrpc.CloseStatusUpdate",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "DELETE",
                  "path": "/v1/channels/{channel_point.funding_txid_str}/{channel_point.output_index}",
                  "details": {
                    "operationId": "Lightning_CloseChannel",
                    "parameters": [
                      {
                        "description": "Hex-encoded string representing the byte-reversed hash of the funding\ntransaction.",
                        "in": "path",
                        "name": "channel_point.funding_txid_str",
                        "required": true,
                        "type": "string"
                      },
                      {
                        "description": "The index of the output of the funding transaction",
                        "format": "int64",
                        "in": "path",
                        "name": "channel_point.output_index",
                        "required": true,
                        "type": "integer"
                      },
                      {
                        "description": "Txid of the funding transaction. When using REST, this field must be\nencoded as base64.",
                        "format": "byte",
                        "in": "query",
                        "name": "channel_point.funding_txid_bytes",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "If true, then the channel will be closed forcibly. This means the\ncurrent commitment transaction will be signed and broadcast.",
                        "in": "query",
                        "name": "force",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "description": "The target number of blocks that the closure transaction should be\nconfirmed by.",
                        "format": "int32",
                        "in": "query",
                        "name": "target_conf",
                        "required": false,
                        "type": "integer"
                      },
                      {
                        "description": "Deprecated, use sat_per_vbyte.\nA manual fee rate set in sat/vbyte that should be used when crafting the\nclosure transaction.",
                        "format": "int64",
                        "in": "query",
                        "name": "sat_per_byte",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "An optional address to send funds to in the case of a cooperative close.\nIf the channel was opened with an upfront shutdown script and this field\nis set, the request to close will fail because the channel must pay out\nto the upfront shutdown addresss.",
                        "in": "query",
                        "name": "delivery_address",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "A manual fee rate set in sat/vbyte that should be used when crafting the\nclosure transaction.",
                        "format": "uint64",
                        "in": "query",
                        "name": "sat_per_vbyte",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcCloseStatusUpdate"
                            }
                          },
                          "title": "Stream result of lnrpcCloseStatusUpdate",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `closechannel`\nCloseChannel attempts to close an active channel identified by its channel\noutpoint (ChannelPoint). The actions of this method can additionally be\naugmented to attempt a force close after a timeout period in the case of an\ninactive peer. If a non-force close (cooperative closure) is requested,\nthen the user can specify either a target number of blocks until the\nclosure transaction is confirmed, or a manual fee rate. If neither are\nspecified, then a default lax, block confirmation target is used.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "AbandonChannel",
              "description": "lncli: `abandonchannel`\nAbandonChannel removes all channel state from the database except for a\nclose summary. This method can be used to get rid of permanently unusable\nchannels due to bugs fixed in newer versions of lnd. This method can also be\nused to remove externally funded channels where the funding transaction was\nnever broadcast. Only available for non-externally funded channels in dev\nbuild.",
              "requestType": "AbandonChannelRequest",
              "requestLongType": "AbandonChannelRequest",
              "requestFullType": "lnrpc.AbandonChannelRequest",
              "requestStreaming": false,
              "responseType": "AbandonChannelResponse",
              "responseLongType": "AbandonChannelResponse",
              "responseFullType": "lnrpc.AbandonChannelResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "DELETE",
                  "path": "/v1/channels/abandon/{channel_point.funding_txid_str}/{channel_point.output_index}",
                  "details": {
                    "operationId": "Lightning_AbandonChannel",
                    "parameters": [
                      {
                        "description": "Hex-encoded string representing the byte-reversed hash of the funding\ntransaction.",
                        "in": "path",
                        "name": "channel_point.funding_txid_str",
                        "required": true,
                        "type": "string"
                      },
                      {
                        "description": "The index of the output of the funding transaction",
                        "format": "int64",
                        "in": "path",
                        "name": "channel_point.output_index",
                        "required": true,
                        "type": "integer"
                      },
                      {
                        "description": "Txid of the funding transaction. When using REST, this field must be\nencoded as base64.",
                        "format": "byte",
                        "in": "query",
                        "name": "channel_point.funding_txid_bytes",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "in": "query",
                        "name": "pending_funding_shim_only",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "description": "Override the requirement for being in dev mode by setting this to true and\nconfirming the user knows what they are doing and this is a potential foot\ngun to lose funds if used on active channels.",
                        "in": "query",
                        "name": "i_know_what_i_am_doing",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcAbandonChannelResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `abandonchannel`\nAbandonChannel removes all channel state from the database except for a\nclose summary. This method can be used to get rid of permanently unusable\nchannels due to bugs fixed in newer versions of lnd. This method can also be\nused to remove externally funded channels where the funding transaction was\nnever broadcast. Only available for non-externally funded channels in dev\nbuild.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SendPayment",
              "description": "lncli: `sendpayment`\nDeprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a\nbi-directional streaming RPC for sending payments through the Lightning\nNetwork. A single RPC invocation creates a persistent bi-directional\nstream allowing clients to rapidly send payments through the Lightning\nNetwork with a single persistent connection.",
              "requestType": "SendRequest",
              "requestLongType": "SendRequest",
              "requestFullType": "lnrpc.SendRequest",
              "requestStreaming": true,
              "responseType": "SendResponse",
              "responseLongType": "SendResponse",
              "responseFullType": "lnrpc.SendResponse",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/channels/transaction-stream",
                  "details": {
                    "operationId": "Lightning_SendPayment",
                    "parameters": [
                      {
                        "description": " (streaming inputs)",
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcSendRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcSendResponse"
                            }
                          },
                          "title": "Stream result of lnrpcSendResponse",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `sendpayment`\nDeprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a\nbi-directional streaming RPC for sending payments through the Lightning\nNetwork. A single RPC invocation creates a persistent bi-directional\nstream allowing clients to rapidly send payments through the Lightning\nNetwork with a single persistent connection.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ],
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "SendPaymentSync",
              "description": "SendPaymentSync is the synchronous non-streaming version of SendPayment.\nThis RPC is intended to be consumed by clients of the REST proxy.\nAdditionally, this RPC expects the destination's public key and the payment\nhash (if any) to be encoded as hex strings.",
              "requestType": "SendRequest",
              "requestLongType": "SendRequest",
              "requestFullType": "lnrpc.SendRequest",
              "requestStreaming": false,
              "responseType": "SendResponse",
              "responseLongType": "SendResponse",
              "responseFullType": "lnrpc.SendResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/channels/transactions",
                  "details": {
                    "operationId": "Lightning_SendPaymentSync",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcSendRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcSendResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SendPaymentSync is the synchronous non-streaming version of SendPayment.\nThis RPC is intended to be consumed by clients of the REST proxy.\nAdditionally, this RPC expects the destination's public key and the payment\nhash (if any) to be encoded as hex strings.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SendToRoute",
              "description": "lncli: `sendtoroute`\nDeprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional\nstreaming RPC for sending payment through the Lightning Network. This\nmethod differs from SendPayment in that it allows users to specify a full\nroute manually. This can be used for things like rebalancing, and atomic\nswaps.",
              "requestType": "SendToRouteRequest",
              "requestLongType": "SendToRouteRequest",
              "requestFullType": "lnrpc.SendToRouteRequest",
              "requestStreaming": true,
              "responseType": "SendResponse",
              "responseLongType": "SendResponse",
              "responseFullType": "lnrpc.SendResponse",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "UNKNOWN",
                  "path": "",
                  "details": null
                }
              ],
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "SendToRouteSync",
              "description": "SendToRouteSync is a synchronous version of SendToRoute. It Will block\nuntil the payment either fails or succeeds.",
              "requestType": "SendToRouteRequest",
              "requestLongType": "SendToRouteRequest",
              "requestFullType": "lnrpc.SendToRouteRequest",
              "requestStreaming": false,
              "responseType": "SendResponse",
              "responseLongType": "SendResponse",
              "responseFullType": "lnrpc.SendResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/channels/transactions/route",
                  "details": {
                    "operationId": "Lightning_SendToRouteSync",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcSendToRouteRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcSendResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SendToRouteSync is a synchronous version of SendToRoute. It Will block\nuntil the payment either fails or succeeds.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "AddInvoice",
              "description": "lncli: `addinvoice`\nAddInvoice attempts to add a new invoice to the invoice database. Any\nduplicated invoices are rejected, therefore all invoices *must* have a\nunique payment preimage.",
              "requestType": "Invoice",
              "requestLongType": "Invoice",
              "requestFullType": "lnrpc.Invoice",
              "requestStreaming": false,
              "responseType": "AddInvoiceResponse",
              "responseLongType": "AddInvoiceResponse",
              "responseFullType": "lnrpc.AddInvoiceResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/invoices",
                  "details": {
                    "operationId": "Lightning_AddInvoice",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcInvoice"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcAddInvoiceResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `addinvoice`\nAddInvoice attempts to add a new invoice to the invoice database. Any\nduplicated invoices are rejected, therefore all invoices *must* have a\nunique payment preimage.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ListInvoices",
              "description": "lncli: `listinvoices`\nListInvoices returns a list of all the invoices currently stored within the\ndatabase. Any active debug invoices are ignored. It has full support for\npaginated responses, allowing users to query for specific invoices through\ntheir add_index. This can be done by using either the first_index_offset or\nlast_index_offset fields included in the response as the index_offset of the\nnext request. By default, the first 100 invoices created will be returned.\nBackwards pagination is also supported through the Reversed flag.",
              "requestType": "ListInvoiceRequest",
              "requestLongType": "ListInvoiceRequest",
              "requestFullType": "lnrpc.ListInvoiceRequest",
              "requestStreaming": false,
              "responseType": "ListInvoiceResponse",
              "responseLongType": "ListInvoiceResponse",
              "responseFullType": "lnrpc.ListInvoiceResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/invoices",
                  "details": {
                    "operationId": "Lightning_ListInvoices",
                    "parameters": [
                      {
                        "description": "If set, only invoices that are not settled and not canceled will be returned\nin the response.",
                        "in": "query",
                        "name": "pending_only",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "description": "The index of an invoice that will be used as either the start or end of a\nquery to determine which invoices should be returned in the response.",
                        "format": "uint64",
                        "in": "query",
                        "name": "index_offset",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "The max number of invoices to return in the response to this query.",
                        "format": "uint64",
                        "in": "query",
                        "name": "num_max_invoices",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "If set, the invoices returned will result from seeking backwards from the\nspecified index offset. This can be used to paginate backwards.",
                        "in": "query",
                        "name": "reversed",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcListInvoiceResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `listinvoices`\nListInvoices returns a list of all the invoices currently stored within the\ndatabase. Any active debug invoices are ignored. It has full support for\npaginated responses, allowing users to query for specific invoices through\ntheir add_index. This can be done by using either the first_index_offset or\nlast_index_offset fields included in the response as the index_offset of the\nnext request. By default, the first 100 invoices created will be returned.\nBackwards pagination is also supported through the Reversed flag.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "LookupInvoice",
              "description": "lncli: `lookupinvoice`\nLookupInvoice attempts to look up an invoice according to its payment hash.\nThe passed payment hash *must* be exactly 32 bytes, if not, an error is\nreturned.",
              "requestType": "PaymentHash",
              "requestLongType": "PaymentHash",
              "requestFullType": "lnrpc.PaymentHash",
              "requestStreaming": false,
              "responseType": "Invoice",
              "responseLongType": "Invoice",
              "responseFullType": "lnrpc.Invoice",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/invoice/{r_hash_str}",
                  "details": {
                    "operationId": "Lightning_LookupInvoice",
                    "parameters": [
                      {
                        "description": "The hex-encoded payment hash of the invoice to be looked up. The passed\npayment hash must be exactly 32 bytes, otherwise an error is returned.\nDeprecated now that the REST gateway supports base64 encoding of bytes\nfields.",
                        "in": "path",
                        "name": "r_hash_str",
                        "required": true,
                        "type": "string"
                      },
                      {
                        "description": "The payment hash of the invoice to be looked up. When using REST, this field\nmust be encoded as base64.",
                        "format": "byte",
                        "in": "query",
                        "name": "r_hash",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcInvoice"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `lookupinvoice`\nLookupInvoice attempts to look up an invoice according to its payment hash.\nThe passed payment hash *must* be exactly 32 bytes, if not, an error is\nreturned.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SubscribeInvoices",
              "description": "SubscribeInvoices returns a uni-directional stream (server -\u003e client) for\nnotifying the client of newly added/settled invoices. The caller can\noptionally specify the add_index and/or the settle_index. If the add_index\nis specified, then we'll first start by sending add invoice events for all\ninvoices with an add_index greater than the specified value. If the\nsettle_index is specified, the next, we'll send out all settle events for\ninvoices with a settle_index greater than the specified value. One or both\nof these fields can be set. If no fields are set, then we'll only send out\nthe latest add/settle events.",
              "requestType": "InvoiceSubscription",
              "requestLongType": "InvoiceSubscription",
              "requestFullType": "lnrpc.InvoiceSubscription",
              "requestStreaming": false,
              "responseType": "Invoice",
              "responseLongType": "Invoice",
              "responseFullType": "lnrpc.Invoice",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/invoices/subscribe",
                  "details": {
                    "operationId": "Lightning_SubscribeInvoices",
                    "parameters": [
                      {
                        "description": "If specified (non-zero), then we'll first start by sending out\nnotifications for all added indexes with an add_index greater than this\nvalue. This allows callers to catch up on any events they missed while they\nweren't connected to the streaming RPC.",
                        "format": "uint64",
                        "in": "query",
                        "name": "add_index",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "If specified (non-zero), then we'll first start by sending out\nnotifications for all settled indexes with an settle_index greater than\nthis value. This allows callers to catch up on any events they missed while\nthey weren't connected to the streaming RPC.",
                        "format": "uint64",
                        "in": "query",
                        "name": "settle_index",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcInvoice"
                            }
                          },
                          "title": "Stream result of lnrpcInvoice",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SubscribeInvoices returns a uni-directional stream (server -\u003e client) for\nnotifying the client of newly added/settled invoices. The caller can\noptionally specify the add_index and/or the settle_index. If the add_index\nis specified, then we'll first start by sending add invoice events for all\ninvoices with an add_index greater than the specified value. If the\nsettle_index is specified, the next, we'll send out all settle events for\ninvoices with a settle_index greater than the specified value. One or both\nof these fields can be set. If no fields are set, then we'll only send out\nthe latest add/settle events.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "DecodePayReq",
              "description": "lncli: `decodepayreq`\nDecodePayReq takes an encoded payment request string and attempts to decode\nit, returning a full description of the conditions encoded within the\npayment request.",
              "requestType": "PayReqString",
              "requestLongType": "PayReqString",
              "requestFullType": "lnrpc.PayReqString",
              "requestStreaming": false,
              "responseType": "PayReq",
              "responseLongType": "PayReq",
              "responseFullType": "lnrpc.PayReq",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/payreq/{pay_req}",
                  "details": {
                    "operationId": "Lightning_DecodePayReq",
                    "parameters": [
                      {
                        "description": "The payment request string to be decoded",
                        "in": "path",
                        "name": "pay_req",
                        "required": true,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcPayReq"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `decodepayreq`\nDecodePayReq takes an encoded payment request string and attempts to decode\nit, returning a full description of the conditions encoded within the\npayment request.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ListPayments",
              "description": "lncli: `listpayments`\nListPayments returns a list of all outgoing payments.",
              "requestType": "ListPaymentsRequest",
              "requestLongType": "ListPaymentsRequest",
              "requestFullType": "lnrpc.ListPaymentsRequest",
              "requestStreaming": false,
              "responseType": "ListPaymentsResponse",
              "responseLongType": "ListPaymentsResponse",
              "responseFullType": "lnrpc.ListPaymentsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/payments",
                  "details": {
                    "operationId": "Lightning_ListPayments",
                    "parameters": [
                      {
                        "description": "If true, then return payments that have not yet fully completed. This means\nthat pending payments, as well as failed payments will show up if this\nfield is set to true. This flag doesn't change the meaning of the indices,\nwhich are tied to individual payments.",
                        "in": "query",
                        "name": "include_incomplete",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "description": "The index of a payment that will be used as either the start or end of a\nquery to determine which payments should be returned in the response. The\nindex_offset is exclusive. In the case of a zero index_offset, the query\nwill start with the oldest payment when paginating forwards, or will end\nwith the most recent payment when paginating backwards.",
                        "format": "uint64",
                        "in": "query",
                        "name": "index_offset",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "The maximal number of payments returned in the response to this query.",
                        "format": "uint64",
                        "in": "query",
                        "name": "max_payments",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "If set, the payments returned will result from seeking backwards from the\nspecified index offset. This can be used to paginate backwards. The order\nof the returned payments is always oldest first (ascending index order).",
                        "in": "query",
                        "name": "reversed",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "description": "If set, all payments (complete and incomplete, independent of the\nmax_payments parameter) will be counted. Note that setting this to true will\nincrease the run time of the call significantly on systems that have a lot\nof payments, as all of them have to be iterated through to be counted.",
                        "in": "query",
                        "name": "count_total_payments",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcListPaymentsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `listpayments`\nListPayments returns a list of all outgoing payments.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "DeletePayment",
              "description": "DeletePayment deletes an outgoing payment from DB. Note that it will not\nattempt to delete an In-Flight payment, since that would be unsafe.",
              "requestType": "DeletePaymentRequest",
              "requestLongType": "DeletePaymentRequest",
              "requestFullType": "lnrpc.DeletePaymentRequest",
              "requestStreaming": false,
              "responseType": "DeletePaymentResponse",
              "responseLongType": "DeletePaymentResponse",
              "responseFullType": "lnrpc.DeletePaymentResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "DELETE",
                  "path": "/v1/payment",
                  "details": {
                    "operationId": "Lightning_DeletePayment",
                    "parameters": [
                      {
                        "description": "Payment hash to delete.",
                        "format": "byte",
                        "in": "query",
                        "name": "payment_hash",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "Only delete failed HTLCs from the payment, not the payment itself.",
                        "in": "query",
                        "name": "failed_htlcs_only",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcDeletePaymentResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "DeletePayment deletes an outgoing payment from DB. Note that it will not\nattempt to delete an In-Flight payment, since that would be unsafe.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "DeleteAllPayments",
              "description": "DeleteAllPayments deletes all outgoing payments from DB. Note that it will\nnot attempt to delete In-Flight payments, since that would be unsafe.",
              "requestType": "DeleteAllPaymentsRequest",
              "requestLongType": "DeleteAllPaymentsRequest",
              "requestFullType": "lnrpc.DeleteAllPaymentsRequest",
              "requestStreaming": false,
              "responseType": "DeleteAllPaymentsResponse",
              "responseLongType": "DeleteAllPaymentsResponse",
              "responseFullType": "lnrpc.DeleteAllPaymentsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "DELETE",
                  "path": "/v1/payments",
                  "details": {
                    "operationId": "Lightning_DeleteAllPayments",
                    "parameters": [
                      {
                        "description": "Only delete failed payments.",
                        "in": "query",
                        "name": "failed_payments_only",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "description": "Only delete failed HTLCs from payments, not the payment itself.",
                        "in": "query",
                        "name": "failed_htlcs_only",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcDeleteAllPaymentsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "DeleteAllPayments deletes all outgoing payments from DB. Note that it will\nnot attempt to delete In-Flight payments, since that would be unsafe.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "DescribeGraph",
              "description": "lncli: `describegraph`\nDescribeGraph returns a description of the latest graph state from the\npoint of view of the node. The graph information is partitioned into two\ncomponents: all the nodes/vertexes, and all the edges that connect the\nvertexes themselves. As this is a directed graph, the edges also contain\nthe node directional specific routing policy which includes: the time lock\ndelta, fee information, etc.",
              "requestType": "ChannelGraphRequest",
              "requestLongType": "ChannelGraphRequest",
              "requestFullType": "lnrpc.ChannelGraphRequest",
              "requestStreaming": false,
              "responseType": "ChannelGraph",
              "responseLongType": "ChannelGraph",
              "responseFullType": "lnrpc.ChannelGraph",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/graph",
                  "details": {
                    "operationId": "Lightning_DescribeGraph",
                    "parameters": [
                      {
                        "description": "Whether unannounced channels are included in the response or not. If set,\nunannounced channels are included. Unannounced channels are both private\nchannels, and public channels that are not yet announced to the network.",
                        "in": "query",
                        "name": "include_unannounced",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcChannelGraph"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `describegraph`\nDescribeGraph returns a description of the latest graph state from the\npoint of view of the node. The graph information is partitioned into two\ncomponents: all the nodes/vertexes, and all the edges that connect the\nvertexes themselves. As this is a directed graph, the edges also contain\nthe node directional specific routing policy which includes: the time lock\ndelta, fee information, etc.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetNodeMetrics",
              "description": "lncli: `getnodemetrics`\nGetNodeMetrics returns node metrics calculated from the graph. Currently\nthe only supported metric is betweenness centrality of individual nodes.",
              "requestType": "NodeMetricsRequest",
              "requestLongType": "NodeMetricsRequest",
              "requestFullType": "lnrpc.NodeMetricsRequest",
              "requestStreaming": false,
              "responseType": "NodeMetricsResponse",
              "responseLongType": "NodeMetricsResponse",
              "responseFullType": "lnrpc.NodeMetricsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/graph/nodemetrics",
                  "details": {
                    "operationId": "Lightning_GetNodeMetrics",
                    "parameters": [
                      {
                        "collectionFormat": "multi",
                        "description": "The requested node metrics.",
                        "in": "query",
                        "items": {
                          "enum": [
                            "UNKNOWN",
                            "BETWEENNESS_CENTRALITY"
                          ],
                          "type": "string"
                        },
                        "name": "types",
                        "required": false,
                        "type": "array"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcNodeMetricsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `getnodemetrics`\nGetNodeMetrics returns node metrics calculated from the graph. Currently\nthe only supported metric is betweenness centrality of individual nodes.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetChanInfo",
              "description": "lncli: `getchaninfo`\nGetChanInfo returns the latest authenticated network announcement for the\ngiven channel identified by its channel ID: an 8-byte integer which\nuniquely identifies the location of transaction's funding output within the\nblockchain.",
              "requestType": "ChanInfoRequest",
              "requestLongType": "ChanInfoRequest",
              "requestFullType": "lnrpc.ChanInfoRequest",
              "requestStreaming": false,
              "responseType": "ChannelEdge",
              "responseLongType": "ChannelEdge",
              "responseFullType": "lnrpc.ChannelEdge",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/graph/edge/{chan_id}",
                  "details": {
                    "operationId": "Lightning_GetChanInfo",
                    "parameters": [
                      {
                        "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel.",
                        "format": "uint64",
                        "in": "path",
                        "name": "chan_id",
                        "required": true,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcChannelEdge"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `getchaninfo`\nGetChanInfo returns the latest authenticated network announcement for the\ngiven channel identified by its channel ID: an 8-byte integer which\nuniquely identifies the location of transaction's funding output within the\nblockchain.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetNodeInfo",
              "description": "lncli: `getnodeinfo`\nGetNodeInfo returns the latest advertised, aggregated, and authenticated\nchannel information for the specified node identified by its public key.",
              "requestType": "NodeInfoRequest",
              "requestLongType": "NodeInfoRequest",
              "requestFullType": "lnrpc.NodeInfoRequest",
              "requestStreaming": false,
              "responseType": "NodeInfo",
              "responseLongType": "NodeInfo",
              "responseFullType": "lnrpc.NodeInfo",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/graph/node/{pub_key}",
                  "details": {
                    "operationId": "Lightning_GetNodeInfo",
                    "parameters": [
                      {
                        "description": "The 33-byte hex-encoded compressed public of the target node",
                        "in": "path",
                        "name": "pub_key",
                        "required": true,
                        "type": "string"
                      },
                      {
                        "description": "If true, will include all known channels associated with the node.",
                        "in": "query",
                        "name": "include_channels",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcNodeInfo"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `getnodeinfo`\nGetNodeInfo returns the latest advertised, aggregated, and authenticated\nchannel information for the specified node identified by its public key.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "QueryRoutes",
              "description": "lncli: `queryroutes`\nQueryRoutes attempts to query the daemon's Channel Router for a possible\nroute to a target destination capable of carrying a specific amount of\nsatoshis. The returned route contains the full details required to craft and\nsend an HTLC, also including the necessary information that should be\npresent within the Sphinx packet encapsulated within the HTLC.\n\nWhen using REST, the `dest_custom_records` map type can be set by appending\n`\u0026dest_custom_records[\u003crecord_number\u003e]=\u003crecord_data_base64_url_encoded\u003e`\nto the URL. Unfortunately this map type doesn't appear in the REST API\ndocumentation because of a bug in the grpc-gateway library.",
              "requestType": "QueryRoutesRequest",
              "requestLongType": "QueryRoutesRequest",
              "requestFullType": "lnrpc.QueryRoutesRequest",
              "requestStreaming": false,
              "responseType": "QueryRoutesResponse",
              "responseLongType": "QueryRoutesResponse",
              "responseFullType": "lnrpc.QueryRoutesResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/graph/routes/{pub_key}/{amt}",
                  "details": {
                    "description": "When using REST, the `dest_custom_records` map type can be set by appending\n`\u0026dest_custom_records[\u003crecord_number\u003e]=\u003crecord_data_base64_url_encoded\u003e`\nto the URL. Unfortunately this map type doesn't appear in the REST API\ndocumentation because of a bug in the grpc-gateway library.",
                    "operationId": "Lightning_QueryRoutes",
                    "parameters": [
                      {
                        "description": "The 33-byte hex-encoded public key for the payment destination",
                        "in": "path",
                        "name": "pub_key",
                        "required": true,
                        "type": "string"
                      },
                      {
                        "description": "The amount to send expressed in satoshis.\n\nThe fields amt and amt_msat are mutually exclusive.",
                        "format": "int64",
                        "in": "path",
                        "name": "amt",
                        "required": true,
                        "type": "string"
                      },
                      {
                        "description": "The amount to send expressed in millisatoshis.\n\nThe fields amt and amt_msat are mutually exclusive.",
                        "format": "int64",
                        "in": "query",
                        "name": "amt_msat",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "An optional CLTV delta from the current height that should be used for the\ntimelock of the final hop. Note that unlike SendPayment, QueryRoutes does\nnot add any additional block padding on top of final_ctlv_delta. This\npadding of a few blocks needs to be added manually or otherwise failures may\nhappen when a block comes in while the payment is in flight.",
                        "format": "int32",
                        "in": "query",
                        "name": "final_cltv_delta",
                        "required": false,
                        "type": "integer"
                      },
                      {
                        "description": "The fee limit expressed as a fixed amount of satoshis.\n\nThe fields fixed and fixed_msat are mutually exclusive.",
                        "format": "int64",
                        "in": "query",
                        "name": "fee_limit.fixed",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "The fee limit expressed as a fixed amount of millisatoshis.\n\nThe fields fixed and fixed_msat are mutually exclusive.",
                        "format": "int64",
                        "in": "query",
                        "name": "fee_limit.fixed_msat",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "The fee limit expressed as a percentage of the payment amount.",
                        "format": "int64",
                        "in": "query",
                        "name": "fee_limit.percent",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "collectionFormat": "multi",
                        "description": "A list of nodes to ignore during path finding. When using REST, these fields\nmust be encoded as base64.",
                        "in": "query",
                        "items": {
                          "format": "byte",
                          "type": "string"
                        },
                        "name": "ignored_nodes",
                        "required": false,
                        "type": "array"
                      },
                      {
                        "description": "The source node where the request route should originated from. If empty,\nself is assumed.",
                        "in": "query",
                        "name": "source_pub_key",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "If set to true, edge probabilities from mission control will be used to get\nthe optimal route.",
                        "in": "query",
                        "name": "use_mission_control",
                        "required": false,
                        "type": "boolean"
                      },
                      {
                        "description": "An optional maximum total time lock for the route. If the source is empty or\nourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If\nzero, then the value of `--max-cltv-expiry` is used as the limit.",
                        "format": "int64",
                        "in": "query",
                        "name": "cltv_limit",
                        "required": false,
                        "type": "integer"
                      },
                      {
                        "description": "The channel id of the channel that must be taken to the first hop. If zero,\nany channel may be used.",
                        "format": "uint64",
                        "in": "query",
                        "name": "outgoing_chan_id",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "description": "The pubkey of the last hop of the route. If empty, any hop may be used.",
                        "format": "byte",
                        "in": "query",
                        "name": "last_hop_pubkey",
                        "required": false,
                        "type": "string"
                      },
                      {
                        "collectionFormat": "multi",
                        "description": "Features assumed to be supported by the final node. All transitive feature\ndependencies must also be set properly. For a given feature bit pair, either\noptional or remote may be set, but not both. If this field is nil or empty,\nthe router will try to load destination features from the graph as a\nfallback.",
                        "in": "query",
                        "items": {
                          "enum": [
                            "DATALOSS_PROTECT_REQ",
                            "DATALOSS_PROTECT_OPT",
                            "INITIAL_ROUING_SYNC",
                            "UPFRONT_SHUTDOWN_SCRIPT_REQ",
                            "UPFRONT_SHUTDOWN_SCRIPT_OPT",
                            "GOSSIP_QUERIES_REQ",
                            "GOSSIP_QUERIES_OPT",
                            "TLV_ONION_REQ",
                            "TLV_ONION_OPT",
                            "EXT_GOSSIP_QUERIES_REQ",
                            "EXT_GOSSIP_QUERIES_OPT",
                            "STATIC_REMOTE_KEY_REQ",
                            "STATIC_REMOTE_KEY_OPT",
                            "PAYMENT_ADDR_REQ",
                            "PAYMENT_ADDR_OPT",
                            "MPP_REQ",
                            "MPP_OPT",
                            "WUMBO_CHANNELS_REQ",
                            "WUMBO_CHANNELS_OPT",
                            "ANCHORS_REQ",
                            "ANCHORS_OPT",
                            "ANCHORS_ZERO_FEE_HTLC_REQ",
                            "ANCHORS_ZERO_FEE_HTLC_OPT",
                            "AMP_REQ",
                            "AMP_OPT"
                          ],
                          "type": "string"
                        },
                        "name": "dest_features",
                        "required": false,
                        "type": "array"
                      },
                      {
                        "description": "The time preference for this payment. Set to -1 to optimize for fees\nonly, to 1 to optimize for reliability only or a value inbetween for a mix.",
                        "format": "double",
                        "in": "query",
                        "name": "time_pref",
                        "required": false,
                        "type": "number"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcQueryRoutesResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `queryroutes`\nQueryRoutes attempts to query the daemon's Channel Router for a possible\nroute to a target destination capable of carrying a specific amount of\nsatoshis. The returned route contains the full details required to craft and\nsend an HTLC, also including the necessary information that should be\npresent within the Sphinx packet encapsulated within the HTLC.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetNetworkInfo",
              "description": "lncli: `getnetworkinfo`\nGetNetworkInfo returns some basic stats about the known channel graph from\nthe point of view of the node.",
              "requestType": "NetworkInfoRequest",
              "requestLongType": "NetworkInfoRequest",
              "requestFullType": "lnrpc.NetworkInfoRequest",
              "requestStreaming": false,
              "responseType": "NetworkInfo",
              "responseLongType": "NetworkInfo",
              "responseFullType": "lnrpc.NetworkInfo",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/graph/info",
                  "details": {
                    "operationId": "Lightning_GetNetworkInfo",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcNetworkInfo"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `getnetworkinfo`\nGetNetworkInfo returns some basic stats about the known channel graph from\nthe point of view of the node.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "StopDaemon",
              "description": "lncli: `stop`\nStopDaemon will send a shutdown request to the interrupt handler, triggering\na graceful shutdown of the daemon.",
              "requestType": "StopRequest",
              "requestLongType": "StopRequest",
              "requestFullType": "lnrpc.StopRequest",
              "requestStreaming": false,
              "responseType": "StopResponse",
              "responseLongType": "StopResponse",
              "responseFullType": "lnrpc.StopResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/stop",
                  "details": {
                    "operationId": "Lightning_StopDaemon",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcStopRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcStopResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `stop`\nStopDaemon will send a shutdown request to the interrupt handler, triggering\na graceful shutdown of the daemon.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SubscribeChannelGraph",
              "description": "SubscribeChannelGraph launches a streaming RPC that allows the caller to\nreceive notifications upon any changes to the channel graph topology from\nthe point of view of the responding node. Events notified include: new\nnodes coming online, nodes updating their authenticated attributes, new\nchannels being advertised, updates in the routing policy for a directional\nchannel edge, and when channels are closed on-chain.",
              "requestType": "GraphTopologySubscription",
              "requestLongType": "GraphTopologySubscription",
              "requestFullType": "lnrpc.GraphTopologySubscription",
              "requestStreaming": false,
              "responseType": "GraphTopologyUpdate",
              "responseLongType": "GraphTopologyUpdate",
              "responseFullType": "lnrpc.GraphTopologyUpdate",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/graph/subscribe",
                  "details": {
                    "operationId": "Lightning_SubscribeChannelGraph",
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcGraphTopologyUpdate"
                            }
                          },
                          "title": "Stream result of lnrpcGraphTopologyUpdate",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SubscribeChannelGraph launches a streaming RPC that allows the caller to\nreceive notifications upon any changes to the channel graph topology from\nthe point of view of the responding node. Events notified include: new\nnodes coming online, nodes updating their authenticated attributes, new\nchannels being advertised, updates in the routing policy for a directional\nchannel edge, and when channels are closed on-chain.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "DebugLevel",
              "description": "lncli: `debuglevel`\nDebugLevel allows a caller to programmatically set the logging verbosity of\nlnd. The logging can be targeted according to a coarse daemon-wide logging\nlevel, or in a granular fashion to specify the logging for a target\nsub-system.",
              "requestType": "DebugLevelRequest",
              "requestLongType": "DebugLevelRequest",
              "requestFullType": "lnrpc.DebugLevelRequest",
              "requestStreaming": false,
              "responseType": "DebugLevelResponse",
              "responseLongType": "DebugLevelResponse",
              "responseFullType": "lnrpc.DebugLevelResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/debuglevel",
                  "details": {
                    "operationId": "Lightning_DebugLevel",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcDebugLevelRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcDebugLevelResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `debuglevel`\nDebugLevel allows a caller to programmatically set the logging verbosity of\nlnd. The logging can be targeted according to a coarse daemon-wide logging\nlevel, or in a granular fashion to specify the logging for a target\nsub-system.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "FeeReport",
              "description": "lncli: `feereport`\nFeeReport allows the caller to obtain a report detailing the current fee\nschedule enforced by the node globally for each channel.",
              "requestType": "FeeReportRequest",
              "requestLongType": "FeeReportRequest",
              "requestFullType": "lnrpc.FeeReportRequest",
              "requestStreaming": false,
              "responseType": "FeeReportResponse",
              "responseLongType": "FeeReportResponse",
              "responseFullType": "lnrpc.FeeReportResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/fees",
                  "details": {
                    "operationId": "Lightning_FeeReport",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcFeeReportResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `feereport`\nFeeReport allows the caller to obtain a report detailing the current fee\nschedule enforced by the node globally for each channel.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "UpdateChannelPolicy",
              "description": "lncli: `updatechanpolicy`\nUpdateChannelPolicy allows the caller to update the fee schedule and\nchannel policies for all channels globally, or a particular channel.",
              "requestType": "PolicyUpdateRequest",
              "requestLongType": "PolicyUpdateRequest",
              "requestFullType": "lnrpc.PolicyUpdateRequest",
              "requestStreaming": false,
              "responseType": "PolicyUpdateResponse",
              "responseLongType": "PolicyUpdateResponse",
              "responseFullType": "lnrpc.PolicyUpdateResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/chanpolicy",
                  "details": {
                    "operationId": "Lightning_UpdateChannelPolicy",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcPolicyUpdateRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcPolicyUpdateResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `updatechanpolicy`\nUpdateChannelPolicy allows the caller to update the fee schedule and\nchannel policies for all channels globally, or a particular channel.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ForwardingHistory",
              "description": "lncli: `fwdinghistory`\nForwardingHistory allows the caller to query the htlcswitch for a record of\nall HTLCs forwarded within the target time range, and integer offset\nwithin that time range, for a maximum number of events. If no maximum number\nof events is specified, up to 100 events will be returned. If no time-range\nis specified, then events will be returned in the order that they occured.\n\nA list of forwarding events are returned. The size of each forwarding event\nis 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.\nAs a result each message can only contain 50k entries. Each response has\nthe index offset of the last entry. The index offset can be provided to the\nrequest to allow the caller to skip a series of records.",
              "requestType": "ForwardingHistoryRequest",
              "requestLongType": "ForwardingHistoryRequest",
              "requestFullType": "lnrpc.ForwardingHistoryRequest",
              "requestStreaming": false,
              "responseType": "ForwardingHistoryResponse",
              "responseLongType": "ForwardingHistoryResponse",
              "responseFullType": "lnrpc.ForwardingHistoryResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/switch",
                  "details": {
                    "description": "A list of forwarding events are returned. The size of each forwarding event\nis 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.\nAs a result each message can only contain 50k entries. Each response has\nthe index offset of the last entry. The index offset can be provided to the\nrequest to allow the caller to skip a series of records.",
                    "operationId": "Lightning_ForwardingHistory",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcForwardingHistoryRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcForwardingHistoryResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `fwdinghistory`\nForwardingHistory allows the caller to query the htlcswitch for a record of\nall HTLCs forwarded within the target time range, and integer offset\nwithin that time range, for a maximum number of events. If no maximum number\nof events is specified, up to 100 events will be returned. If no time-range\nis specified, then events will be returned in the order that they occured.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ExportChannelBackup",
              "description": "lncli: `exportchanbackup`\nExportChannelBackup attempts to return an encrypted static channel backup\nfor the target channel identified by it channel point. The backup is\nencrypted with a key generated from the aezeed seed of the user. The\nreturned backup can either be restored using the RestoreChannelBackup\nmethod once lnd is running, or via the InitWallet and UnlockWallet methods\nfrom the WalletUnlocker service.",
              "requestType": "ExportChannelBackupRequest",
              "requestLongType": "ExportChannelBackupRequest",
              "requestFullType": "lnrpc.ExportChannelBackupRequest",
              "requestStreaming": false,
              "responseType": "ChannelBackup",
              "responseLongType": "ChannelBackup",
              "responseFullType": "lnrpc.ChannelBackup",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/channels/backup/{chan_point.funding_txid_str}/{chan_point.output_index}",
                  "details": {
                    "operationId": "Lightning_ExportChannelBackup",
                    "parameters": [
                      {
                        "description": "Hex-encoded string representing the byte-reversed hash of the funding\ntransaction.",
                        "in": "path",
                        "name": "chan_point.funding_txid_str",
                        "required": true,
                        "type": "string"
                      },
                      {
                        "description": "The index of the output of the funding transaction",
                        "format": "int64",
                        "in": "path",
                        "name": "chan_point.output_index",
                        "required": true,
                        "type": "integer"
                      },
                      {
                        "description": "Txid of the funding transaction. When using REST, this field must be\nencoded as base64.",
                        "format": "byte",
                        "in": "query",
                        "name": "chan_point.funding_txid_bytes",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcChannelBackup"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `exportchanbackup`\nExportChannelBackup attempts to return an encrypted static channel backup\nfor the target channel identified by it channel point. The backup is\nencrypted with a key generated from the aezeed seed of the user. The\nreturned backup can either be restored using the RestoreChannelBackup\nmethod once lnd is running, or via the InitWallet and UnlockWallet methods\nfrom the WalletUnlocker service.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ExportAllChannelBackups",
              "description": "ExportAllChannelBackups returns static channel backups for all existing\nchannels known to lnd. A set of regular singular static channel backups for\neach channel are returned. Additionally, a multi-channel backup is returned\nas well, which contains a single encrypted blob containing the backups of\neach channel.",
              "requestType": "ChanBackupExportRequest",
              "requestLongType": "ChanBackupExportRequest",
              "requestFullType": "lnrpc.ChanBackupExportRequest",
              "requestStreaming": false,
              "responseType": "ChanBackupSnapshot",
              "responseLongType": "ChanBackupSnapshot",
              "responseFullType": "lnrpc.ChanBackupSnapshot",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/channels/backup",
                  "details": {
                    "operationId": "Lightning_ExportAllChannelBackups",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcChanBackupSnapshot"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ExportAllChannelBackups returns static channel backups for all existing\nchannels known to lnd. A set of regular singular static channel backups for\neach channel are returned. Additionally, a multi-channel backup is returned\nas well, which contains a single encrypted blob containing the backups of\neach channel.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "VerifyChanBackup",
              "description": "VerifyChanBackup allows a caller to verify the integrity of a channel backup\nsnapshot. This method will accept either a packed Single or a packed Multi.\nSpecifying both will result in an error.",
              "requestType": "ChanBackupSnapshot",
              "requestLongType": "ChanBackupSnapshot",
              "requestFullType": "lnrpc.ChanBackupSnapshot",
              "requestStreaming": false,
              "responseType": "VerifyChanBackupResponse",
              "responseLongType": "VerifyChanBackupResponse",
              "responseFullType": "lnrpc.VerifyChanBackupResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/channels/backup/verify",
                  "details": {
                    "operationId": "Lightning_VerifyChanBackup",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcChanBackupSnapshot"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcVerifyChanBackupResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "VerifyChanBackup allows a caller to verify the integrity of a channel backup\nsnapshot. This method will accept either a packed Single or a packed Multi.\nSpecifying both will result in an error.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "RestoreChannelBackups",
              "description": "lncli: `restorechanbackup`\nRestoreChannelBackups accepts a set of singular channel backups, or a\nsingle encrypted multi-chan backup and attempts to recover any funds\nremaining within the channel. If we are able to unpack the backup, then the\nnew channel will be shown under listchannels, as well as pending channels.",
              "requestType": "RestoreChanBackupRequest",
              "requestLongType": "RestoreChanBackupRequest",
              "requestFullType": "lnrpc.RestoreChanBackupRequest",
              "requestStreaming": false,
              "responseType": "RestoreBackupResponse",
              "responseLongType": "RestoreBackupResponse",
              "responseFullType": "lnrpc.RestoreBackupResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/channels/backup/restore",
                  "details": {
                    "operationId": "Lightning_RestoreChannelBackups",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcRestoreChanBackupRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcRestoreBackupResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `restorechanbackup`\nRestoreChannelBackups accepts a set of singular channel backups, or a\nsingle encrypted multi-chan backup and attempts to recover any funds\nremaining within the channel. If we are able to unpack the backup, then the\nnew channel will be shown under listchannels, as well as pending channels.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SubscribeChannelBackups",
              "description": "SubscribeChannelBackups allows a client to sub-subscribe to the most up to\ndate information concerning the state of all channel backups. Each time a\nnew channel is added, we return the new set of channels, along with a\nmulti-chan backup containing the backup info for all channels. Each time a\nchannel is closed, we send a new update, which contains new new chan back\nups, but the updated set of encrypted multi-chan backups with the closed\nchannel(s) removed.",
              "requestType": "ChannelBackupSubscription",
              "requestLongType": "ChannelBackupSubscription",
              "requestFullType": "lnrpc.ChannelBackupSubscription",
              "requestStreaming": false,
              "responseType": "ChanBackupSnapshot",
              "responseLongType": "ChanBackupSnapshot",
              "responseFullType": "lnrpc.ChanBackupSnapshot",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/channels/backup/subscribe",
                  "details": {
                    "operationId": "Lightning_SubscribeChannelBackups",
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcChanBackupSnapshot"
                            }
                          },
                          "title": "Stream result of lnrpcChanBackupSnapshot",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SubscribeChannelBackups allows a client to sub-subscribe to the most up to\ndate information concerning the state of all channel backups. Each time a\nnew channel is added, we return the new set of channels, along with a\nmulti-chan backup containing the backup info for all channels. Each time a\nchannel is closed, we send a new update, which contains new new chan back\nups, but the updated set of encrypted multi-chan backups with the closed\nchannel(s) removed.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "BakeMacaroon",
              "description": "lncli: `bakemacaroon`\nBakeMacaroon allows the creation of a new macaroon with custom read and\nwrite permissions. No first-party caveats are added since this can be done\noffline.",
              "requestType": "BakeMacaroonRequest",
              "requestLongType": "BakeMacaroonRequest",
              "requestFullType": "lnrpc.BakeMacaroonRequest",
              "requestStreaming": false,
              "responseType": "BakeMacaroonResponse",
              "responseLongType": "BakeMacaroonResponse",
              "responseFullType": "lnrpc.BakeMacaroonResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/macaroon",
                  "details": {
                    "operationId": "Lightning_BakeMacaroon",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcBakeMacaroonRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcBakeMacaroonResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `bakemacaroon`\nBakeMacaroon allows the creation of a new macaroon with custom read and\nwrite permissions. No first-party caveats are added since this can be done\noffline.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ListMacaroonIDs",
              "description": "lncli: `listmacaroonids`\nListMacaroonIDs returns all root key IDs that are in use.",
              "requestType": "ListMacaroonIDsRequest",
              "requestLongType": "ListMacaroonIDsRequest",
              "requestFullType": "lnrpc.ListMacaroonIDsRequest",
              "requestStreaming": false,
              "responseType": "ListMacaroonIDsResponse",
              "responseLongType": "ListMacaroonIDsResponse",
              "responseFullType": "lnrpc.ListMacaroonIDsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/macaroon/ids",
                  "details": {
                    "operationId": "Lightning_ListMacaroonIDs",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcListMacaroonIDsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `listmacaroonids`\nListMacaroonIDs returns all root key IDs that are in use.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "DeleteMacaroonID",
              "description": "lncli: `deletemacaroonid`\nDeleteMacaroonID deletes the specified macaroon ID and invalidates all\nmacaroons derived from that ID.",
              "requestType": "DeleteMacaroonIDRequest",
              "requestLongType": "DeleteMacaroonIDRequest",
              "requestFullType": "lnrpc.DeleteMacaroonIDRequest",
              "requestStreaming": false,
              "responseType": "DeleteMacaroonIDResponse",
              "responseLongType": "DeleteMacaroonIDResponse",
              "responseFullType": "lnrpc.DeleteMacaroonIDResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "DELETE",
                  "path": "/v1/macaroon/{root_key_id}",
                  "details": {
                    "operationId": "Lightning_DeleteMacaroonID",
                    "parameters": [
                      {
                        "description": "The root key ID to be removed.",
                        "format": "uint64",
                        "in": "path",
                        "name": "root_key_id",
                        "required": true,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcDeleteMacaroonIDResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `deletemacaroonid`\nDeleteMacaroonID deletes the specified macaroon ID and invalidates all\nmacaroons derived from that ID.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ListPermissions",
              "description": "lncli: `listpermissions`\nListPermissions lists all RPC method URIs and their required macaroon\npermissions to access them.",
              "requestType": "ListPermissionsRequest",
              "requestLongType": "ListPermissionsRequest",
              "requestFullType": "lnrpc.ListPermissionsRequest",
              "requestStreaming": false,
              "responseType": "ListPermissionsResponse",
              "responseLongType": "ListPermissionsResponse",
              "responseFullType": "lnrpc.ListPermissionsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/macaroon/permissions",
                  "details": {
                    "operationId": "Lightning_ListPermissions",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcListPermissionsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `listpermissions`\nListPermissions lists all RPC method URIs and their required macaroon\npermissions to access them.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "CheckMacaroonPermissions",
              "description": "CheckMacaroonPermissions checks whether a request follows the constraints\nimposed on the macaroon and that the macaroon is authorized to follow the\nprovided permissions.",
              "requestType": "CheckMacPermRequest",
              "requestLongType": "CheckMacPermRequest",
              "requestFullType": "lnrpc.CheckMacPermRequest",
              "requestStreaming": false,
              "responseType": "CheckMacPermResponse",
              "responseLongType": "CheckMacPermResponse",
              "responseFullType": "lnrpc.CheckMacPermResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/macaroon/checkpermissions",
                  "details": {
                    "operationId": "Lightning_CheckMacaroonPermissions",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcCheckMacPermRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcCheckMacPermResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "CheckMacaroonPermissions checks whether a request follows the constraints\nimposed on the macaroon and that the macaroon is authorized to follow the\nprovided permissions.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "RegisterRPCMiddleware",
              "description": "RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A\ngRPC middleware is software component external to lnd that aims to add\nadditional business logic to lnd by observing/intercepting/validating\nincoming gRPC client requests and (if needed) replacing/overwriting outgoing\nmessages before they're sent to the client. When registering the middleware\nmust identify itself and indicate what custom macaroon caveats it wants to\nbe responsible for. Only requests that contain a macaroon with that specific\ncustom caveat are then sent to the middleware for inspection. The other\noption is to register for the read-only mode in which all requests/responses\nare forwarded for interception to the middleware but the middleware is not\nallowed to modify any responses. As a security measure, _no_ middleware can\nmodify responses for requests made with _unencumbered_ macaroons!",
              "requestType": "RPCMiddlewareResponse",
              "requestLongType": "RPCMiddlewareResponse",
              "requestFullType": "lnrpc.RPCMiddlewareResponse",
              "requestStreaming": true,
              "responseType": "RPCMiddlewareRequest",
              "responseLongType": "RPCMiddlewareRequest",
              "responseFullType": "lnrpc.RPCMiddlewareRequest",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/middleware",
                  "details": {
                    "operationId": "Lightning_RegisterRPCMiddleware",
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcRPCMiddlewareRequest"
                            }
                          },
                          "title": "Stream result of lnrpcRPCMiddlewareRequest",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A\ngRPC middleware is software component external to lnd that aims to add\nadditional business logic to lnd by observing/intercepting/validating\nincoming gRPC client requests and (if needed) replacing/overwriting outgoing\nmessages before they're sent to the client. When registering the middleware\nmust identify itself and indicate what custom macaroon caveats it wants to\nbe responsible for. Only requests that contain a macaroon with that specific\ncustom caveat are then sent to the middleware for inspection. The other\noption is to register for the read-only mode in which all requests/responses\nare forwarded for interception to the middleware but the middleware is not\nallowed to modify any responses. As a security measure, _no_ middleware can\nmodify responses for requests made with _unencumbered_ macaroons!",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SendCustomMessage",
              "description": "lncli: `sendcustom`\nSendCustomMessage sends a custom peer message.",
              "requestType": "SendCustomMessageRequest",
              "requestLongType": "SendCustomMessageRequest",
              "requestFullType": "lnrpc.SendCustomMessageRequest",
              "requestStreaming": false,
              "responseType": "SendCustomMessageResponse",
              "responseLongType": "SendCustomMessageResponse",
              "responseFullType": "lnrpc.SendCustomMessageResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v1/custommessage",
                  "details": {
                    "operationId": "Lightning_SendCustomMessage",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/lnrpcSendCustomMessageRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcSendCustomMessageResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `sendcustom`\nSendCustomMessage sends a custom peer message.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SubscribeCustomMessages",
              "description": "lncli: `subscribecustom`\nSubscribeCustomMessages subscribes to a stream of incoming custom peer\nmessages.",
              "requestType": "SubscribeCustomMessagesRequest",
              "requestLongType": "SubscribeCustomMessagesRequest",
              "requestFullType": "lnrpc.SubscribeCustomMessagesRequest",
              "requestStreaming": false,
              "responseType": "CustomMessage",
              "responseLongType": "CustomMessage",
              "responseFullType": "lnrpc.CustomMessage",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/custommessage/subscribe",
                  "details": {
                    "operationId": "Lightning_SubscribeCustomMessages",
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcCustomMessage"
                            }
                          },
                          "title": "Stream result of lnrpcCustomMessage",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: `subscribecustom`\nSubscribeCustomMessages subscribes to a stream of incoming custom peer\nmessages.",
                    "tags": [
                      "Lightning"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "wtclientrpc/wtclient.proto",
      "description": "",
      "package": "wtclientrpc",
      "hasEnums": true,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [
        {
          "name": "PolicyType",
          "longName": "PolicyType",
          "fullName": "wtclientrpc.PolicyType",
          "description": "",
          "values": [
            {
              "name": "LEGACY",
              "number": "0",
              "description": "Selects the policy from the legacy tower client."
            },
            {
              "name": "ANCHOR",
              "number": "1",
              "description": "Selects the policy from the anchor tower client."
            }
          ]
        }
      ],
      "extensions": [],
      "messages": [
        {
          "name": "AddTowerRequest",
          "longName": "AddTowerRequest",
          "fullName": "wtclientrpc.AddTowerRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pubkey",
              "description": "The identifying public key of the watchtower to add.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "address",
              "description": "A network address the watchtower is reachable over.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "AddTowerResponse",
          "longName": "AddTowerResponse",
          "fullName": "wtclientrpc.AddTowerResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "GetTowerInfoRequest",
          "longName": "GetTowerInfoRequest",
          "fullName": "wtclientrpc.GetTowerInfoRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pubkey",
              "description": "The identifying public key of the watchtower to retrieve information for.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "include_sessions",
              "description": "Whether we should include sessions with the watchtower in the response.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListTowersRequest",
          "longName": "ListTowersRequest",
          "fullName": "wtclientrpc.ListTowersRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "include_sessions",
              "description": "Whether we should include sessions with the watchtower in the response.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ListTowersResponse",
          "longName": "ListTowersResponse",
          "fullName": "wtclientrpc.ListTowersResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "towers",
              "description": "The list of watchtowers available for new backups.",
              "label": "repeated",
              "type": "Tower",
              "longType": "Tower",
              "fullType": "wtclientrpc.Tower",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PolicyRequest",
          "longName": "PolicyRequest",
          "fullName": "wtclientrpc.PolicyRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "policy_type",
              "description": "The client type from which to retrieve the active offering policy.",
              "label": "",
              "type": "PolicyType",
              "longType": "PolicyType",
              "fullType": "wtclientrpc.PolicyType",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "PolicyResponse",
          "longName": "PolicyResponse",
          "fullName": "wtclientrpc.PolicyResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "max_updates",
              "description": "The maximum number of updates each session we negotiate with watchtowers\nshould allow.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sweep_sat_per_byte",
              "description": "Deprecated, use sweep_sat_per_vbyte.\nThe fee rate, in satoshis per vbyte, that will be used by watchtowers for\njustice transactions in response to channel breaches.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "sweep_sat_per_vbyte",
              "description": "The fee rate, in satoshis per vbyte, that will be used by watchtowers for\njustice transactions in response to channel breaches.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "RemoveTowerRequest",
          "longName": "RemoveTowerRequest",
          "fullName": "wtclientrpc.RemoveTowerRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pubkey",
              "description": "The identifying public key of the watchtower to remove.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "address",
              "description": "If set, then the record for this address will be removed, indicating that is\nis stale. Otherwise, the watchtower will no longer be used for future\nsession negotiations and backups.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "RemoveTowerResponse",
          "longName": "RemoveTowerResponse",
          "fullName": "wtclientrpc.RemoveTowerResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "StatsRequest",
          "longName": "StatsRequest",
          "fullName": "wtclientrpc.StatsRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "StatsResponse",
          "longName": "StatsResponse",
          "fullName": "wtclientrpc.StatsResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "num_backups",
              "description": "The total number of backups made to all active and exhausted watchtower\nsessions.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_pending_backups",
              "description": "The total number of backups that are pending to be acknowledged by all\nactive and exhausted watchtower sessions.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_failed_backups",
              "description": "The total number of backups that all active and exhausted watchtower\nsessions have failed to acknowledge.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_sessions_acquired",
              "description": "The total number of new sessions made to watchtowers.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_sessions_exhausted",
              "description": "The total number of watchtower sessions that have been exhausted.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "Tower",
          "longName": "Tower",
          "fullName": "wtclientrpc.Tower",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pubkey",
              "description": "The identifying public key of the watchtower.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "addresses",
              "description": "The list of addresses the watchtower is reachable over.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "active_session_candidate",
              "description": "Whether the watchtower is currently a candidate for new sessions.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_sessions",
              "description": "The number of sessions that have been negotiated with the watchtower.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sessions",
              "description": "The list of sessions that have been negotiated with the watchtower.",
              "label": "repeated",
              "type": "TowerSession",
              "longType": "TowerSession",
              "fullType": "wtclientrpc.TowerSession",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "TowerSession",
          "longName": "TowerSession",
          "fullName": "wtclientrpc.TowerSession",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "num_backups",
              "description": "The total number of successful backups that have been made to the\nwatchtower session.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "num_pending_backups",
              "description": "The total number of backups in the session that are currently pending to be\nacknowledged by the watchtower.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "max_backups",
              "description": "The maximum number of backups allowed by the watchtower session.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "sweep_sat_per_byte",
              "description": "Deprecated, use sweep_sat_per_vbyte.\nThe fee rate, in satoshis per vbyte, that will be used by the watchtower for\nthe justice transaction in the event of a channel breach.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": "",
              "options": {
                "deprecated": true
              }
            },
            {
              "name": "sweep_sat_per_vbyte",
              "description": "The fee rate, in satoshis per vbyte, that will be used by the watchtower for\nthe justice transaction in the event of a channel breach.",
              "label": "",
              "type": "uint32",
              "longType": "uint32",
              "fullType": "uint32",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": [
        {
          "name": "WatchtowerClient",
          "longName": "WatchtowerClient",
          "fullName": "wtclientrpc.WatchtowerClient",
          "description": "WatchtowerClient is a service that grants access to the watchtower client\nfunctionality of the daemon.",
          "methods": [
            {
              "name": "AddTower",
              "description": "AddTower adds a new watchtower reachable at the given address and\nconsiders it for new sessions. If the watchtower already exists, then\nany new addresses included will be considered when dialing it for\nsession negotiations and backups.",
              "requestType": "AddTowerRequest",
              "requestLongType": "AddTowerRequest",
              "requestFullType": "wtclientrpc.AddTowerRequest",
              "requestStreaming": false,
              "responseType": "AddTowerResponse",
              "responseLongType": "AddTowerResponse",
              "responseFullType": "wtclientrpc.AddTowerResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/watchtower/client",
                  "details": {
                    "operationId": "WatchtowerClient_AddTower",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/wtclientrpcAddTowerRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/wtclientrpcAddTowerResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "AddTower adds a new watchtower reachable at the given address and\nconsiders it for new sessions. If the watchtower already exists, then\nany new addresses included will be considered when dialing it for\nsession negotiations and backups.",
                    "tags": [
                      "WatchtowerClient"
                    ]
                  }
                }
              ]
            },
            {
              "name": "RemoveTower",
              "description": "RemoveTower removes a watchtower from being considered for future session\nnegotiations and from being used for any subsequent backups until it's added\nagain. If an address is provided, then this RPC only serves as a way of\nremoving the address from the watchtower instead.",
              "requestType": "RemoveTowerRequest",
              "requestLongType": "RemoveTowerRequest",
              "requestFullType": "wtclientrpc.RemoveTowerRequest",
              "requestStreaming": false,
              "responseType": "RemoveTowerResponse",
              "responseLongType": "RemoveTowerResponse",
              "responseFullType": "wtclientrpc.RemoveTowerResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "DELETE",
                  "path": "/v2/watchtower/client/{pubkey}",
                  "details": {
                    "operationId": "WatchtowerClient_RemoveTower",
                    "parameters": [
                      {
                        "description": "The identifying public key of the watchtower to remove.",
                        "format": "byte",
                        "in": "path",
                        "name": "pubkey",
                        "required": true,
                        "type": "string"
                      },
                      {
                        "description": "If set, then the record for this address will be removed, indicating that is\nis stale. Otherwise, the watchtower will no longer be used for future\nsession negotiations and backups.",
                        "in": "query",
                        "name": "address",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/wtclientrpcRemoveTowerResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "RemoveTower removes a watchtower from being considered for future session\nnegotiations and from being used for any subsequent backups until it's added\nagain. If an address is provided, then this RPC only serves as a way of\nremoving the address from the watchtower instead.",
                    "tags": [
                      "WatchtowerClient"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ListTowers",
              "description": "ListTowers returns the list of watchtowers registered with the client.",
              "requestType": "ListTowersRequest",
              "requestLongType": "ListTowersRequest",
              "requestFullType": "wtclientrpc.ListTowersRequest",
              "requestStreaming": false,
              "responseType": "ListTowersResponse",
              "responseLongType": "ListTowersResponse",
              "responseFullType": "wtclientrpc.ListTowersResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/watchtower/client",
                  "details": {
                    "operationId": "WatchtowerClient_ListTowers",
                    "parameters": [
                      {
                        "description": "Whether we should include sessions with the watchtower in the response.",
                        "in": "query",
                        "name": "include_sessions",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/wtclientrpcListTowersResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ListTowers returns the list of watchtowers registered with the client.",
                    "tags": [
                      "WatchtowerClient"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetTowerInfo",
              "description": "GetTowerInfo retrieves information for a registered watchtower.",
              "requestType": "GetTowerInfoRequest",
              "requestLongType": "GetTowerInfoRequest",
              "requestFullType": "wtclientrpc.GetTowerInfoRequest",
              "requestStreaming": false,
              "responseType": "Tower",
              "responseLongType": "Tower",
              "responseFullType": "wtclientrpc.Tower",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/watchtower/client/info/{pubkey}",
                  "details": {
                    "operationId": "WatchtowerClient_GetTowerInfo",
                    "parameters": [
                      {
                        "description": "The identifying public key of the watchtower to retrieve information for.",
                        "format": "byte",
                        "in": "path",
                        "name": "pubkey",
                        "required": true,
                        "type": "string"
                      },
                      {
                        "description": "Whether we should include sessions with the watchtower in the response.",
                        "in": "query",
                        "name": "include_sessions",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/wtclientrpcTower"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "GetTowerInfo retrieves information for a registered watchtower.",
                    "tags": [
                      "WatchtowerClient"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Stats",
              "description": "Stats returns the in-memory statistics of the client since startup.",
              "requestType": "StatsRequest",
              "requestLongType": "StatsRequest",
              "requestFullType": "wtclientrpc.StatsRequest",
              "requestStreaming": false,
              "responseType": "StatsResponse",
              "responseLongType": "StatsResponse",
              "responseFullType": "wtclientrpc.StatsResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/watchtower/client/stats",
                  "details": {
                    "operationId": "WatchtowerClient_Stats",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/wtclientrpcStatsResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "Stats returns the in-memory statistics of the client since startup.",
                    "tags": [
                      "WatchtowerClient"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Policy",
              "description": "Policy returns the active watchtower client policy configuration.",
              "requestType": "PolicyRequest",
              "requestLongType": "PolicyRequest",
              "requestFullType": "wtclientrpc.PolicyRequest",
              "requestStreaming": false,
              "responseType": "PolicyResponse",
              "responseLongType": "PolicyResponse",
              "responseFullType": "wtclientrpc.PolicyResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/watchtower/client/policy",
                  "details": {
                    "operationId": "WatchtowerClient_Policy",
                    "parameters": [
                      {
                        "default": "LEGACY",
                        "description": "The client type from which to retrieve the active offering policy.\n\n - LEGACY: Selects the policy from the legacy tower client.\n - ANCHOR: Selects the policy from the anchor tower client.",
                        "enum": [
                          "LEGACY",
                          "ANCHOR"
                        ],
                        "in": "query",
                        "name": "policy_type",
                        "required": false,
                        "type": "string"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/wtclientrpcPolicyResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "Policy returns the active watchtower client policy configuration.",
                    "tags": [
                      "WatchtowerClient"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "stateservice.proto",
      "description": "",
      "package": "lnrpc",
      "hasEnums": true,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [
        {
          "name": "WalletState",
          "longName": "WalletState",
          "fullName": "lnrpc.WalletState",
          "description": "",
          "values": [
            {
              "name": "NON_EXISTING",
              "number": "0",
              "description": ""
            },
            {
              "name": "LOCKED",
              "number": "1",
              "description": ""
            },
            {
              "name": "UNLOCKED",
              "number": "2",
              "description": ""
            },
            {
              "name": "RPC_ACTIVE",
              "number": "3",
              "description": ""
            },
            {
              "name": "SERVER_ACTIVE",
              "number": "4",
              "description": "SERVER_ACTIVE means that the lnd server is ready to accept calls."
            },
            {
              "name": "WAITING_TO_START",
              "number": "255",
              "description": ""
            }
          ]
        }
      ],
      "extensions": [],
      "messages": [
        {
          "name": "GetStateRequest",
          "longName": "GetStateRequest",
          "fullName": "lnrpc.GetStateRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "GetStateResponse",
          "longName": "GetStateResponse",
          "fullName": "lnrpc.GetStateResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "state",
              "description": "",
              "label": "",
              "type": "WalletState",
              "longType": "WalletState",
              "fullType": "lnrpc.WalletState",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SubscribeStateRequest",
          "longName": "SubscribeStateRequest",
          "fullName": "lnrpc.SubscribeStateRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "SubscribeStateResponse",
          "longName": "SubscribeStateResponse",
          "fullName": "lnrpc.SubscribeStateResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "state",
              "description": "",
              "label": "",
              "type": "WalletState",
              "longType": "WalletState",
              "fullType": "lnrpc.WalletState",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": [
        {
          "name": "State",
          "longName": "State",
          "fullName": "lnrpc.State",
          "description": "State service is a always running service that exposes the current state of\nthe wallet and RPC server.",
          "methods": [
            {
              "name": "SubscribeState",
              "description": "SubscribeState subscribes to the state of the wallet. The current wallet\nstate will always be delivered immediately.",
              "requestType": "SubscribeStateRequest",
              "requestLongType": "SubscribeStateRequest",
              "requestFullType": "lnrpc.SubscribeStateRequest",
              "requestStreaming": false,
              "responseType": "SubscribeStateResponse",
              "responseLongType": "SubscribeStateResponse",
              "responseFullType": "lnrpc.SubscribeStateResponse",
              "responseStreaming": true,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/state/subscribe",
                  "details": {
                    "operationId": "State_SubscribeState",
                    "responses": {
                      "200": {
                        "description": "A successful response.(streaming responses)",
                        "schema": {
                          "properties": {
                            "error": {
                              "$ref": "#/definitions/rpcStatus"
                            },
                            "result": {
                              "$ref": "#/definitions/lnrpcSubscribeStateResponse"
                            }
                          },
                          "title": "Stream result of lnrpcSubscribeStateResponse",
                          "type": "object"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SubscribeState subscribes to the state of the wallet. The current wallet\nstate will always be delivered immediately.",
                    "tags": [
                      "State"
                    ]
                  }
                }
              ]
            },
            {
              "name": "GetState",
              "description": "GetState returns the current wallet state without streaming further\nchanges.",
              "requestType": "GetStateRequest",
              "requestLongType": "GetStateRequest",
              "requestFullType": "lnrpc.GetStateRequest",
              "requestStreaming": false,
              "responseType": "GetStateResponse",
              "responseLongType": "GetStateResponse",
              "responseFullType": "lnrpc.GetStateResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v1/state",
                  "details": {
                    "operationId": "State_GetState",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/lnrpcGetStateResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "GetState returns the current wallet state without streaming further\nchanges.",
                    "tags": [
                      "State"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "autopilotrpc/autopilot.proto",
      "description": "",
      "package": "autopilotrpc",
      "hasEnums": false,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [],
      "extensions": [],
      "messages": [
        {
          "name": "ModifyStatusRequest",
          "longName": "ModifyStatusRequest",
          "fullName": "autopilotrpc.ModifyStatusRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "enable",
              "description": "Whether the autopilot agent should be enabled or not.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ModifyStatusResponse",
          "longName": "ModifyStatusResponse",
          "fullName": "autopilotrpc.ModifyStatusResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "QueryScoresRequest",
          "longName": "QueryScoresRequest",
          "fullName": "autopilotrpc.QueryScoresRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pubkeys",
              "description": "",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "ignore_local_state",
              "description": "If set, we will ignore the local channel state when calculating scores.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "QueryScoresResponse",
          "longName": "QueryScoresResponse",
          "fullName": "autopilotrpc.QueryScoresResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "results",
              "description": "",
              "label": "repeated",
              "type": "HeuristicResult",
              "longType": "QueryScoresResponse.HeuristicResult",
              "fullType": "autopilotrpc.QueryScoresResponse.HeuristicResult",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "HeuristicResult",
          "longName": "QueryScoresResponse.HeuristicResult",
          "fullName": "autopilotrpc.QueryScoresResponse.HeuristicResult",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "heuristic",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "scores",
              "description": "",
              "label": "repeated",
              "type": "ScoresEntry",
              "longType": "QueryScoresResponse.HeuristicResult.ScoresEntry",
              "fullType": "autopilotrpc.QueryScoresResponse.HeuristicResult.ScoresEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ScoresEntry",
          "longName": "QueryScoresResponse.HeuristicResult.ScoresEntry",
          "fullName": "autopilotrpc.QueryScoresResponse.HeuristicResult.ScoresEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SetScoresRequest",
          "longName": "SetScoresRequest",
          "fullName": "autopilotrpc.SetScoresRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "heuristic",
              "description": "The name of the heuristic to provide scores to.",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "scores",
              "description": "A map from hex-encoded public keys to scores. Scores must be in the range\n[0.0, 1.0].",
              "label": "repeated",
              "type": "ScoresEntry",
              "longType": "SetScoresRequest.ScoresEntry",
              "fullType": "autopilotrpc.SetScoresRequest.ScoresEntry",
              "ismap": true,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "ScoresEntry",
          "longName": "SetScoresRequest.ScoresEntry",
          "fullName": "autopilotrpc.SetScoresRequest.ScoresEntry",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "key",
              "description": "",
              "label": "",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "value",
              "description": "",
              "label": "",
              "type": "double",
              "longType": "double",
              "fullType": "double",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        },
        {
          "name": "SetScoresResponse",
          "longName": "SetScoresResponse",
          "fullName": "autopilotrpc.SetScoresResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "StatusRequest",
          "longName": "StatusRequest",
          "fullName": "autopilotrpc.StatusRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "StatusResponse",
          "longName": "StatusResponse",
          "fullName": "autopilotrpc.StatusResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "active",
              "description": "Indicates whether the autopilot is active or not.",
              "label": "",
              "type": "bool",
              "longType": "bool",
              "fullType": "bool",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": [
        {
          "name": "Autopilot",
          "longName": "Autopilot",
          "fullName": "autopilotrpc.Autopilot",
          "description": "Autopilot is a service that can be used to get information about the current\nstate of the daemon's autopilot agent, and also supply it with information\nthat can be used when deciding where to open channels.",
          "methods": [
            {
              "name": "Status",
              "description": "Status returns whether the daemon's autopilot agent is active.",
              "requestType": "StatusRequest",
              "requestLongType": "StatusRequest",
              "requestFullType": "autopilotrpc.StatusRequest",
              "requestStreaming": false,
              "responseType": "StatusResponse",
              "responseLongType": "StatusResponse",
              "responseFullType": "autopilotrpc.StatusResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/autopilot/status",
                  "details": {
                    "operationId": "Autopilot_Status",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/autopilotrpcStatusResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "Status returns whether the daemon's autopilot agent is active.",
                    "tags": [
                      "Autopilot"
                    ]
                  }
                }
              ]
            },
            {
              "name": "ModifyStatus",
              "description": "ModifyStatus is used to modify the status of the autopilot agent, like\nenabling or disabling it.",
              "requestType": "ModifyStatusRequest",
              "requestLongType": "ModifyStatusRequest",
              "requestFullType": "autopilotrpc.ModifyStatusRequest",
              "requestStreaming": false,
              "responseType": "ModifyStatusResponse",
              "responseLongType": "ModifyStatusResponse",
              "responseFullType": "autopilotrpc.ModifyStatusResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/autopilot/modify",
                  "details": {
                    "operationId": "Autopilot_ModifyStatus",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/autopilotrpcModifyStatusRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/autopilotrpcModifyStatusResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "ModifyStatus is used to modify the status of the autopilot agent, like\nenabling or disabling it.",
                    "tags": [
                      "Autopilot"
                    ]
                  }
                }
              ]
            },
            {
              "name": "QueryScores",
              "description": "QueryScores queries all available autopilot heuristics, in addition to any\nactive combination of these heruristics, for the scores they would give to\nthe given nodes.",
              "requestType": "QueryScoresRequest",
              "requestLongType": "QueryScoresRequest",
              "requestFullType": "autopilotrpc.QueryScoresRequest",
              "requestStreaming": false,
              "responseType": "QueryScoresResponse",
              "responseLongType": "QueryScoresResponse",
              "responseFullType": "autopilotrpc.QueryScoresResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/autopilot/scores",
                  "details": {
                    "operationId": "Autopilot_QueryScores",
                    "parameters": [
                      {
                        "collectionFormat": "multi",
                        "in": "query",
                        "items": {
                          "type": "string"
                        },
                        "name": "pubkeys",
                        "required": false,
                        "type": "array"
                      },
                      {
                        "description": "If set, we will ignore the local channel state when calculating scores.",
                        "in": "query",
                        "name": "ignore_local_state",
                        "required": false,
                        "type": "boolean"
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/autopilotrpcQueryScoresResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "QueryScores queries all available autopilot heuristics, in addition to any\nactive combination of these heruristics, for the scores they would give to\nthe given nodes.",
                    "tags": [
                      "Autopilot"
                    ]
                  }
                }
              ]
            },
            {
              "name": "SetScores",
              "description": "SetScores attempts to set the scores used by the running autopilot agent,\nif the external scoring heuristic is enabled.",
              "requestType": "SetScoresRequest",
              "requestLongType": "SetScoresRequest",
              "requestFullType": "autopilotrpc.SetScoresRequest",
              "requestStreaming": false,
              "responseType": "SetScoresResponse",
              "responseLongType": "SetScoresResponse",
              "responseFullType": "autopilotrpc.SetScoresResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "POST",
                  "path": "/v2/autopilot/scores",
                  "details": {
                    "operationId": "Autopilot_SetScores",
                    "parameters": [
                      {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                          "$ref": "#/definitions/autopilotrpcSetScoresRequest"
                        }
                      }
                    ],
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/autopilotrpcSetScoresResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "SetScores attempts to set the scores used by the running autopilot agent,\nif the external scoring heuristic is enabled.",
                    "tags": [
                      "Autopilot"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "watchtowerrpc/watchtower.proto",
      "description": "",
      "package": "watchtowerrpc",
      "hasEnums": false,
      "hasExtensions": false,
      "hasMessages": true,
      "hasServices": true,
      "enums": [],
      "extensions": [],
      "messages": [
        {
          "name": "GetInfoRequest",
          "longName": "GetInfoRequest",
          "fullName": "watchtowerrpc.GetInfoRequest",
          "description": "",
          "hasExtensions": false,
          "hasFields": false,
          "hasOneofs": false,
          "extensions": [],
          "fields": []
        },
        {
          "name": "GetInfoResponse",
          "longName": "GetInfoResponse",
          "fullName": "watchtowerrpc.GetInfoResponse",
          "description": "",
          "hasExtensions": false,
          "hasFields": true,
          "hasOneofs": false,
          "extensions": [],
          "fields": [
            {
              "name": "pubkey",
              "description": "The public key of the watchtower.",
              "label": "",
              "type": "bytes",
              "longType": "bytes",
              "fullType": "bytes",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "listeners",
              "description": "The listening addresses of the watchtower.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            },
            {
              "name": "uris",
              "description": "The URIs of the watchtower.",
              "label": "repeated",
              "type": "string",
              "longType": "string",
              "fullType": "string",
              "ismap": false,
              "isoneof": false,
              "oneofdecl": "",
              "defaultValue": ""
            }
          ]
        }
      ],
      "services": [
        {
          "name": "Watchtower",
          "longName": "Watchtower",
          "fullName": "watchtowerrpc.Watchtower",
          "description": "Watchtower is a service that grants access to the watchtower server\nfunctionality of the daemon.",
          "methods": [
            {
              "name": "GetInfo",
              "description": "lncli: tower info\nGetInfo returns general information concerning the companion watchtower\nincluding its public key and URIs where the server is currently\nlistening for clients.",
              "requestType": "GetInfoRequest",
              "requestLongType": "GetInfoRequest",
              "requestFullType": "watchtowerrpc.GetInfoRequest",
              "requestStreaming": false,
              "responseType": "GetInfoResponse",
              "responseLongType": "GetInfoResponse",
              "responseFullType": "watchtowerrpc.GetInfoResponse",
              "responseStreaming": false,
              "restMappings": [
                {
                  "method": "GET",
                  "path": "/v2/watchtower/server",
                  "details": {
                    "operationId": "Watchtower_GetInfo",
                    "responses": {
                      "200": {
                        "description": "A successful response.",
                        "schema": {
                          "$ref": "#/definitions/watchtowerrpcGetInfoResponse"
                        }
                      },
                      "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                          "$ref": "#/definitions/rpcStatus"
                        }
                      }
                    },
                    "summary": "lncli: tower info\nGetInfo returns general information concerning the companion watchtower\nincluding its public key and URIs where the server is currently\nlistening for clients.",
                    "tags": [
                      "Watchtower"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "scalarValueTypes": [
    {
      "protoType": "double",
      "notes": "",
      "cppType": "double",
      "csType": "double",
      "goType": "float64",
      "javaType": "double",
      "phpType": "float",
      "pythonType": "float",
      "rubyType": "Float"
    },
    {
      "protoType": "float",
      "notes": "",
      "cppType": "float",
      "csType": "float",
      "goType": "float32",
      "javaType": "float",
      "phpType": "float",
      "pythonType": "float",
      "rubyType": "Float"
    },
    {
      "protoType": "int32",
      "notes": "Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.",
      "cppType": "int32",
      "csType": "int",
      "goType": "int32",
      "javaType": "int",
      "phpType": "integer",
      "pythonType": "int",
      "rubyType": "Bignum or Fixnum (as required)"
    },
    {
      "protoType": "int64",
      "notes": "Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.",
      "cppType": "int64",
      "csType": "long",
      "goType": "int64",
      "javaType": "long",
      "phpType": "integer/string",
      "pythonType": "int/long",
      "rubyType": "Bignum"
    },
    {
      "protoType": "uint32",
      "notes": "Uses variable-length encoding.",
      "cppType": "uint32",
      "csType": "uint",
      "goType": "uint32",
      "javaType": "int",
      "phpType": "integer",
      "pythonType": "int/long",
      "rubyType": "Bignum or Fixnum (as required)"
    },
    {
      "protoType": "uint64",
      "notes": "Uses variable-length encoding.",
      "cppType": "uint64",
      "csType": "ulong",
      "goType": "uint64",
      "javaType": "long",
      "phpType": "integer/string",
      "pythonType": "int/long",
      "rubyType": "Bignum or Fixnum (as required)"
    },
    {
      "protoType": "sint32",
      "notes": "Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.",
      "cppType": "int32",
      "csType": "int",
      "goType": "int32",
      "javaType": "int",
      "phpType": "integer",
      "pythonType": "int",
      "rubyType": "Bignum or Fixnum (as required)"
    },
    {
      "protoType": "sint64",
      "notes": "Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.",
      "cppType": "int64",
      "csType": "long",
      "goType": "int64",
      "javaType": "long",
      "phpType": "integer/string",
      "pythonType": "int/long",
      "rubyType": "Bignum"
    },
    {
      "protoType": "fixed32",
      "notes": "Always four bytes. More efficient than uint32 if values are often greater than 2^28.",
      "cppType": "uint32",
      "csType": "uint",
      "goType": "uint32",
      "javaType": "int",
      "phpType": "integer",
      "pythonType": "int",
      "rubyType": "Bignum or Fixnum (as required)"
    },
    {
      "protoType": "fixed64",
      "notes": "Always eight bytes. More efficient than uint64 if values are often greater than 2^56.",
      "cppType": "uint64",
      "csType": "ulong",
      "goType": "uint64",
      "javaType": "long",
      "phpType": "integer/string",
      "pythonType": "int/long",
      "rubyType": "Bignum"
    },
    {
      "protoType": "sfixed32",
      "notes": "Always four bytes.",
      "cppType": "int32",
      "csType": "int",
      "goType": "int32",
      "javaType": "int",
      "phpType": "integer",
      "pythonType": "int",
      "rubyType": "Bignum or Fixnum (as required)"
    },
    {
      "protoType": "sfixed64",
      "notes": "Always eight bytes.",
      "cppType": "int64",
      "csType": "long",
      "goType": "int64",
      "javaType": "long",
      "phpType": "integer/string",
      "pythonType": "int/long",
      "rubyType": "Bignum"
    },
    {
      "protoType": "bool",
      "notes": "",
      "cppType": "bool",
      "csType": "bool",
      "goType": "bool",
      "javaType": "boolean",
      "phpType": "boolean",
      "pythonType": "boolean",
      "rubyType": "TrueClass/FalseClass"
    },
    {
      "protoType": "string",
      "notes": "A string must always contain UTF-8 encoded or 7-bit ASCII text.",
      "cppType": "string",
      "csType": "string",
      "goType": "string",
      "javaType": "String",
      "phpType": "string",
      "pythonType": "str/unicode",
      "rubyType": "String (UTF-8)"
    },
    {
      "protoType": "bytes",
      "notes": "May contain any arbitrary sequence of bytes.",
      "cppType": "string",
      "csType": "ByteString",
      "goType": "[]byte",
      "javaType": "ByteString",
      "phpType": "string",
      "pythonType": "str",
      "rubyType": "String (ASCII-8BIT)"
    }
  ],
  "restTypes": {
    "ChannelCloseSummaryClosureType": {
      "default": "COOPERATIVE_CLOSE",
      "enum": [
        "COOPERATIVE_CLOSE",
        "LOCAL_FORCE_CLOSE",
        "REMOTE_FORCE_CLOSE",
        "BREACH_CLOSE",
        "FUNDING_CANCELED",
        "ABANDONED"
      ],
      "type": "string"
    },
    "ChannelEventUpdateUpdateType": {
      "default": "OPEN_CHANNEL",
      "enum": [
        "OPEN_CHANNEL",
        "CLOSED_CHANNEL",
        "ACTIVE_CHANNEL",
        "INACTIVE_CHANNEL",
        "PENDING_OPEN_CHANNEL",
        "FULLY_RESOLVED_CHANNEL"
      ],
      "type": "string"
    },
    "FailureFailureCode": {
      "default": "RESERVED",
      "description": " - RESERVED: The numbers assigned in this enumeration match the failure codes as\ndefined in BOLT #4. Because protobuf 3 requires enums to start with 0,\na RESERVED value is added.\n - INTERNAL_FAILURE: An internal error occurred.\n - UNKNOWN_FAILURE: The error source is known, but the failure itself couldn't be decoded.\n - UNREADABLE_FAILURE: An unreadable failure result is returned if the received failure message\ncannot be decrypted. In that case the error source is unknown.",
      "enum": [
        "RESERVED",
        "INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS",
        "INCORRECT_PAYMENT_AMOUNT",
        "FINAL_INCORRECT_CLTV_EXPIRY",
        "FINAL_INCORRECT_HTLC_AMOUNT",
        "FINAL_EXPIRY_TOO_SOON",
        "INVALID_REALM",
        "EXPIRY_TOO_SOON",
        "INVALID_ONION_VERSION",
        "INVALID_ONION_HMAC",
        "INVALID_ONION_KEY",
        "AMOUNT_BELOW_MINIMUM",
        "FEE_INSUFFICIENT",
        "INCORRECT_CLTV_EXPIRY",
        "CHANNEL_DISABLED",
        "TEMPORARY_CHANNEL_FAILURE",
        "REQUIRED_NODE_FEATURE_MISSING",
        "REQUIRED_CHANNEL_FEATURE_MISSING",
        "UNKNOWN_NEXT_PEER",
        "TEMPORARY_NODE_FAILURE",
        "PERMANENT_NODE_FAILURE",
        "PERMANENT_CHANNEL_FAILURE",
        "EXPIRY_TOO_FAR",
        "MPP_TIMEOUT",
        "INVALID_ONION_PAYLOAD",
        "INTERNAL_FAILURE",
        "UNKNOWN_FAILURE",
        "UNREADABLE_FAILURE"
      ],
      "type": "string"
    },
    "ForceClosedChannelAnchorState": {
      "default": "LIMBO",
      "enum": [
        "LIMBO",
        "RECOVERED",
        "LOST"
      ],
      "type": "string"
    },
    "HTLCAttemptHTLCStatus": {
      "default": "IN_FLIGHT",
      "enum": [
        "IN_FLIGHT",
        "SUCCEEDED",
        "FAILED"
      ],
      "type": "string"
    },
    "InvoiceInvoiceState": {
      "default": "OPEN",
      "enum": [
        "OPEN",
        "SETTLED",
        "CANCELED",
        "ACCEPTED"
      ],
      "type": "string"
    },
    "ListSweepsResponseTransactionIDs": {
      "properties": {
        "transaction_ids": {
          "description": "Reversed, hex-encoded string representing the transaction ids of the\nsweeps that our node has broadcast. Note that these transactions may\nnot have confirmed yet, we record sweeps on broadcast, not confirmation.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "PaymentPaymentStatus": {
      "default": "UNKNOWN",
      "enum": [
        "UNKNOWN",
        "IN_FLIGHT",
        "SUCCEEDED",
        "FAILED"
      ],
      "type": "string"
    },
    "PeerEventEventType": {
      "default": "PEER_ONLINE",
      "enum": [
        "PEER_ONLINE",
        "PEER_OFFLINE"
      ],
      "type": "string"
    },
    "PeerSyncType": {
      "default": "UNKNOWN_SYNC",
      "description": " - UNKNOWN_SYNC: Denotes that we cannot determine the peer's current sync type.\n - ACTIVE_SYNC: Denotes that we are actively receiving new graph updates from the peer.\n - PASSIVE_SYNC: Denotes that we are not receiving new graph updates from the peer.\n - PINNED_SYNC: Denotes that this peer is pinned into an active sync.",
      "enum": [
        "UNKNOWN_SYNC",
        "ACTIVE_SYNC",
        "PASSIVE_SYNC",
        "PINNED_SYNC"
      ],
      "type": "string"
    },
    "PendingChannelsResponseClosedChannel": {
      "properties": {
        "channel": {
          "$ref": "#/definitions/PendingChannelsResponsePendingChannel",
          "title": "The pending channel to be closed"
        },
        "closing_txid": {
          "title": "The transaction id of the closing transaction",
          "type": "string"
        }
      },
      "type": "object"
    },
    "PendingChannelsResponseCommitments": {
      "properties": {
        "local_commit_fee_sat": {
          "description": "The amount in satoshis calculated to be paid in fees for the local\ncommitment.",
          "format": "uint64",
          "type": "string"
        },
        "local_txid": {
          "description": "Hash of the local version of the commitment tx.",
          "type": "string"
        },
        "remote_commit_fee_sat": {
          "description": "The amount in satoshis calculated to be paid in fees for the remote\ncommitment.",
          "format": "uint64",
          "type": "string"
        },
        "remote_pending_commit_fee_sat": {
          "description": "The amount in satoshis calculated to be paid in fees for the remote\npending commitment.",
          "format": "uint64",
          "type": "string"
        },
        "remote_pending_txid": {
          "description": "Hash of the remote pending version of the commitment tx.",
          "type": "string"
        },
        "remote_txid": {
          "description": "Hash of the remote version of the commitment tx.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "PendingChannelsResponseForceClosedChannel": {
      "properties": {
        "anchor": {
          "$ref": "#/definitions/ForceClosedChannelAnchorState"
        },
        "blocks_til_maturity": {
          "description": "Remaining # of blocks until the commitment output can be swept.\nNegative values indicate how many blocks have passed since becoming\nmature.",
          "format": "int32",
          "type": "integer"
        },
        "channel": {
          "$ref": "#/definitions/PendingChannelsResponsePendingChannel",
          "title": "The pending channel to be force closed"
        },
        "closing_txid": {
          "title": "The transaction id of the closing transaction",
          "type": "string"
        },
        "limbo_balance": {
          "format": "int64",
          "title": "The balance in satoshis encumbered in this pending channel",
          "type": "string"
        },
        "maturity_height": {
          "format": "int64",
          "title": "The height at which funds can be swept into the wallet",
          "type": "integer"
        },
        "pending_htlcs": {
          "items": {
            "$ref": "#/definitions/lnrpcPendingHTLC"
          },
          "type": "array"
        },
        "recovered_balance": {
          "format": "int64",
          "title": "The total value of funds successfully recovered from this channel",
          "type": "string"
        }
      },
      "type": "object"
    },
    "PendingChannelsResponsePendingChannel": {
      "properties": {
        "capacity": {
          "format": "int64",
          "type": "string"
        },
        "chan_status_flags": {
          "description": "A set of flags showing the current state of the channel.",
          "type": "string"
        },
        "channel_point": {
          "type": "string"
        },
        "commitment_type": {
          "$ref": "#/definitions/lnrpcCommitmentType",
          "description": "The commitment type used by this channel."
        },
        "initiator": {
          "$ref": "#/definitions/lnrpcInitiator",
          "description": "The party that initiated opening the channel."
        },
        "local_balance": {
          "format": "int64",
          "type": "string"
        },
        "local_chan_reserve_sat": {
          "description": "The minimum satoshis this node is required to reserve in its\nbalance.",
          "format": "int64",
          "type": "string"
        },
        "num_forwarding_packages": {
          "description": "Total number of forwarding packages created in this channel.",
          "format": "int64",
          "type": "string"
        },
        "private": {
          "description": "Whether this channel is advertised to the network or not.",
          "type": "boolean"
        },
        "remote_balance": {
          "format": "int64",
          "type": "string"
        },
        "remote_chan_reserve_sat": {
          "description": "The minimum satoshis the other node is required to reserve in its\nbalance.",
          "format": "int64",
          "type": "string"
        },
        "remote_node_pub": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PendingChannelsResponsePendingOpenChannel": {
      "properties": {
        "channel": {
          "$ref": "#/definitions/PendingChannelsResponsePendingChannel",
          "title": "The pending channel"
        },
        "commit_fee": {
          "description": "The amount calculated to be paid in fees for the current set of\ncommitment transactions. The fee amount is persisted with the channel\nin order to allow the fee amount to be removed and recalculated with\neach channel state update, including updates that happen after a system\nrestart.",
          "format": "int64",
          "type": "string"
        },
        "commit_weight": {
          "format": "int64",
          "title": "The weight of the commitment transaction",
          "type": "string"
        },
        "fee_per_kw": {
          "description": "The required number of satoshis per kilo-weight that the requester will\npay at all times, for both the funding transaction and commitment\ntransaction. This value can later be updated once the channel is open.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "PendingChannelsResponseWaitingCloseChannel": {
      "properties": {
        "channel": {
          "$ref": "#/definitions/PendingChannelsResponsePendingChannel",
          "title": "The pending channel waiting for closing tx to confirm"
        },
        "closing_txid": {
          "title": "The transaction id of the closing transaction",
          "type": "string"
        },
        "commitments": {
          "$ref": "#/definitions/PendingChannelsResponseCommitments",
          "description": "A list of valid commitment transactions. Any of these can confirm at\nthis point."
        },
        "limbo_balance": {
          "format": "int64",
          "title": "The balance in satoshis encumbered in this channel",
          "type": "string"
        }
      },
      "type": "object"
    },
    "QueryScoresResponseHeuristicResult": {
      "properties": {
        "heuristic": {
          "type": "string"
        },
        "scores": {
          "additionalProperties": {
            "format": "double",
            "type": "number"
          },
          "type": "object"
        }
      },
      "type": "object"
    },
    "autopilotrpcModifyStatusRequest": {
      "properties": {
        "enable": {
          "description": "Whether the autopilot agent should be enabled or not.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "autopilotrpcModifyStatusResponse": {
      "type": "object"
    },
    "autopilotrpcQueryScoresResponse": {
      "properties": {
        "results": {
          "items": {
            "$ref": "#/definitions/QueryScoresResponseHeuristicResult"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "autopilotrpcSetScoresRequest": {
      "properties": {
        "heuristic": {
          "description": "The name of the heuristic to provide scores to.",
          "type": "string"
        },
        "scores": {
          "additionalProperties": {
            "format": "double",
            "type": "number"
          },
          "description": "A map from hex-encoded public keys to scores. Scores must be in the range\n[0.0, 1.0].",
          "type": "object"
        }
      },
      "type": "object"
    },
    "autopilotrpcSetScoresResponse": {
      "type": "object"
    },
    "autopilotrpcStatusResponse": {
      "properties": {
        "active": {
          "description": "Indicates whether the autopilot is active or not.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "chainrpcBlockEpoch": {
      "properties": {
        "hash": {
          "description": "The hash of the block.",
          "format": "byte",
          "type": "string"
        },
        "height": {
          "description": "The height of the block.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "chainrpcConfDetails": {
      "properties": {
        "block_hash": {
          "description": "The hash of the block in which the confirmed transaction was included in.",
          "format": "byte",
          "type": "string"
        },
        "block_height": {
          "description": "The height of the block in which the confirmed transaction was included\nin.",
          "format": "int64",
          "type": "integer"
        },
        "raw_tx": {
          "description": "The raw bytes of the confirmed transaction.",
          "format": "byte",
          "type": "string"
        },
        "tx_index": {
          "description": "The index of the confirmed transaction within the transaction.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "chainrpcConfEvent": {
      "properties": {
        "conf": {
          "$ref": "#/definitions/chainrpcConfDetails",
          "description": "An event that includes the confirmation details of the request\n(txid/ouput script)."
        },
        "reorg": {
          "$ref": "#/definitions/chainrpcReorg",
          "description": "An event send when the transaction of the request is reorged out of the\nchain."
        }
      },
      "type": "object"
    },
    "chainrpcConfRequest": {
      "properties": {
        "height_hint": {
          "description": "The earliest height in the chain for which the transaction/output script\ncould have been included in a block. This should in most cases be set to the\nbroadcast height of the transaction/output script.",
          "format": "int64",
          "type": "integer"
        },
        "num_confs": {
          "description": "The number of desired confirmations the transaction/output script should\nreach before dispatching a confirmation notification.",
          "format": "int64",
          "type": "integer"
        },
        "script": {
          "description": "An output script within a transaction with the hash above which will be used\nby light clients to match block filters. If the transaction hash is set to a\nhash of all zeros, then a confirmation notification will be requested for\nthis script instead.",
          "format": "byte",
          "type": "string"
        },
        "txid": {
          "description": "The transaction hash for which we should request a confirmation notification\nfor. If set to a hash of all zeros, then the confirmation notification will\nbe requested for the script instead.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "chainrpcOutpoint": {
      "properties": {
        "hash": {
          "description": "The hash of the transaction.",
          "format": "byte",
          "type": "string"
        },
        "index": {
          "description": "The index of the output within the transaction.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "chainrpcReorg": {
      "type": "object"
    },
    "chainrpcSpendDetails": {
      "properties": {
        "raw_spending_tx": {
          "description": "The raw bytes of the spending transaction.",
          "format": "byte",
          "type": "string"
        },
        "spending_height": {
          "description": "The height at which the spending transaction was included in a block.",
          "format": "int64",
          "type": "integer"
        },
        "spending_input_index": {
          "description": "The input of the spending transaction that fulfilled the spend request.",
          "format": "int64",
          "type": "integer"
        },
        "spending_outpoint": {
          "$ref": "#/definitions/chainrpcOutpoint",
          "description": "The outpoint was that spent."
        },
        "spending_tx_hash": {
          "description": "The hash of the spending transaction.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "chainrpcSpendEvent": {
      "properties": {
        "reorg": {
          "$ref": "#/definitions/chainrpcReorg",
          "description": "An event sent when the spending transaction of the request was\nreorged out of the chain."
        },
        "spend": {
          "$ref": "#/definitions/chainrpcSpendDetails",
          "description": "An event that includes the details of the spending transaction of the\nrequest (outpoint/output script)."
        }
      },
      "type": "object"
    },
    "chainrpcSpendRequest": {
      "properties": {
        "height_hint": {
          "description": "The earliest height in the chain for which the outpoint/output script could\nhave been spent. This should in most cases be set to the broadcast height of\nthe outpoint/output script.",
          "format": "int64",
          "type": "integer"
        },
        "outpoint": {
          "$ref": "#/definitions/chainrpcOutpoint",
          "description": "The outpoint for which we should request a spend notification for. If set to\na zero outpoint, then the spend notification will be requested for the\nscript instead. A zero or nil outpoint is not supported for Taproot spends\nbecause the output script cannot reliably be computed from the witness alone\nand the spent output script is not always available in the rescan context.\nSo an outpoint must _always_ be specified when registering a spend\nnotification for a Taproot output."
        },
        "script": {
          "description": "The output script for the outpoint above. This will be used by light clients\nto match block filters. If the outpoint is set to a zero outpoint, then a\nspend notification will be requested for this script instead.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "devrpcImportGraphResponse": {
      "type": "object"
    },
    "invoicesrpcAddHoldInvoiceRequest": {
      "properties": {
        "cltv_expiry": {
          "description": "Delta to use for the time-lock of the CLTV extended to the final hop.",
          "format": "uint64",
          "type": "string"
        },
        "description_hash": {
          "description": "Hash (SHA-256) of a description of the payment. Used if the description of\npayment (memo) is too long to naturally fit within the description field\nof an encoded payment request.",
          "format": "byte",
          "type": "string"
        },
        "expiry": {
          "description": "Payment request expiry time in seconds. Default is 3600 (1 hour).",
          "format": "int64",
          "type": "string"
        },
        "fallback_addr": {
          "description": "Fallback on-chain address.",
          "type": "string"
        },
        "hash": {
          "format": "byte",
          "title": "The hash of the preimage",
          "type": "string"
        },
        "memo": {
          "description": "An optional memo to attach along with the invoice. Used for record keeping\npurposes for the invoice's creator, and will also be set in the description\nfield of the encoded payment request if the description_hash field is not\nbeing used.",
          "type": "string"
        },
        "private": {
          "description": "Whether this invoice should include routing hints for private channels.",
          "type": "boolean"
        },
        "route_hints": {
          "description": "Route hints that can each be individually used to assist in reaching the\ninvoice's destination.",
          "items": {
            "$ref": "#/definitions/lnrpcRouteHint"
          },
          "type": "array"
        },
        "value": {
          "description": "The fields value and value_msat are mutually exclusive.",
          "format": "int64",
          "title": "The value of this invoice in satoshis",
          "type": "string"
        },
        "value_msat": {
          "description": "The fields value and value_msat are mutually exclusive.",
          "format": "int64",
          "title": "The value of this invoice in millisatoshis",
          "type": "string"
        }
      },
      "type": "object"
    },
    "invoicesrpcAddHoldInvoiceResp": {
      "properties": {
        "add_index": {
          "description": "The \"add\" index of this invoice. Each newly created invoice will increment\nthis index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all added\ninvoices with an add_index greater than this one.",
          "format": "uint64",
          "type": "string"
        },
        "payment_addr": {
          "description": "The payment address of the generated invoice. This value should be used\nin all payments for this invoice as we require it for end to end\nsecurity.",
          "format": "byte",
          "type": "string"
        },
        "payment_request": {
          "description": "A bare-bones invoice for a payment within the Lightning Network. With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "invoicesrpcCancelInvoiceMsg": {
      "properties": {
        "payment_hash": {
          "description": "Hash corresponding to the (hold) invoice to cancel. When using\nREST, this field must be encoded as base64.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "invoicesrpcCancelInvoiceResp": {
      "type": "object"
    },
    "invoicesrpcLookupModifier": {
      "default": "DEFAULT",
      "description": " - DEFAULT: The default look up modifier, no look up behavior is changed.\n - HTLC_SET_ONLY: Indicates that when a look up is done based on a set_id, then only that set\nof HTLCs related to that set ID should be returned.\n - HTLC_SET_BLANK: Indicates that when a look up is done using a payment_addr, then no HTLCs\nrelated to the payment_addr should be returned. This is useful when one\nwants to be able to obtain the set of associated setIDs with a given\ninvoice, then look up the sub-invoices \"projected\" by that set ID.",
      "enum": [
        "DEFAULT",
        "HTLC_SET_ONLY",
        "HTLC_SET_BLANK"
      ],
      "type": "string"
    },
    "invoicesrpcSettleInvoiceMsg": {
      "properties": {
        "preimage": {
          "description": "Externally discovered pre-image that should be used to settle the hold\ninvoice.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "invoicesrpcSettleInvoiceResp": {
      "type": "object"
    },
    "lnrpcAMP": {
      "description": "Details specific to AMP HTLCs.",
      "properties": {
        "child_index": {
          "description": "A nonce used to randomize the child preimage and child hash from a given\nroot_share.",
          "format": "int64",
          "type": "integer"
        },
        "hash": {
          "description": "The payment hash of the AMP HTLC.",
          "format": "byte",
          "type": "string"
        },
        "preimage": {
          "description": "The preimage used to settle this AMP htlc. This field will only be\npopulated if the invoice is in InvoiceState_ACCEPTED or\nInvoiceState_SETTLED.",
          "format": "byte",
          "type": "string"
        },
        "root_share": {
          "description": "An n-of-n secret share of the root seed from which child payment hashes\nand preimages are derived.",
          "format": "byte",
          "type": "string"
        },
        "set_id": {
          "description": "An identifier for the HTLC set that this HTLC belongs to.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcAMPInvoiceState": {
      "properties": {
        "amt_paid_msat": {
          "description": "The total amount paid for the sub-invoice expressed in milli satoshis.",
          "format": "int64",
          "type": "string"
        },
        "settle_index": {
          "description": "The settle index of this HTLC set, if the invoice state is settled.",
          "format": "uint64",
          "type": "string"
        },
        "settle_time": {
          "description": "The time this HTLC set was settled expressed in unix epoch.",
          "format": "int64",
          "type": "string"
        },
        "state": {
          "$ref": "#/definitions/lnrpcInvoiceHTLCState",
          "description": "The state the HTLCs associated with this setID are in."
        }
      },
      "type": "object"
    },
    "lnrpcAMPRecord": {
      "properties": {
        "child_index": {
          "format": "int64",
          "type": "integer"
        },
        "root_share": {
          "format": "byte",
          "type": "string"
        },
        "set_id": {
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcAbandonChannelResponse": {
      "type": "object"
    },
    "lnrpcAddInvoiceResponse": {
      "properties": {
        "add_index": {
          "description": "The \"add\" index of this invoice. Each newly created invoice will increment\nthis index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all added\ninvoices with an add_index greater than this one.",
          "format": "uint64",
          "type": "string"
        },
        "payment_addr": {
          "description": "The payment address of the generated invoice. This value should be used\nin all payments for this invoice as we require it for end to end\nsecurity.",
          "format": "byte",
          "type": "string"
        },
        "payment_request": {
          "description": "A bare-bones invoice for a payment within the Lightning Network. With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient.",
          "type": "string"
        },
        "r_hash": {
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcAddressType": {
      "default": "WITNESS_PUBKEY_HASH",
      "description": "- `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)\n- `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)\n- `p2tr`: Pay to taproot pubkey (`TAPROOT_PUBKEY` = 4)",
      "enum": [
        "WITNESS_PUBKEY_HASH",
        "NESTED_PUBKEY_HASH",
        "UNUSED_WITNESS_PUBKEY_HASH",
        "UNUSED_NESTED_PUBKEY_HASH",
        "TAPROOT_PUBKEY",
        "UNUSED_TAPROOT_PUBKEY"
      ],
      "title": "`AddressType` has to be one of:",
      "type": "string"
    },
    "lnrpcAmount": {
      "properties": {
        "msat": {
          "description": "Value denominated in milli-satoshis.",
          "format": "uint64",
          "type": "string"
        },
        "sat": {
          "description": "Value denominated in satoshis.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcBakeMacaroonRequest": {
      "properties": {
        "allow_external_permissions": {
          "description": "Informs the RPC on whether to allow external permissions that LND is not\naware of.",
          "type": "boolean"
        },
        "permissions": {
          "description": "The list of permissions the new macaroon should grant.",
          "items": {
            "$ref": "#/definitions/lnrpcMacaroonPermission"
          },
          "type": "array"
        },
        "root_key_id": {
          "description": "The root key ID used to create the macaroon, must be a positive integer.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcBakeMacaroonResponse": {
      "properties": {
        "macaroon": {
          "description": "The hex encoded macaroon, serialized in binary format.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcBatchOpenChannel": {
      "properties": {
        "close_address": {
          "description": "Close address is an optional address which specifies the address to which\nfunds should be paid out to upon cooperative close. This field may only be\nset if the peer supports the option upfront feature bit (call listpeers\nto check). The remote peer will only accept cooperative closes to this\naddress if it is set.\n\nNote: If this value is set on channel creation, you will *not* be able to\ncooperatively close out to a different address.",
          "type": "string"
        },
        "commitment_type": {
          "$ref": "#/definitions/lnrpcCommitmentType",
          "description": "The explicit commitment type to use. Note this field will only be used if\nthe remote peer supports explicit channel negotiation."
        },
        "local_funding_amount": {
          "description": "The number of satoshis the wallet should commit to the channel.",
          "format": "int64",
          "type": "string"
        },
        "min_htlc_msat": {
          "description": "The minimum value in millisatoshi we will require for incoming HTLCs on\nthe channel.",
          "format": "int64",
          "type": "string"
        },
        "node_pubkey": {
          "description": "The pubkey of the node to open a channel with. When using REST, this\nfield must be encoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "pending_chan_id": {
          "description": "An optional, unique identifier of 32 random bytes that will be used as the\npending channel ID to identify the channel while it is in the pre-pending\nstate.",
          "format": "byte",
          "type": "string"
        },
        "private": {
          "description": "Whether this channel should be private, not announced to the greater\nnetwork.",
          "type": "boolean"
        },
        "push_sat": {
          "description": "The number of satoshis to push to the remote side as part of the initial\ncommitment state.",
          "format": "int64",
          "type": "string"
        },
        "remote_csv_delay": {
          "description": "The delay we require on the remote's commitment transaction. If this is\nnot set, it will be scaled automatically with the channel size.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcBatchOpenChannelRequest": {
      "properties": {
        "channels": {
          "description": "The list of channels to open.",
          "items": {
            "$ref": "#/definitions/lnrpcBatchOpenChannel"
          },
          "type": "array"
        },
        "label": {
          "description": "An optional label for the batch transaction, limited to 500 characters.",
          "type": "string"
        },
        "min_confs": {
          "description": "The minimum number of confirmations each one of your outputs used for\nthe funding transaction must satisfy.",
          "format": "int32",
          "type": "integer"
        },
        "sat_per_vbyte": {
          "description": "A manual fee rate set in sat/vByte that should be used when crafting the\nfunding transaction.",
          "format": "int64",
          "type": "string"
        },
        "spend_unconfirmed": {
          "description": "Whether unconfirmed outputs should be used as inputs for the funding\ntransaction.",
          "type": "boolean"
        },
        "target_conf": {
          "description": "The target number of blocks that the funding transaction should be\nconfirmed by.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcBatchOpenChannelResponse": {
      "properties": {
        "pending_channels": {
          "items": {
            "$ref": "#/definitions/lnrpcPendingUpdate"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcChain": {
      "properties": {
        "chain": {
          "title": "The blockchain the node is on (eg bitcoin, litecoin)",
          "type": "string"
        },
        "network": {
          "title": "The network the node is on (eg regtest, testnet, mainnet)",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcChanBackupSnapshot": {
      "properties": {
        "multi_chan_backup": {
          "$ref": "#/definitions/lnrpcMultiChanBackup",
          "description": "A multi-channel backup that covers all open channels currently known to\nlnd."
        },
        "single_chan_backups": {
          "$ref": "#/definitions/lnrpcChannelBackups",
          "description": "The set of new channels that have been added since the last channel backup\nsnapshot was requested."
        }
      },
      "type": "object"
    },
    "lnrpcChanPointShim": {
      "properties": {
        "amt": {
          "description": "The size of the pre-crafted output to be used as the channel point for this\nchannel funding.",
          "format": "int64",
          "type": "string"
        },
        "chan_point": {
          "$ref": "#/definitions/lnrpcChannelPoint",
          "description": "The target channel point to refrence in created commitment transactions."
        },
        "local_key": {
          "$ref": "#/definitions/lnrpcKeyDescriptor",
          "description": "Our local key to use when creating the multi-sig output."
        },
        "pending_chan_id": {
          "description": "If non-zero, then this will be used as the pending channel ID on the wire\nprotocol to initate the funding request. This is an optional field, and\nshould only be set if the responder is already expecting a specific pending\nchannel ID.",
          "format": "byte",
          "type": "string"
        },
        "remote_key": {
          "description": "The key of the remote party to use when creating the multi-sig output.",
          "format": "byte",
          "type": "string"
        },
        "thaw_height": {
          "description": "This uint32 indicates if this channel is to be considered 'frozen'. A frozen\nchannel does not allow a cooperative channel close by the initiator. The\nthaw_height is the height that this restriction stops applying to the\nchannel. The height can be interpreted in two ways: as a relative height if\nthe value is less than 500,000, or as an absolute height otherwise.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcChangePasswordRequest": {
      "properties": {
        "current_password": {
          "description": "current_password should be the current valid passphrase used to unlock the\ndaemon. When using REST, this field must be encoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "new_macaroon_root_key": {
          "description": "new_macaroon_root_key is an optional argument instructing the daemon to\nrotate the macaroon root key when set to true. This will invalidate all\npreviously generated macaroons.",
          "type": "boolean"
        },
        "new_password": {
          "description": "new_password should be the new passphrase that will be needed to unlock the\ndaemon. When using REST, this field must be encoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "stateless_init": {
          "title": "stateless_init is an optional argument instructing the daemon NOT to create\nany *.macaroon files in its filesystem. If this parameter is set, then the\nadmin macaroon returned in the response MUST be stored by the caller of the\nRPC as otherwise all access to the daemon will be lost!",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcChangePasswordResponse": {
      "properties": {
        "admin_macaroon": {
          "description": "The binary serialized admin macaroon that can be used to access the daemon\nafter rotating the macaroon root key. If both the stateless_init and\nnew_macaroon_root_key parameter were set to true, this is the ONLY copy of\nthe macaroon that was created from the new root key and MUST be stored\nsafely by the caller. Otherwise a copy of this macaroon is also persisted on\ndisk by the daemon, together with other macaroon files.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcChannel": {
      "properties": {
        "active": {
          "title": "Whether this channel is active or not",
          "type": "boolean"
        },
        "capacity": {
          "format": "int64",
          "title": "The total amount of funds held in this channel",
          "type": "string"
        },
        "chan_id": {
          "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel.",
          "format": "uint64",
          "type": "string"
        },
        "chan_status_flags": {
          "description": "A set of flags showing the current state of the channel.",
          "type": "string"
        },
        "channel_point": {
          "description": "The outpoint (txid:index) of the funding transaction. With this value, Bob\nwill be able to generate a signature for Alice's version of the commitment\ntransaction.",
          "type": "string"
        },
        "close_address": {
          "description": "Close address is the address that we will enforce payout to on cooperative\nclose if the channel was opened utilizing option upfront shutdown. This\nvalue can be set on channel open by setting close_address in an open channel\nrequest. If this value is not set, you can still choose a payout address by\ncooperatively closing with the delivery_address field set.",
          "type": "string"
        },
        "commit_fee": {
          "description": "The amount calculated to be paid in fees for the current set of commitment\ntransactions. The fee amount is persisted with the channel in order to\nallow the fee amount to be removed and recalculated with each channel state\nupdate, including updates that happen after a system restart.",
          "format": "int64",
          "type": "string"
        },
        "commit_weight": {
          "format": "int64",
          "title": "The weight of the commitment transaction",
          "type": "string"
        },
        "commitment_type": {
          "$ref": "#/definitions/lnrpcCommitmentType",
          "description": "The commitment type used by this channel."
        },
        "csv_delay": {
          "description": "Deprecated. The CSV delay expressed in relative blocks. If the channel is\nforce closed, we will need to wait for this many blocks before we can regain\nour funds.",
          "format": "int64",
          "type": "integer"
        },
        "fee_per_kw": {
          "description": "The required number of satoshis per kilo-weight that the requester will pay\nat all times, for both the funding transaction and commitment transaction.\nThis value can later be updated once the channel is open.",
          "format": "int64",
          "type": "string"
        },
        "initiator": {
          "description": "True if we were the ones that created the channel.",
          "type": "boolean"
        },
        "lifetime": {
          "description": "The number of seconds that the channel has been monitored by the channel\nscoring system. Scores are currently not persisted, so this value may be\nless than the lifetime of the channel [EXPERIMENTAL].",
          "format": "int64",
          "type": "string"
        },
        "local_balance": {
          "format": "int64",
          "title": "This node's current balance in this channel",
          "type": "string"
        },
        "local_chan_reserve_sat": {
          "description": "Deprecated. The minimum satoshis this node is required to reserve in its\nbalance.",
          "format": "int64",
          "type": "string"
        },
        "local_constraints": {
          "$ref": "#/definitions/lnrpcChannelConstraints",
          "description": "List constraints for the local node."
        },
        "num_updates": {
          "description": "The total number of updates conducted within this channel.",
          "format": "uint64",
          "type": "string"
        },
        "pending_htlcs": {
          "description": "The list of active, uncleared HTLCs currently pending within the channel.",
          "items": {
            "$ref": "#/definitions/lnrpcHTLC"
          },
          "type": "array"
        },
        "private": {
          "description": "Whether this channel is advertised to the network or not.",
          "type": "boolean"
        },
        "push_amount_sat": {
          "description": "The amount that the initiator of the channel optionally pushed to the remote\nparty on channel open. This amount will be zero if the channel initiator did\nnot push any funds to the remote peer. If the initiator field is true, we\npushed this amount to our peer, if it is false, the remote peer pushed this\namount to us.",
          "format": "uint64",
          "type": "string"
        },
        "remote_balance": {
          "format": "int64",
          "title": "The counterparty's current balance in this channel",
          "type": "string"
        },
        "remote_chan_reserve_sat": {
          "description": "Deprecated. The minimum satoshis the other node is required to reserve in\nits balance.",
          "format": "int64",
          "type": "string"
        },
        "remote_constraints": {
          "$ref": "#/definitions/lnrpcChannelConstraints",
          "description": "List constraints for the remote node."
        },
        "remote_pubkey": {
          "title": "The identity pubkey of the remote node",
          "type": "string"
        },
        "static_remote_key": {
          "description": "Deprecated. Use commitment_type.",
          "type": "boolean"
        },
        "thaw_height": {
          "description": "This uint32 indicates if this channel is to be considered 'frozen'. A\nfrozen channel doest not allow a cooperative channel close by the\ninitiator. The thaw_height is the height that this restriction stops\napplying to the channel. This field is optional, not setting it or using a\nvalue of zero will mean the channel has no additional restrictions. The\nheight can be interpreted in two ways: as a relative height if the value is\nless than 500,000, or as an absolute height otherwise.",
          "format": "int64",
          "type": "integer"
        },
        "total_satoshis_received": {
          "description": "The total number of satoshis we've received within this channel.",
          "format": "int64",
          "type": "string"
        },
        "total_satoshis_sent": {
          "description": "The total number of satoshis we've sent within this channel.",
          "format": "int64",
          "type": "string"
        },
        "unsettled_balance": {
          "format": "int64",
          "title": "The unsettled balance in this channel",
          "type": "string"
        },
        "uptime": {
          "description": "The number of seconds that the remote peer has been observed as being online\nby the channel scoring system over the lifetime of the channel\n[EXPERIMENTAL].",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcChannelAcceptRequest": {
      "properties": {
        "chain_hash": {
          "description": "The hash of the genesis block that the proposed channel resides in.",
          "format": "byte",
          "type": "string"
        },
        "channel_flags": {
          "description": "A bit-field which the initiator uses to specify proposed channel\nbehavior.",
          "format": "int64",
          "type": "integer"
        },
        "channel_reserve": {
          "description": "The minimum amount of satoshis the initiator requires us to have at all\ntimes.",
          "format": "uint64",
          "type": "string"
        },
        "commitment_type": {
          "$ref": "#/definitions/lnrpcCommitmentType",
          "description": "The commitment type the initiator wishes to use for the proposed channel."
        },
        "csv_delay": {
          "description": "The number of blocks to use for the relative time lock in the pay-to-self\noutput of both commitment transactions.",
          "format": "int64",
          "type": "integer"
        },
        "dust_limit": {
          "description": "The dust limit of the initiator's commitment tx.",
          "format": "uint64",
          "type": "string"
        },
        "fee_per_kw": {
          "description": "The initial fee rate that the initiator suggests for both commitment\ntransactions.",
          "format": "uint64",
          "type": "string"
        },
        "funding_amt": {
          "description": "The funding amount in satoshis that initiator wishes to use in the\nchannel.",
          "format": "uint64",
          "type": "string"
        },
        "max_accepted_htlcs": {
          "description": "The total number of incoming HTLC's that the initiator will accept.",
          "format": "int64",
          "type": "integer"
        },
        "max_value_in_flight": {
          "description": "The maximum amount of coins in millisatoshis that can be pending in this\nchannel.",
          "format": "uint64",
          "type": "string"
        },
        "min_htlc": {
          "description": "The smallest HTLC in millisatoshis that the initiator will accept.",
          "format": "uint64",
          "type": "string"
        },
        "node_pubkey": {
          "description": "The pubkey of the node that wishes to open an inbound channel.",
          "format": "byte",
          "type": "string"
        },
        "pending_chan_id": {
          "description": "The pending channel id.",
          "format": "byte",
          "type": "string"
        },
        "push_amt": {
          "description": "The push amount of the proposed channel in millisatoshis.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcChannelAcceptResponse": {
      "properties": {
        "accept": {
          "description": "Whether or not the client accepts the channel.",
          "type": "boolean"
        },
        "csv_delay": {
          "description": "The csv delay (in blocks) that we require for the remote party.",
          "format": "int64",
          "type": "integer"
        },
        "error": {
          "description": "An optional error to send the initiating party to indicate why the channel\nwas rejected. This field *should not* contain sensitive information, it will\nbe sent to the initiating party. This field should only be set if accept is\nfalse, the channel will be rejected if an error is set with accept=true\nbecause the meaning of this response is ambiguous. Limited to 500\ncharacters.",
          "type": "string"
        },
        "in_flight_max_msat": {
          "description": "The maximum amount of funds in millisatoshis that we allow the remote peer\nto have in outstanding htlcs.",
          "format": "uint64",
          "type": "string"
        },
        "max_htlc_count": {
          "description": "The maximum number of htlcs that the remote peer can offer us.",
          "format": "int64",
          "type": "integer"
        },
        "min_accept_depth": {
          "description": "The number of confirmations we require before we consider the channel open.",
          "format": "int64",
          "type": "integer"
        },
        "min_htlc_in": {
          "description": "The minimum value in millisatoshis for incoming htlcs on the channel.",
          "format": "uint64",
          "type": "string"
        },
        "pending_chan_id": {
          "description": "The pending channel id to which this response applies.",
          "format": "byte",
          "type": "string"
        },
        "reserve_sat": {
          "description": "The reserve amount in satoshis that we require the remote peer to adhere to.\nWe require that the remote peer always have some reserve amount allocated to\nthem so that there is always a disincentive to broadcast old state (if they\nhold 0 sats on their side of the channel, there is nothing to lose).",
          "format": "uint64",
          "type": "string"
        },
        "upfront_shutdown": {
          "description": "The upfront shutdown address to use if the initiating peer supports option\nupfront shutdown script (see ListPeers for the features supported). Note\nthat the channel open will fail if this value is set for a peer that does\nnot support this feature bit.",
          "type": "string"
        },
        "zero_conf": {
          "description": "Whether the responder wants this to be a zero-conf channel. This will fail\nif either side does not have the scid-alias feature bit set. The minimum\ndepth field must be zero if this is true.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcChannelBackup": {
      "properties": {
        "chan_backup": {
          "description": "Is an encrypted single-chan backup. this can be passed to\nRestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in\norder to trigger the recovery protocol. When using REST, this field must be\nencoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "chan_point": {
          "$ref": "#/definitions/lnrpcChannelPoint",
          "description": "Identifies the channel that this backup belongs to."
        }
      },
      "type": "object"
    },
    "lnrpcChannelBackups": {
      "properties": {
        "chan_backups": {
          "description": "A set of single-chan static channel backups.",
          "items": {
            "$ref": "#/definitions/lnrpcChannelBackup"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcChannelBalanceResponse": {
      "properties": {
        "balance": {
          "format": "int64",
          "title": "Deprecated. Sum of channels balances denominated in satoshis",
          "type": "string"
        },
        "local_balance": {
          "$ref": "#/definitions/lnrpcAmount",
          "description": "Sum of channels local balances."
        },
        "pending_open_balance": {
          "format": "int64",
          "title": "Deprecated. Sum of channels pending balances denominated in satoshis",
          "type": "string"
        },
        "pending_open_local_balance": {
          "$ref": "#/definitions/lnrpcAmount",
          "description": "Sum of channels pending local balances."
        },
        "pending_open_remote_balance": {
          "$ref": "#/definitions/lnrpcAmount",
          "description": "Sum of channels pending remote balances."
        },
        "remote_balance": {
          "$ref": "#/definitions/lnrpcAmount",
          "description": "Sum of channels remote balances."
        },
        "unsettled_local_balance": {
          "$ref": "#/definitions/lnrpcAmount",
          "description": "Sum of channels local unsettled balances."
        },
        "unsettled_remote_balance": {
          "$ref": "#/definitions/lnrpcAmount",
          "description": "Sum of channels remote unsettled balances."
        }
      },
      "type": "object"
    },
    "lnrpcChannelCloseSummary": {
      "properties": {
        "capacity": {
          "description": "Total capacity of the channel.",
          "format": "int64",
          "type": "string"
        },
        "chain_hash": {
          "description": "The hash of the genesis block that this channel resides within.",
          "type": "string"
        },
        "chan_id": {
          "description": "The unique channel ID for the channel.",
          "format": "uint64",
          "type": "string"
        },
        "channel_point": {
          "description": "The outpoint (txid:index) of the funding transaction.",
          "type": "string"
        },
        "close_height": {
          "description": "Height at which the funding transaction was spent.",
          "format": "int64",
          "type": "integer"
        },
        "close_initiator": {
          "$ref": "#/definitions/lnrpcInitiator",
          "description": "Close initiator indicates which party initiated the close. This value will\nbe unknown for channels that were cooperatively closed before we started\ntracking cooperative close initiators. Note that this indicates which party\ninitiated a close, and it is possible for both to initiate cooperative or\nforce closes, although only one party's close will be confirmed on chain."
        },
        "close_type": {
          "$ref": "#/definitions/ChannelCloseSummaryClosureType",
          "description": "Details on how the channel was closed."
        },
        "closing_tx_hash": {
          "description": "The txid of the transaction which ultimately closed this channel.",
          "type": "string"
        },
        "open_initiator": {
          "$ref": "#/definitions/lnrpcInitiator",
          "description": "Open initiator is the party that initiated opening the channel. Note that\nthis value may be unknown if the channel was closed before we migrated to\nstore open channel information after close."
        },
        "remote_pubkey": {
          "description": "Public key of the remote peer that we formerly had a channel with.",
          "type": "string"
        },
        "resolutions": {
          "items": {
            "$ref": "#/definitions/lnrpcResolution"
          },
          "type": "array"
        },
        "settled_balance": {
          "format": "int64",
          "title": "Settled balance at the time of channel closure",
          "type": "string"
        },
        "time_locked_balance": {
          "format": "int64",
          "title": "The sum of all the time-locked outputs at the time of channel closure",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcChannelCloseUpdate": {
      "properties": {
        "closing_txid": {
          "format": "byte",
          "type": "string"
        },
        "success": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcChannelConstraints": {
      "properties": {
        "chan_reserve_sat": {
          "description": "The minimum satoshis this node is required to reserve in its balance.",
          "format": "uint64",
          "type": "string"
        },
        "csv_delay": {
          "description": "The CSV delay expressed in relative blocks. If the channel is force closed,\nwe will need to wait for this many blocks before we can regain our funds.",
          "format": "int64",
          "type": "integer"
        },
        "dust_limit_sat": {
          "description": "The dust limit (in satoshis) of the initiator's commitment tx.",
          "format": "uint64",
          "type": "string"
        },
        "max_accepted_htlcs": {
          "description": "The total number of incoming HTLC's that the initiator will accept.",
          "format": "int64",
          "type": "integer"
        },
        "max_pending_amt_msat": {
          "description": "The maximum amount of coins in millisatoshis that can be pending in this\nchannel.",
          "format": "uint64",
          "type": "string"
        },
        "min_htlc_msat": {
          "description": "The smallest HTLC in millisatoshis that the initiator will accept.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcChannelEdge": {
      "description": "A fully authenticated channel along with all its unique attributes.\nOnce an authenticated channel announcement has been processed on the network,\nthen an instance of ChannelEdgeInfo encapsulating the channels attributes is\nstored. The other portions relevant to routing policy of a channel are stored\nwithin a ChannelEdgePolicy for each direction of the channel.",
      "properties": {
        "capacity": {
          "format": "int64",
          "type": "string"
        },
        "chan_point": {
          "type": "string"
        },
        "channel_id": {
          "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel.",
          "format": "uint64",
          "type": "string"
        },
        "last_update": {
          "format": "int64",
          "type": "integer"
        },
        "node1_policy": {
          "$ref": "#/definitions/lnrpcRoutingPolicy"
        },
        "node1_pub": {
          "type": "string"
        },
        "node2_policy": {
          "$ref": "#/definitions/lnrpcRoutingPolicy"
        },
        "node2_pub": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcChannelEdgeUpdate": {
      "properties": {
        "advertising_node": {
          "type": "string"
        },
        "capacity": {
          "format": "int64",
          "type": "string"
        },
        "chan_id": {
          "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel.",
          "format": "uint64",
          "type": "string"
        },
        "chan_point": {
          "$ref": "#/definitions/lnrpcChannelPoint"
        },
        "connecting_node": {
          "type": "string"
        },
        "routing_policy": {
          "$ref": "#/definitions/lnrpcRoutingPolicy"
        }
      },
      "type": "object"
    },
    "lnrpcChannelEventUpdate": {
      "properties": {
        "active_channel": {
          "$ref": "#/definitions/lnrpcChannelPoint"
        },
        "closed_channel": {
          "$ref": "#/definitions/lnrpcChannelCloseSummary"
        },
        "fully_resolved_channel": {
          "$ref": "#/definitions/lnrpcChannelPoint"
        },
        "inactive_channel": {
          "$ref": "#/definitions/lnrpcChannelPoint"
        },
        "open_channel": {
          "$ref": "#/definitions/lnrpcChannel"
        },
        "pending_open_channel": {
          "$ref": "#/definitions/lnrpcPendingUpdate"
        },
        "type": {
          "$ref": "#/definitions/ChannelEventUpdateUpdateType"
        }
      },
      "type": "object"
    },
    "lnrpcChannelFeeReport": {
      "properties": {
        "base_fee_msat": {
          "description": "The base fee charged regardless of the number of milli-satoshis sent.",
          "format": "int64",
          "type": "string"
        },
        "chan_id": {
          "description": "The short channel id that this fee report belongs to.",
          "format": "uint64",
          "type": "string"
        },
        "channel_point": {
          "description": "The channel that this fee report belongs to.",
          "type": "string"
        },
        "fee_per_mil": {
          "description": "The amount charged per milli-satoshis transferred expressed in\nmillionths of a satoshi.",
          "format": "int64",
          "type": "string"
        },
        "fee_rate": {
          "description": "The effective fee rate in milli-satoshis. Computed by dividing the\nfee_per_mil value by 1 million.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "lnrpcChannelGraph": {
      "description": "Returns a new instance of the directed channel graph.",
      "properties": {
        "edges": {
          "items": {
            "$ref": "#/definitions/lnrpcChannelEdge"
          },
          "title": "The list of `ChannelEdge`s in this channel graph",
          "type": "array"
        },
        "nodes": {
          "items": {
            "$ref": "#/definitions/lnrpcLightningNode"
          },
          "title": "The list of `LightningNode`s in this channel graph",
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcChannelOpenUpdate": {
      "properties": {
        "channel_point": {
          "$ref": "#/definitions/lnrpcChannelPoint"
        }
      },
      "type": "object"
    },
    "lnrpcChannelPoint": {
      "properties": {
        "funding_txid_bytes": {
          "description": "Txid of the funding transaction. When using REST, this field must be\nencoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "funding_txid_str": {
          "description": "Hex-encoded string representing the byte-reversed hash of the funding\ntransaction.",
          "type": "string"
        },
        "output_index": {
          "format": "int64",
          "title": "The index of the output of the funding transaction",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcChannelUpdate": {
      "properties": {
        "base_fee": {
          "description": "The base fee that must be used for incoming HTLC's to this particular\nchannel. This value will be tacked onto the required for a payment\nindependent of the size of the payment.",
          "format": "int64",
          "type": "integer"
        },
        "chain_hash": {
          "description": "The target chain that this channel was opened within. This value\nshould be the genesis hash of the target chain. Along with the short\nchannel ID, this uniquely identifies the channel globally in a\nblockchain.",
          "format": "byte",
          "type": "string"
        },
        "chan_id": {
          "description": "The unique description of the funding transaction.",
          "format": "uint64",
          "type": "string"
        },
        "channel_flags": {
          "description": "The bitfield that describes additional meta-data concerning how the\nupdate is to be interpreted. Currently, the least-significant bit must be\nset to 0 if the creating node corresponds to the first node in the\npreviously sent channel announcement and 1 otherwise. If the second bit\nis set, then the channel is set to be disabled.",
          "format": "int64",
          "type": "integer"
        },
        "extra_opaque_data": {
          "description": "The set of data that was appended to this message, some of which we may\nnot actually know how to iterate or parse. By holding onto this data, we\nensure that we're able to properly validate the set of signatures that\ncover these new fields, and ensure we're able to make upgrades to the\nnetwork in a forwards compatible manner.",
          "format": "byte",
          "type": "string"
        },
        "fee_rate": {
          "description": "The fee rate that will be charged per millionth of a satoshi.",
          "format": "int64",
          "type": "integer"
        },
        "htlc_maximum_msat": {
          "description": "The maximum HTLC value which will be accepted.",
          "format": "uint64",
          "type": "string"
        },
        "htlc_minimum_msat": {
          "description": "The minimum HTLC value which will be accepted.",
          "format": "uint64",
          "type": "string"
        },
        "message_flags": {
          "description": "The bitfield that describes whether optional fields are present in this\nupdate. Currently, the least-significant bit must be set to 1 if the\noptional field MaxHtlc is present.",
          "format": "int64",
          "type": "integer"
        },
        "signature": {
          "description": "The signature that validates the announced data and proves the ownership\nof node id.",
          "format": "byte",
          "type": "string"
        },
        "time_lock_delta": {
          "description": "The minimum number of blocks this node requires to be added to the expiry\nof HTLCs. This is a security parameter determined by the node operator.\nThis value represents the required gap between the time locks of the\nincoming and outgoing HTLC's set to this node.",
          "format": "int64",
          "type": "integer"
        },
        "timestamp": {
          "description": "A timestamp that allows ordering in the case of multiple announcements.\nWe should ignore the message if timestamp is not greater than the\nlast-received.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcCheckMacPermRequest": {
      "properties": {
        "fullMethod": {
          "type": "string"
        },
        "macaroon": {
          "format": "byte",
          "type": "string"
        },
        "permissions": {
          "items": {
            "$ref": "#/definitions/lnrpcMacaroonPermission"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcCheckMacPermResponse": {
      "properties": {
        "valid": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcCloseStatusUpdate": {
      "properties": {
        "chan_close": {
          "$ref": "#/definitions/lnrpcChannelCloseUpdate"
        },
        "close_pending": {
          "$ref": "#/definitions/lnrpcPendingUpdate"
        }
      },
      "type": "object"
    },
    "lnrpcClosedChannelUpdate": {
      "properties": {
        "capacity": {
          "format": "int64",
          "type": "string"
        },
        "chan_id": {
          "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel.",
          "format": "uint64",
          "type": "string"
        },
        "chan_point": {
          "$ref": "#/definitions/lnrpcChannelPoint"
        },
        "closed_height": {
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcClosedChannelsResponse": {
      "properties": {
        "channels": {
          "items": {
            "$ref": "#/definitions/lnrpcChannelCloseSummary"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcCommitmentType": {
      "default": "UNKNOWN_COMMITMENT_TYPE",
      "description": " - UNKNOWN_COMMITMENT_TYPE: Returned when the commitment type isn't known or unavailable.\n - LEGACY: A channel using the legacy commitment format having tweaked to_remote\nkeys.\n - STATIC_REMOTE_KEY: A channel that uses the modern commitment format where the key in the\noutput of the remote party does not change each state. This makes back\nup and recovery easier as when the channel is closed, the funds go\ndirectly to that key.\n - ANCHORS: A channel that uses a commitment format that has anchor outputs on the\ncommitments, allowing fee bumping after a force close transaction has\nbeen broadcast.\n - SCRIPT_ENFORCED_LEASE: A channel that uses a commitment type that builds upon the anchors\ncommitment format, but in addition requires a CLTV clause to spend outputs\npaying to the channel initiator. This is intended for use on leased channels\nto guarantee that the channel initiator has no incentives to close a leased\nchannel before its maturity date.",
      "enum": [
        "UNKNOWN_COMMITMENT_TYPE",
        "LEGACY",
        "STATIC_REMOTE_KEY",
        "ANCHORS",
        "SCRIPT_ENFORCED_LEASE"
      ],
      "type": "string"
    },
    "lnrpcConnectPeerRequest": {
      "properties": {
        "addr": {
          "$ref": "#/definitions/lnrpcLightningAddress",
          "description": "Lightning address of the peer to connect to."
        },
        "perm": {
          "description": "If set, the daemon will attempt to persistently connect to the target\npeer. Otherwise, the call will be synchronous.",
          "type": "boolean"
        },
        "timeout": {
          "description": "The connection timeout value (in seconds) for this request. It won't affect\nother requests.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcConnectPeerResponse": {
      "type": "object"
    },
    "lnrpcCustomMessage": {
      "properties": {
        "data": {
          "format": "byte",
          "title": "Raw message data",
          "type": "string"
        },
        "peer": {
          "format": "byte",
          "title": "Peer from which the message originates",
          "type": "string"
        },
        "type": {
          "description": "Message type. This value will be in the custom range (\u003e= 32768).",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcDebugLevelRequest": {
      "properties": {
        "level_spec": {
          "type": "string"
        },
        "show": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcDebugLevelResponse": {
      "properties": {
        "sub_systems": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcDeleteAllPaymentsResponse": {
      "type": "object"
    },
    "lnrpcDeleteMacaroonIDResponse": {
      "properties": {
        "deleted": {
          "description": "A boolean indicates that the deletion is successful.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcDeletePaymentResponse": {
      "type": "object"
    },
    "lnrpcDisconnectPeerResponse": {
      "type": "object"
    },
    "lnrpcEdgeLocator": {
      "properties": {
        "channel_id": {
          "description": "The short channel id of this edge.",
          "format": "uint64",
          "type": "string"
        },
        "direction_reverse": {
          "description": "The direction of this edge. If direction_reverse is false, the direction\nof this edge is from the channel endpoint with the lexicographically smaller\npub key to the endpoint with the larger pub key. If direction_reverse is\nis true, the edge goes the other way.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcEstimateFeeResponse": {
      "properties": {
        "fee_sat": {
          "description": "The total fee in satoshis.",
          "format": "int64",
          "type": "string"
        },
        "feerate_sat_per_byte": {
          "description": "Deprecated, use sat_per_vbyte.\nThe fee rate in satoshi/vbyte.",
          "format": "int64",
          "type": "string"
        },
        "sat_per_vbyte": {
          "description": "The fee rate in satoshi/vbyte.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcFailedUpdate": {
      "properties": {
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "title": "The outpoint in format txid:n"
        },
        "reason": {
          "$ref": "#/definitions/lnrpcUpdateFailure",
          "description": "Reason for the policy update failure."
        },
        "update_error": {
          "description": "A string representation of the policy update error.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcFailure": {
      "properties": {
        "channel_update": {
          "$ref": "#/definitions/lnrpcChannelUpdate",
          "description": "An optional channel update message."
        },
        "cltv_expiry": {
          "description": "A failure type-dependent cltv expiry value.",
          "format": "int64",
          "type": "integer"
        },
        "code": {
          "$ref": "#/definitions/FailureFailureCode",
          "title": "Failure code as defined in the Lightning spec"
        },
        "failure_source_index": {
          "description": "The position in the path of the intermediate or final node that generated\nthe failure message. Position zero is the sender node.",
          "format": "int64",
          "type": "integer"
        },
        "flags": {
          "description": "A failure type-dependent flags value.",
          "format": "int64",
          "type": "integer"
        },
        "height": {
          "description": "A failure type-dependent block height.",
          "format": "int64",
          "type": "integer"
        },
        "htlc_msat": {
          "description": "A failure type-dependent htlc value.",
          "format": "uint64",
          "type": "string"
        },
        "onion_sha_256": {
          "description": "The sha256 sum of the onion payload.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcFeature": {
      "properties": {
        "is_known": {
          "type": "boolean"
        },
        "is_required": {
          "type": "boolean"
        },
        "name": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcFeatureBit": {
      "default": "DATALOSS_PROTECT_REQ",
      "enum": [
        "DATALOSS_PROTECT_REQ",
        "DATALOSS_PROTECT_OPT",
        "INITIAL_ROUING_SYNC",
        "UPFRONT_SHUTDOWN_SCRIPT_REQ",
        "UPFRONT_SHUTDOWN_SCRIPT_OPT",
        "GOSSIP_QUERIES_REQ",
        "GOSSIP_QUERIES_OPT",
        "TLV_ONION_REQ",
        "TLV_ONION_OPT",
        "EXT_GOSSIP_QUERIES_REQ",
        "EXT_GOSSIP_QUERIES_OPT",
        "STATIC_REMOTE_KEY_REQ",
        "STATIC_REMOTE_KEY_OPT",
        "PAYMENT_ADDR_REQ",
        "PAYMENT_ADDR_OPT",
        "MPP_REQ",
        "MPP_OPT",
        "WUMBO_CHANNELS_REQ",
        "WUMBO_CHANNELS_OPT",
        "ANCHORS_REQ",
        "ANCHORS_OPT",
        "ANCHORS_ZERO_FEE_HTLC_REQ",
        "ANCHORS_ZERO_FEE_HTLC_OPT",
        "AMP_REQ",
        "AMP_OPT"
      ],
      "type": "string"
    },
    "lnrpcFeeLimit": {
      "properties": {
        "fixed": {
          "description": "The fee limit expressed as a fixed amount of satoshis.\n\nThe fields fixed and fixed_msat are mutually exclusive.",
          "format": "int64",
          "type": "string"
        },
        "fixed_msat": {
          "description": "The fee limit expressed as a fixed amount of millisatoshis.\n\nThe fields fixed and fixed_msat are mutually exclusive.",
          "format": "int64",
          "type": "string"
        },
        "percent": {
          "description": "The fee limit expressed as a percentage of the payment amount.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcFeeReportResponse": {
      "properties": {
        "channel_fees": {
          "description": "An array of channel fee reports which describes the current fee schedule\nfor each channel.",
          "items": {
            "$ref": "#/definitions/lnrpcChannelFeeReport"
          },
          "type": "array"
        },
        "day_fee_sum": {
          "description": "The total amount of fee revenue (in satoshis) the switch has collected\nover the past 24 hrs.",
          "format": "uint64",
          "type": "string"
        },
        "month_fee_sum": {
          "description": "The total amount of fee revenue (in satoshis) the switch has collected\nover the past 1 month.",
          "format": "uint64",
          "type": "string"
        },
        "week_fee_sum": {
          "description": "The total amount of fee revenue (in satoshis) the switch has collected\nover the past 1 week.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcFloatMetric": {
      "properties": {
        "normalized_value": {
          "description": "The value normalized to [0,1] or [-1,1].",
          "format": "double",
          "type": "number"
        },
        "value": {
          "description": "Arbitrary float value.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "lnrpcForwardingEvent": {
      "properties": {
        "amt_in": {
          "description": "The total amount (in satoshis) of the incoming HTLC that created half\nthe circuit.",
          "format": "uint64",
          "type": "string"
        },
        "amt_in_msat": {
          "description": "The total amount (in milli-satoshis) of the incoming HTLC that created\nhalf the circuit.",
          "format": "uint64",
          "type": "string"
        },
        "amt_out": {
          "description": "The total amount (in satoshis) of the outgoing HTLC that created the\nsecond half of the circuit.",
          "format": "uint64",
          "type": "string"
        },
        "amt_out_msat": {
          "description": "The total amount (in milli-satoshis) of the outgoing HTLC that created\nthe second half of the circuit.",
          "format": "uint64",
          "type": "string"
        },
        "chan_id_in": {
          "description": "The incoming channel ID that carried the HTLC that created the circuit.",
          "format": "uint64",
          "type": "string"
        },
        "chan_id_out": {
          "description": "The outgoing channel ID that carried the preimage that completed the\ncircuit.",
          "format": "uint64",
          "type": "string"
        },
        "fee": {
          "description": "The total fee (in satoshis) that this payment circuit carried.",
          "format": "uint64",
          "type": "string"
        },
        "fee_msat": {
          "description": "The total fee (in milli-satoshis) that this payment circuit carried.",
          "format": "uint64",
          "type": "string"
        },
        "timestamp": {
          "description": "Timestamp is the time (unix epoch offset) that this circuit was\ncompleted. Deprecated by timestamp_ns.",
          "format": "uint64",
          "type": "string"
        },
        "timestamp_ns": {
          "description": "The number of nanoseconds elapsed since January 1, 1970 UTC when this\ncircuit was completed.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcForwardingHistoryRequest": {
      "properties": {
        "end_time": {
          "description": "End time is the end point of the forwarding history request. The\nresponse will carry at most 50k records between the start time and the\nend time. The index offset can be used to implement pagination.",
          "format": "uint64",
          "type": "string"
        },
        "index_offset": {
          "description": "Index offset is the offset in the time series to start at. As each\nresponse can only contain 50k records, callers can use this to skip\naround within a packed time series.",
          "format": "int64",
          "type": "integer"
        },
        "num_max_events": {
          "description": "The max number of events to return in the response to this query.",
          "format": "int64",
          "type": "integer"
        },
        "start_time": {
          "description": "Start time is the starting point of the forwarding history request. All\nrecords beyond this point will be included, respecting the end time, and\nthe index offset.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcForwardingHistoryResponse": {
      "properties": {
        "forwarding_events": {
          "description": "A list of forwarding events from the time slice of the time series\nspecified in the request.",
          "items": {
            "$ref": "#/definitions/lnrpcForwardingEvent"
          },
          "type": "array"
        },
        "last_offset_index": {
          "description": "The index of the last time in the set of returned forwarding events. Can\nbe used to seek further, pagination style.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcFundingPsbtFinalize": {
      "properties": {
        "final_raw_tx": {
          "description": "As an alternative to the signed PSBT with all witness data, the final raw\nwire format transaction can also be specified directly. Cannot be set at the\nsame time as signed_psbt.",
          "format": "byte",
          "type": "string"
        },
        "pending_chan_id": {
          "description": "The pending channel ID of the channel to get the PSBT for.",
          "format": "byte",
          "type": "string"
        },
        "signed_psbt": {
          "description": "The funded PSBT that contains all witness data to send the exact channel\ncapacity amount to the PK script returned in the open channel message in a\nprevious step. Cannot be set at the same time as final_raw_tx.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcFundingPsbtVerify": {
      "properties": {
        "funded_psbt": {
          "description": "The funded but not yet signed PSBT that sends the exact channel capacity\namount to the PK script returned in the open channel message in a previous\nstep.",
          "format": "byte",
          "type": "string"
        },
        "pending_chan_id": {
          "description": "The pending channel ID of the channel to get the PSBT for.",
          "format": "byte",
          "type": "string"
        },
        "skip_finalize": {
          "description": "Can only be used if the no_publish flag was set to true in the OpenChannel\ncall meaning that the caller is solely responsible for publishing the final\nfunding transaction. If skip_finalize is set to true then lnd will not wait\nfor a FundingPsbtFinalize state step and instead assumes that a transaction\nwith the same TXID as the passed in PSBT will eventually confirm.\nIT IS ABSOLUTELY IMPERATIVE that the TXID of the transaction that is\neventually published does have the _same TXID_ as the verified PSBT. That\nmeans no inputs or outputs can change, only signatures can be added. If the\nTXID changes between this call and the publish step then the channel will\nnever be created and the funds will be in limbo.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcFundingShim": {
      "properties": {
        "chan_point_shim": {
          "$ref": "#/definitions/lnrpcChanPointShim",
          "description": "A channel shim where the channel point was fully constructed outside\nof lnd's wallet and the transaction might already be published."
        },
        "psbt_shim": {
          "$ref": "#/definitions/lnrpcPsbtShim",
          "description": "A channel shim that uses a PSBT to fund and sign the channel funding\ntransaction."
        }
      },
      "type": "object"
    },
    "lnrpcFundingShimCancel": {
      "properties": {
        "pending_chan_id": {
          "description": "The pending channel ID of the channel to cancel the funding shim for.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcFundingStateStepResp": {
      "type": "object"
    },
    "lnrpcFundingTransitionMsg": {
      "properties": {
        "psbt_finalize": {
          "$ref": "#/definitions/lnrpcFundingPsbtFinalize",
          "description": "Used to continue a funding flow that was initiated to be executed\nthrough a PSBT. This step finalizes the funded and signed PSBT, finishes\nnegotiation with the peer and finally publishes the resulting funding\ntransaction."
        },
        "psbt_verify": {
          "$ref": "#/definitions/lnrpcFundingPsbtVerify",
          "description": "Used to continue a funding flow that was initiated to be executed\nthrough a PSBT. This step verifies that the PSBT contains the correct\noutputs to fund the channel."
        },
        "shim_cancel": {
          "$ref": "#/definitions/lnrpcFundingShimCancel",
          "description": "Used to cancel an existing registered funding shim."
        },
        "shim_register": {
          "$ref": "#/definitions/lnrpcFundingShim",
          "description": "The funding shim to register. This should be used before any\nchannel funding has began by the remote party, as it is intended as a\npreparatory step for the full channel funding."
        }
      },
      "type": "object"
    },
    "lnrpcGenSeedResponse": {
      "properties": {
        "cipher_seed_mnemonic": {
          "description": "cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed\ncipher seed obtained by the user. This field is optional, as if not\nprovided, then the daemon will generate a new cipher seed for the user.\nOtherwise, then the daemon will attempt to recover the wallet state linked\nto this cipher seed.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "enciphered_seed": {
          "description": "enciphered_seed are the raw aezeed cipher seed bytes. This is the raw\ncipher text before run through our mnemonic encoding scheme.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcGetInfoResponse": {
      "properties": {
        "alias": {
          "title": "If applicable, the alias of the current node, e.g. \"bob\"",
          "type": "string"
        },
        "best_header_timestamp": {
          "format": "int64",
          "title": "Timestamp of the block best known to the wallet",
          "type": "string"
        },
        "block_hash": {
          "title": "The node's current view of the hash of the best block",
          "type": "string"
        },
        "block_height": {
          "format": "int64",
          "title": "The node's current view of the height of the best block",
          "type": "integer"
        },
        "chains": {
          "items": {
            "$ref": "#/definitions/lnrpcChain"
          },
          "title": "A list of active chains the node is connected to",
          "type": "array"
        },
        "color": {
          "title": "The color of the current node in hex code format",
          "type": "string"
        },
        "commit_hash": {
          "description": "The SHA1 commit hash that the daemon is compiled with.",
          "type": "string"
        },
        "features": {
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcFeature"
          },
          "description": "Features that our node has advertised in our init message, node\nannouncements and invoices.",
          "type": "object"
        },
        "identity_pubkey": {
          "description": "The identity pubkey of the current node.",
          "type": "string"
        },
        "num_active_channels": {
          "format": "int64",
          "title": "Number of active channels",
          "type": "integer"
        },
        "num_inactive_channels": {
          "format": "int64",
          "title": "Number of inactive channels",
          "type": "integer"
        },
        "num_peers": {
          "format": "int64",
          "title": "Number of peers",
          "type": "integer"
        },
        "num_pending_channels": {
          "format": "int64",
          "title": "Number of pending channels",
          "type": "integer"
        },
        "require_htlc_interceptor": {
          "description": "Indicates whether the HTLC interceptor API is in always-on mode.",
          "type": "boolean"
        },
        "synced_to_chain": {
          "title": "Whether the wallet's view is synced to the main chain",
          "type": "boolean"
        },
        "synced_to_graph": {
          "description": "Whether we consider ourselves synced with the public channel graph.",
          "type": "boolean"
        },
        "testnet": {
          "title": "Whether the current node is connected to testnet. This field is\ndeprecated and the network field should be used instead",
          "type": "boolean"
        },
        "uris": {
          "description": "The URIs of the current node.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "version": {
          "description": "The version of the LND software that the node is running.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcGetRecoveryInfoResponse": {
      "properties": {
        "progress": {
          "description": "The recovery progress, ranging from 0 to 1.",
          "format": "double",
          "type": "number"
        },
        "recovery_finished": {
          "title": "Whether the wallet recovery progress is finished",
          "type": "boolean"
        },
        "recovery_mode": {
          "title": "Whether the wallet is in recovery mode",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcGetStateResponse": {
      "properties": {
        "state": {
          "$ref": "#/definitions/lnrpcWalletState"
        }
      },
      "type": "object"
    },
    "lnrpcGraphTopologyUpdate": {
      "properties": {
        "channel_updates": {
          "items": {
            "$ref": "#/definitions/lnrpcChannelEdgeUpdate"
          },
          "type": "array"
        },
        "closed_chans": {
          "items": {
            "$ref": "#/definitions/lnrpcClosedChannelUpdate"
          },
          "type": "array"
        },
        "node_updates": {
          "items": {
            "$ref": "#/definitions/lnrpcNodeUpdate"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcHTLC": {
      "properties": {
        "amount": {
          "format": "int64",
          "type": "string"
        },
        "expiration_height": {
          "format": "int64",
          "type": "integer"
        },
        "forwarding_channel": {
          "description": "If this HTLC is involved in a forwarding operation, this field indicates\nthe forwarding channel. For an outgoing htlc, it is the incoming channel.\nFor an incoming htlc, it is the outgoing channel. When the htlc\noriginates from this node or this node is the final destination,\nforwarding_channel will be zero. The forwarding channel will also be zero\nfor htlcs that need to be forwarded but don't have a forwarding decision\npersisted yet.",
          "format": "uint64",
          "type": "string"
        },
        "forwarding_htlc_index": {
          "description": "Index identifying the htlc on the forwarding channel.",
          "format": "uint64",
          "type": "string"
        },
        "hash_lock": {
          "format": "byte",
          "type": "string"
        },
        "htlc_index": {
          "description": "Index identifying the htlc on the channel.",
          "format": "uint64",
          "type": "string"
        },
        "incoming": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcHTLCAttempt": {
      "properties": {
        "attempt_id": {
          "description": "The unique ID that is used for this attempt.",
          "format": "uint64",
          "type": "string"
        },
        "attempt_time_ns": {
          "description": "The time in UNIX nanoseconds at which this HTLC was sent.",
          "format": "int64",
          "type": "string"
        },
        "failure": {
          "$ref": "#/definitions/lnrpcFailure",
          "description": "Detailed htlc failure info."
        },
        "preimage": {
          "description": "The preimage that was used to settle the HTLC.",
          "format": "byte",
          "type": "string"
        },
        "resolve_time_ns": {
          "description": "The time in UNIX nanoseconds at which this HTLC was settled or failed.\nThis value will not be set if the HTLC is still IN_FLIGHT.",
          "format": "int64",
          "type": "string"
        },
        "route": {
          "$ref": "#/definitions/lnrpcRoute",
          "description": "The route taken by this HTLC."
        },
        "status": {
          "$ref": "#/definitions/HTLCAttemptHTLCStatus",
          "description": "The status of the HTLC."
        }
      },
      "type": "object"
    },
    "lnrpcHop": {
      "properties": {
        "amp_record": {
          "$ref": "#/definitions/lnrpcAMPRecord",
          "description": "An optional TLV record that signals the use of an AMP payment. If present,\nthe receiver will treat all received payments including the same\n(payment_addr, set_id) pair  as being part of one logical payment. The\npayment will be settled by XORing the root_share's together and deriving the\nchild hashes and preimages according to BOLT XX. Must be used in conjunction\nwith mpp_record."
        },
        "amt_to_forward": {
          "format": "int64",
          "type": "string"
        },
        "amt_to_forward_msat": {
          "format": "int64",
          "type": "string"
        },
        "chan_capacity": {
          "format": "int64",
          "type": "string"
        },
        "chan_id": {
          "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel.",
          "format": "uint64",
          "type": "string"
        },
        "custom_records": {
          "additionalProperties": {
            "format": "byte",
            "type": "string"
          },
          "description": "An optional set of key-value TLV records. This is useful within the context\nof the SendToRoute call as it allows callers to specify arbitrary K-V pairs\nto drop off at each hop within the onion.",
          "type": "object"
        },
        "expiry": {
          "format": "int64",
          "type": "integer"
        },
        "fee": {
          "format": "int64",
          "type": "string"
        },
        "fee_msat": {
          "format": "int64",
          "type": "string"
        },
        "metadata": {
          "description": "The payment metadata to send along with the payment to the payee.",
          "format": "byte",
          "type": "string"
        },
        "mpp_record": {
          "$ref": "#/definitions/lnrpcMPPRecord",
          "description": "An optional TLV record that signals the use of an MPP payment. If present,\nthe receiver will enforce that the same mpp_record is included in the final\nhop payload of all non-zero payments in the HTLC set. If empty, a regular\nsingle-shot payment is or was attempted."
        },
        "pub_key": {
          "description": "An optional public key of the hop. If the public key is given, the payment\ncan be executed without relying on a copy of the channel graph.",
          "type": "string"
        },
        "tlv_payload": {
          "description": "If set to true, then this hop will be encoded using the new variable length\nTLV format. Note that if any custom tlv_records below are specified, then\nthis field MUST be set to true for them to be encoded properly.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcHopHint": {
      "properties": {
        "chan_id": {
          "description": "The unique identifier of the channel.",
          "format": "uint64",
          "type": "string"
        },
        "cltv_expiry_delta": {
          "description": "The time-lock delta of the channel.",
          "format": "int64",
          "type": "integer"
        },
        "fee_base_msat": {
          "description": "The base fee of the channel denominated in millisatoshis.",
          "format": "int64",
          "type": "integer"
        },
        "fee_proportional_millionths": {
          "description": "The fee rate of the channel for sending one satoshi across it denominated in\nmillionths of a satoshi.",
          "format": "int64",
          "type": "integer"
        },
        "node_id": {
          "description": "The public key of the node at the start of the channel.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcInitWalletRequest": {
      "properties": {
        "aezeed_passphrase": {
          "description": "aezeed_passphrase is an optional user provided passphrase that will be used\nto encrypt the generated aezeed cipher seed. When using REST, this field\nmust be encoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "channel_backups": {
          "$ref": "#/definitions/lnrpcChanBackupSnapshot",
          "description": "channel_backups is an optional argument that allows clients to recover the\nsettled funds within a set of channels. This should be populated if the\nuser was unable to close out all channels and sweep funds before partial or\ntotal data loss occurred. If specified, then after on-chain recovery of\nfunds, lnd begin to carry out the data loss recovery protocol in order to\nrecover the funds in each channel from a remote force closed transaction."
        },
        "cipher_seed_mnemonic": {
          "description": "cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed\ncipher seed obtained by the user. This may have been generated by the\nGenSeed method, or be an existing seed.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "extended_master_key": {
          "description": "extended_master_key is an alternative to specifying cipher_seed_mnemonic and\naezeed_passphrase. Instead of deriving the master root key from the entropy\nof an aezeed cipher seed, the given extended master root key is used\ndirectly as the wallet's master key. This allows users to import/use a\nmaster key from another wallet. When doing so, lnd still uses its default\nSegWit only (BIP49/84) derivation paths and funds from custom/non-default\nderivation paths will not automatically appear in the on-chain wallet. Using\nan 'xprv' instead of an aezeed also has the disadvantage that the wallet's\nbirthday is not known as that is an information that's only encoded in the\naezeed, not the xprv. Therefore a birthday needs to be specified in\nextended_master_key_birthday_timestamp or a \"safe\" default value will be\nused.",
          "type": "string"
        },
        "extended_master_key_birthday_timestamp": {
          "description": "extended_master_key_birthday_timestamp is the optional unix timestamp in\nseconds to use as the wallet's birthday when using an extended master key\nto restore the wallet. lnd will only start scanning for funds in blocks that\nare after the birthday which can speed up the process significantly. If the\nbirthday is not known, this should be left at its default value of 0 in\nwhich case lnd will start scanning from the first SegWit block (481824 on\nmainnet).",
          "format": "uint64",
          "type": "string"
        },
        "recovery_window": {
          "description": "recovery_window is an optional argument specifying the address lookahead\nwhen restoring a wallet seed. The recovery window applies to each\nindividual branch of the BIP44 derivation paths. Supplying a recovery\nwindow of zero indicates that no addresses should be recovered, such after\nthe first initialization of the wallet.",
          "format": "int32",
          "type": "integer"
        },
        "stateless_init": {
          "title": "stateless_init is an optional argument instructing the daemon NOT to create\nany *.macaroon files in its filesystem. If this parameter is set, then the\nadmin macaroon returned in the response MUST be stored by the caller of the\nRPC as otherwise all access to the daemon will be lost!",
          "type": "boolean"
        },
        "wallet_password": {
          "description": "wallet_password is the passphrase that should be used to encrypt the\nwallet. This MUST be at least 8 chars in length. After creation, this\npassword is required to unlock the daemon. When using REST, this field\nmust be encoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "watch_only": {
          "$ref": "#/definitions/lnrpcWatchOnly",
          "description": "watch_only is the third option of initializing a wallet: by importing\naccount xpubs only and therefore creating a watch-only wallet that does not\ncontain any private keys. That means the wallet won't be able to sign for\nany of the keys and _needs_ to be run with a remote signer that has the\ncorresponding private keys and can serve signing RPC requests."
        }
      },
      "type": "object"
    },
    "lnrpcInitWalletResponse": {
      "properties": {
        "admin_macaroon": {
          "description": "The binary serialized admin macaroon that can be used to access the daemon\nafter creating the wallet. If the stateless_init parameter was set to true,\nthis is the ONLY copy of the macaroon and MUST be stored safely by the\ncaller. Otherwise a copy of this macaroon is also persisted on disk by the\ndaemon, together with other macaroon files.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcInitiator": {
      "default": "INITIATOR_UNKNOWN",
      "enum": [
        "INITIATOR_UNKNOWN",
        "INITIATOR_LOCAL",
        "INITIATOR_REMOTE",
        "INITIATOR_BOTH"
      ],
      "type": "string"
    },
    "lnrpcInterceptFeedback": {
      "properties": {
        "error": {
          "description": "The error to return to the user. If this is non-empty, the incoming gRPC\nstream/request is aborted and the error is returned to the gRPC client. If\nthis value is empty, it means the middleware accepts the stream/request/\nresponse and the processing of it can continue.",
          "type": "string"
        },
        "replace_response": {
          "description": "A boolean indicating that the gRPC message should be replaced/overwritten.\nThis boolean is needed because in protobuf an empty message is serialized as\na 0-length or nil byte slice and we wouldn't be able to distinguish between\nan empty replacement message and the \"don't replace anything\" case.",
          "type": "boolean"
        },
        "replacement_serialized": {
          "description": "If the replace_response field is set to true, this field must contain the\nbinary serialized gRPC message in the protobuf format.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcInvoice": {
      "properties": {
        "add_index": {
          "description": "The \"add\" index of this invoice. Each newly created invoice will increment\nthis index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all added\ninvoices with an add_index greater than this one.\nNote: Output only, don't specify for creating an invoice.",
          "format": "uint64",
          "type": "string"
        },
        "amp_invoice_state": {
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcAMPInvoiceState"
          },
          "description": "Maps a 32-byte hex-encoded set ID to the sub-invoice AMP state for the\ngiven set ID. This field is always populated for AMP invoices, and can be\nused along side LookupInvoice to obtain the HTLC information related to a\ngiven sub-invoice.\nNote: Output only, don't specify for creating an invoice.",
          "title": "[EXPERIMENTAL]:",
          "type": "object"
        },
        "amt_paid": {
          "description": "Deprecated, use amt_paid_sat or amt_paid_msat.",
          "format": "int64",
          "type": "string"
        },
        "amt_paid_msat": {
          "description": "The amount that was accepted for this invoice, in millisatoshis. This will\nONLY be set if this invoice has been settled. We provide this field as if\nthe invoice was created with a zero value, then we need to record what\namount was ultimately accepted. Additionally, it's possible that the sender\npaid MORE that was specified in the original invoice. So we'll record that\nhere as well.\nNote: Output only, don't specify for creating an invoice.",
          "format": "int64",
          "type": "string"
        },
        "amt_paid_sat": {
          "description": "The amount that was accepted for this invoice, in satoshis. This will ONLY\nbe set if this invoice has been settled. We provide this field as if the\ninvoice was created with a zero value, then we need to record what amount\nwas ultimately accepted. Additionally, it's possible that the sender paid\nMORE that was specified in the original invoice. So we'll record that here\nas well.\nNote: Output only, don't specify for creating an invoice.",
          "format": "int64",
          "type": "string"
        },
        "cltv_expiry": {
          "description": "Delta to use for the time-lock of the CLTV extended to the final hop.",
          "format": "uint64",
          "type": "string"
        },
        "creation_date": {
          "description": "When this invoice was created.\nNote: Output only, don't specify for creating an invoice.",
          "format": "int64",
          "type": "string"
        },
        "description_hash": {
          "description": "Hash (SHA-256) of a description of the payment. Used if the description of\npayment (memo) is too long to naturally fit within the description field\nof an encoded payment request. When using REST, this field must be encoded\nas base64.",
          "format": "byte",
          "type": "string"
        },
        "expiry": {
          "description": "Payment request expiry time in seconds. Default is 3600 (1 hour).",
          "format": "int64",
          "type": "string"
        },
        "fallback_addr": {
          "description": "Fallback on-chain address.",
          "type": "string"
        },
        "features": {
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcFeature"
          },
          "description": "List of features advertised on the invoice.\nNote: Output only, don't specify for creating an invoice.",
          "type": "object"
        },
        "htlcs": {
          "description": "List of HTLCs paying to this invoice [EXPERIMENTAL].\nNote: Output only, don't specify for creating an invoice.",
          "items": {
            "$ref": "#/definitions/lnrpcInvoiceHTLC"
          },
          "type": "array"
        },
        "is_amp": {
          "description": "Signals whether or not this is an AMP invoice.",
          "type": "boolean"
        },
        "is_keysend": {
          "description": "Indicates if this invoice was a spontaneous payment that arrived via keysend\n[EXPERIMENTAL].\nNote: Output only, don't specify for creating an invoice.",
          "type": "boolean"
        },
        "memo": {
          "description": "An optional memo to attach along with the invoice. Used for record keeping\npurposes for the invoice's creator, and will also be set in the description\nfield of the encoded payment request if the description_hash field is not\nbeing used.",
          "type": "string"
        },
        "payment_addr": {
          "description": "The payment address of this invoice. This value will be used in MPP\npayments, and also for newer invoices that always require the MPP payload\nfor added end-to-end security.\nNote: Output only, don't specify for creating an invoice.",
          "format": "byte",
          "type": "string"
        },
        "payment_request": {
          "description": "A bare-bones invoice for a payment within the Lightning Network. With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient.\nNote: Output only, don't specify for creating an invoice.",
          "type": "string"
        },
        "private": {
          "description": "Whether this invoice should include routing hints for private channels.",
          "type": "boolean"
        },
        "r_hash": {
          "description": "The hash of the preimage. When using REST, this field must be encoded as\nbase64.\nNote: Output only, don't specify for creating an invoice.",
          "format": "byte",
          "type": "string"
        },
        "r_preimage": {
          "description": "The hex-encoded preimage (32 byte) which will allow settling an incoming\nHTLC payable to this preimage. When using REST, this field must be encoded\nas base64.",
          "format": "byte",
          "type": "string"
        },
        "route_hints": {
          "description": "Route hints that can each be individually used to assist in reaching the\ninvoice's destination.",
          "items": {
            "$ref": "#/definitions/lnrpcRouteHint"
          },
          "type": "array"
        },
        "settle_date": {
          "description": "When this invoice was settled.\nNote: Output only, don't specify for creating an invoice.",
          "format": "int64",
          "type": "string"
        },
        "settle_index": {
          "description": "The \"settle\" index of this invoice. Each newly settled invoice will\nincrement this index making it monotonically increasing. Callers to the\nSubscribeInvoices call can use this to instantly get notified of all\nsettled invoices with an settle_index greater than this one.\nNote: Output only, don't specify for creating an invoice.",
          "format": "uint64",
          "type": "string"
        },
        "settled": {
          "title": "Whether this invoice has been fulfilled",
          "type": "boolean"
        },
        "state": {
          "$ref": "#/definitions/InvoiceInvoiceState",
          "description": "The state the invoice is in.\nNote: Output only, don't specify for creating an invoice."
        },
        "value": {
          "description": "The fields value and value_msat are mutually exclusive.",
          "format": "int64",
          "title": "The value of this invoice in satoshis",
          "type": "string"
        },
        "value_msat": {
          "description": "The fields value and value_msat are mutually exclusive.",
          "format": "int64",
          "title": "The value of this invoice in millisatoshis",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcInvoiceHTLC": {
      "properties": {
        "accept_height": {
          "description": "Block height at which this htlc was accepted.",
          "format": "int32",
          "type": "integer"
        },
        "accept_time": {
          "description": "Time at which this htlc was accepted.",
          "format": "int64",
          "type": "string"
        },
        "amp": {
          "$ref": "#/definitions/lnrpcAMP",
          "description": "Details relevant to AMP HTLCs, only populated if this is an AMP HTLC."
        },
        "amt_msat": {
          "description": "The amount of the htlc in msat.",
          "format": "uint64",
          "type": "string"
        },
        "chan_id": {
          "description": "Short channel id over which the htlc was received.",
          "format": "uint64",
          "type": "string"
        },
        "custom_records": {
          "additionalProperties": {
            "format": "byte",
            "type": "string"
          },
          "description": "Custom tlv records.",
          "type": "object"
        },
        "expiry_height": {
          "description": "Block height at which this htlc expires.",
          "format": "int32",
          "type": "integer"
        },
        "htlc_index": {
          "description": "Index identifying the htlc on the channel.",
          "format": "uint64",
          "type": "string"
        },
        "mpp_total_amt_msat": {
          "description": "The total amount of the mpp payment in msat.",
          "format": "uint64",
          "type": "string"
        },
        "resolve_time": {
          "description": "Time at which this htlc was settled or canceled.",
          "format": "int64",
          "type": "string"
        },
        "state": {
          "$ref": "#/definitions/lnrpcInvoiceHTLCState",
          "description": "Current state the htlc is in."
        }
      },
      "title": "Details of an HTLC that paid to an invoice",
      "type": "object"
    },
    "lnrpcInvoiceHTLCState": {
      "default": "ACCEPTED",
      "enum": [
        "ACCEPTED",
        "SETTLED",
        "CANCELED"
      ],
      "type": "string"
    },
    "lnrpcKeyDescriptor": {
      "properties": {
        "key_loc": {
          "$ref": "#/definitions/lnrpcKeyLocator",
          "description": "The key locator that identifies which key to use for signing."
        },
        "raw_key_bytes": {
          "description": "The raw bytes of the key being identified.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcKeyLocator": {
      "properties": {
        "key_family": {
          "description": "The family of key being identified.",
          "format": "int32",
          "type": "integer"
        },
        "key_index": {
          "description": "The precise index of the key being identified.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcLightningAddress": {
      "properties": {
        "host": {
          "description": "The network location of the lightning node, e.g. `69.69.69.69:1337` or\n`localhost:10011`.",
          "type": "string"
        },
        "pubkey": {
          "description": "The identity pubkey of the Lightning node.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcLightningNode": {
      "description": "An individual vertex/node within the channel graph. A node is\nconnected to other nodes by one or more channel edges emanating from it. As the\ngraph is directed, a node will also have an incoming edge attached to it for\neach outgoing edge.",
      "properties": {
        "addresses": {
          "items": {
            "$ref": "#/definitions/lnrpcNodeAddress"
          },
          "type": "array"
        },
        "alias": {
          "type": "string"
        },
        "color": {
          "type": "string"
        },
        "features": {
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcFeature"
          },
          "type": "object"
        },
        "last_update": {
          "format": "int64",
          "type": "integer"
        },
        "pub_key": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcListChannelsResponse": {
      "properties": {
        "channels": {
          "items": {
            "$ref": "#/definitions/lnrpcChannel"
          },
          "title": "The list of active channels",
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcListInvoiceResponse": {
      "properties": {
        "first_index_offset": {
          "description": "The index of the last item in the set of returned invoices. This can be used\nto seek backwards, pagination style.",
          "format": "uint64",
          "type": "string"
        },
        "invoices": {
          "description": "A list of invoices from the time slice of the time series specified in the\nrequest.",
          "items": {
            "$ref": "#/definitions/lnrpcInvoice"
          },
          "type": "array"
        },
        "last_index_offset": {
          "description": "The index of the last item in the set of returned invoices. This can be used\nto seek further, pagination style.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcListMacaroonIDsResponse": {
      "properties": {
        "root_key_ids": {
          "description": "The list of root key IDs that are in use.",
          "items": {
            "format": "uint64",
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcListPaymentsResponse": {
      "properties": {
        "first_index_offset": {
          "description": "The index of the first item in the set of returned payments. This can be\nused as the index_offset to continue seeking backwards in the next request.",
          "format": "uint64",
          "type": "string"
        },
        "last_index_offset": {
          "description": "The index of the last item in the set of returned payments. This can be used\nas the index_offset to continue seeking forwards in the next request.",
          "format": "uint64",
          "type": "string"
        },
        "payments": {
          "items": {
            "$ref": "#/definitions/lnrpcPayment"
          },
          "title": "The list of payments",
          "type": "array"
        },
        "total_num_payments": {
          "description": "Will only be set if count_total_payments in the request was set. Represents\nthe total number of payments (complete and incomplete, independent of the\nnumber of payments requested in the query) currently present in the payments\ndatabase.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcListPeersResponse": {
      "properties": {
        "peers": {
          "items": {
            "$ref": "#/definitions/lnrpcPeer"
          },
          "title": "The list of currently connected peers",
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcListPermissionsResponse": {
      "properties": {
        "method_permissions": {
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcMacaroonPermissionList"
          },
          "description": "A map between all RPC method URIs and their required macaroon permissions to\naccess them.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "lnrpcListUnspentResponse": {
      "properties": {
        "utxos": {
          "items": {
            "$ref": "#/definitions/lnrpcUtxo"
          },
          "title": "A list of utxos",
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcMPPRecord": {
      "properties": {
        "payment_addr": {
          "description": "A unique, random identifier used to authenticate the sender as the intended\npayer of a multi-path payment. The payment_addr must be the same for all\nsubpayments, and match the payment_addr provided in the receiver's invoice.\nThe same payment_addr must be used on all subpayments.",
          "format": "byte",
          "type": "string"
        },
        "total_amt_msat": {
          "description": "The total amount in milli-satoshis being sent as part of a larger multi-path\npayment. The caller is responsible for ensuring subpayments to the same node\nand payment_hash sum exactly to total_amt_msat. The same\ntotal_amt_msat must be used on all subpayments.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcMacaroonPermission": {
      "properties": {
        "action": {
          "description": "The action that is granted.",
          "type": "string"
        },
        "entity": {
          "description": "The entity a permission grants access to.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcMacaroonPermissionList": {
      "properties": {
        "permissions": {
          "description": "A list of macaroon permissions.",
          "items": {
            "$ref": "#/definitions/lnrpcMacaroonPermission"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcMiddlewareRegistration": {
      "properties": {
        "custom_macaroon_caveat_name": {
          "description": "The name of the custom macaroon caveat that this middleware is responsible\nfor. Only requests/responses that contain a macaroon with the registered\ncustom caveat are forwarded for interception to the middleware. The\nexception being the read-only mode: All requests/responses are forwarded to\na middleware that requests read-only access but such a middleware won't be\nallowed to _alter_ responses. As a security measure, _no_ middleware can\nchange responses to requests made with _unencumbered_ macaroons!\nNOTE: Cannot be used at the same time as read_only_mode.",
          "type": "string"
        },
        "middleware_name": {
          "description": "The name of the middleware to register. The name should be as informative\nas possible and is logged on registration.",
          "type": "string"
        },
        "read_only_mode": {
          "description": "Instead of defining a custom macaroon caveat name a middleware can register\nitself for read-only access only. In that mode all requests/responses are\nforwarded to the middleware but the middleware isn't allowed to alter any of\nthe responses.\nNOTE: Cannot be used at the same time as custom_macaroon_caveat_name.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcMultiChanBackup": {
      "properties": {
        "chan_points": {
          "description": "Is the set of all channels that are included in this multi-channel backup.",
          "items": {
            "$ref": "#/definitions/lnrpcChannelPoint"
          },
          "type": "array"
        },
        "multi_chan_backup": {
          "description": "A single encrypted blob containing all the static channel backups of the\nchannel listed above. This can be stored as a single file or blob, and\nsafely be replaced with any prior/future versions. When using REST, this\nfield must be encoded as base64.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcNetworkInfo": {
      "properties": {
        "avg_channel_size": {
          "format": "double",
          "type": "number"
        },
        "avg_out_degree": {
          "format": "double",
          "type": "number"
        },
        "graph_diameter": {
          "format": "int64",
          "type": "integer"
        },
        "max_channel_size": {
          "format": "int64",
          "type": "string"
        },
        "max_out_degree": {
          "format": "int64",
          "type": "integer"
        },
        "median_channel_size_sat": {
          "format": "int64",
          "type": "string"
        },
        "min_channel_size": {
          "format": "int64",
          "type": "string"
        },
        "num_channels": {
          "format": "int64",
          "type": "integer"
        },
        "num_nodes": {
          "format": "int64",
          "type": "integer"
        },
        "num_zombie_chans": {
          "description": "The number of edges marked as zombies.",
          "format": "uint64",
          "type": "string"
        },
        "total_network_capacity": {
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcNewAddressResponse": {
      "properties": {
        "address": {
          "title": "The newly generated wallet address",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcNodeAddress": {
      "properties": {
        "addr": {
          "type": "string"
        },
        "network": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcNodeInfo": {
      "properties": {
        "channels": {
          "description": "A list of all public channels for the node.",
          "items": {
            "$ref": "#/definitions/lnrpcChannelEdge"
          },
          "type": "array"
        },
        "node": {
          "$ref": "#/definitions/lnrpcLightningNode",
          "description": "An individual vertex/node within the channel graph. A node is\nconnected to other nodes by one or more channel edges emanating from it. As\nthe graph is directed, a node will also have an incoming edge attached to\nit for each outgoing edge."
        },
        "num_channels": {
          "description": "The total number of channels for the node.",
          "format": "int64",
          "type": "integer"
        },
        "total_capacity": {
          "description": "The sum of all channels capacity for the node, denominated in satoshis.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcNodeMetricType": {
      "default": "UNKNOWN",
      "enum": [
        "UNKNOWN",
        "BETWEENNESS_CENTRALITY"
      ],
      "type": "string"
    },
    "lnrpcNodeMetricsResponse": {
      "properties": {
        "betweenness_centrality": {
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcFloatMetric"
          },
          "description": "Betweenness centrality is the sum of the ratio of shortest paths that pass\nthrough the node for each pair of nodes in the graph (not counting paths\nstarting or ending at this node).\nMap of node pubkey to betweenness centrality of the node. Normalized\nvalues are in the [0,1] closed interval.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "lnrpcNodePair": {
      "properties": {
        "from": {
          "description": "The sending node of the pair. When using REST, this field must be encoded as\nbase64.",
          "format": "byte",
          "type": "string"
        },
        "to": {
          "description": "The receiving node of the pair. When using REST, this field must be encoded\nas base64.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcNodeUpdate": {
      "properties": {
        "addresses": {
          "description": "Deprecated, use node_addresses.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "alias": {
          "type": "string"
        },
        "color": {
          "type": "string"
        },
        "features": {
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcFeature"
          },
          "description": "Features that the node has advertised in the init message, node\nannouncements and invoices.",
          "type": "object"
        },
        "global_features": {
          "description": "Deprecated, use features.",
          "format": "byte",
          "type": "string"
        },
        "identity_key": {
          "type": "string"
        },
        "node_addresses": {
          "items": {
            "$ref": "#/definitions/lnrpcNodeAddress"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcOp": {
      "properties": {
        "actions": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "entity": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcOpenChannelRequest": {
      "properties": {
        "close_address": {
          "description": "Close address is an optional address which specifies the address to which\nfunds should be paid out to upon cooperative close. This field may only be\nset if the peer supports the option upfront feature bit (call listpeers\nto check). The remote peer will only accept cooperative closes to this\naddress if it is set.\n\nNote: If this value is set on channel creation, you will *not* be able to\ncooperatively close out to a different address.",
          "type": "string"
        },
        "commitment_type": {
          "$ref": "#/definitions/lnrpcCommitmentType",
          "description": "The explicit commitment type to use. Note this field will only be used if\nthe remote peer supports explicit channel negotiation."
        },
        "funding_shim": {
          "$ref": "#/definitions/lnrpcFundingShim",
          "description": "Funding shims are an optional argument that allow the caller to intercept\ncertain funding functionality. For example, a shim can be provided to use a\nparticular key for the commitment key (ideally cold) rather than use one\nthat is generated by the wallet as normal, or signal that signing will be\ncarried out in an interactive manner (PSBT based)."
        },
        "local_funding_amount": {
          "format": "int64",
          "title": "The number of satoshis the wallet should commit to the channel",
          "type": "string"
        },
        "max_local_csv": {
          "description": "Max local csv is the maximum csv delay we will allow for our own commitment\ntransaction.",
          "format": "int64",
          "type": "integer"
        },
        "min_confs": {
          "description": "The minimum number of confirmations each one of your outputs used for\nthe funding transaction must satisfy.",
          "format": "int32",
          "type": "integer"
        },
        "min_htlc_msat": {
          "description": "The minimum value in millisatoshi we will require for incoming HTLCs on\nthe channel.",
          "format": "int64",
          "type": "string"
        },
        "node_pubkey": {
          "description": "The pubkey of the node to open a channel with. When using REST, this field\nmust be encoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "node_pubkey_string": {
          "description": "The hex encoded pubkey of the node to open a channel with. Deprecated now\nthat the REST gateway supports base64 encoding of bytes fields.",
          "type": "string"
        },
        "private": {
          "description": "Whether this channel should be private, not announced to the greater\nnetwork.",
          "type": "boolean"
        },
        "push_sat": {
          "format": "int64",
          "title": "The number of satoshis to push to the remote side as part of the initial\ncommitment state",
          "type": "string"
        },
        "remote_csv_delay": {
          "description": "The delay we require on the remote's commitment transaction. If this is\nnot set, it will be scaled automatically with the channel size.",
          "format": "int64",
          "type": "integer"
        },
        "remote_max_htlcs": {
          "description": "The maximum number of concurrent HTLCs we will allow the remote party to add\nto the commitment transaction.",
          "format": "int64",
          "type": "integer"
        },
        "remote_max_value_in_flight_msat": {
          "description": "The maximum amount of coins in millisatoshi that can be pending within\nthe channel. It only applies to the remote party.",
          "format": "uint64",
          "type": "string"
        },
        "sat_per_byte": {
          "description": "Deprecated, use sat_per_vbyte.\nA manual fee rate set in sat/vbyte that should be used when crafting the\nfunding transaction.",
          "format": "int64",
          "type": "string"
        },
        "sat_per_vbyte": {
          "description": "A manual fee rate set in sat/vbyte that should be used when crafting the\nfunding transaction.",
          "format": "uint64",
          "type": "string"
        },
        "scid_alias": {
          "description": "If this is true, then an option-scid-alias channel-type open will be\nattempted.",
          "type": "boolean"
        },
        "spend_unconfirmed": {
          "description": "Whether unconfirmed outputs should be used as inputs for the funding\ntransaction.",
          "type": "boolean"
        },
        "target_conf": {
          "description": "The target number of blocks that the funding transaction should be\nconfirmed by.",
          "format": "int32",
          "type": "integer"
        },
        "zero_conf": {
          "description": "If this is true, then a zero-conf channel open will be attempted.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcOpenStatusUpdate": {
      "properties": {
        "chan_open": {
          "$ref": "#/definitions/lnrpcChannelOpenUpdate",
          "description": "Signals that the channel's funding transaction has now reached the\nrequired number of confirmations on chain and can be used."
        },
        "chan_pending": {
          "$ref": "#/definitions/lnrpcPendingUpdate",
          "description": "Signals that the channel is now fully negotiated and the funding\ntransaction published."
        },
        "pending_chan_id": {
          "description": "The pending channel ID of the created channel. This value may be used to\nfurther the funding flow manually via the FundingStateStep method.",
          "format": "byte",
          "type": "string"
        },
        "psbt_fund": {
          "$ref": "#/definitions/lnrpcReadyForPsbtFunding",
          "description": "Signals that the funding process has been suspended and the construction\nof a PSBT that funds the channel PK script is now required."
        }
      },
      "type": "object"
    },
    "lnrpcOutPoint": {
      "properties": {
        "output_index": {
          "description": "The index of the output on the transaction.",
          "format": "int64",
          "type": "integer"
        },
        "txid_bytes": {
          "description": "Raw bytes representing the transaction id.",
          "format": "byte",
          "type": "string"
        },
        "txid_str": {
          "description": "Reversed, hex-encoded string representing the transaction id.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcOutputDetail": {
      "properties": {
        "address": {
          "title": "The address",
          "type": "string"
        },
        "amount": {
          "format": "int64",
          "title": "The value of the output coin in satoshis",
          "type": "string"
        },
        "is_our_address": {
          "title": "Denotes if the output is controlled by the internal wallet",
          "type": "boolean"
        },
        "output_index": {
          "format": "int64",
          "title": "The output index used in the raw transaction",
          "type": "string"
        },
        "output_type": {
          "$ref": "#/definitions/lnrpcOutputScriptType",
          "title": "The type of the output"
        },
        "pk_script": {
          "title": "The pkscript in hex",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcOutputScriptType": {
      "default": "SCRIPT_TYPE_PUBKEY_HASH",
      "enum": [
        "SCRIPT_TYPE_PUBKEY_HASH",
        "SCRIPT_TYPE_SCRIPT_HASH",
        "SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH",
        "SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH",
        "SCRIPT_TYPE_PUBKEY",
        "SCRIPT_TYPE_MULTISIG",
        "SCRIPT_TYPE_NULLDATA",
        "SCRIPT_TYPE_NON_STANDARD",
        "SCRIPT_TYPE_WITNESS_UNKNOWN"
      ],
      "type": "string"
    },
    "lnrpcPayReq": {
      "properties": {
        "cltv_expiry": {
          "format": "int64",
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "description_hash": {
          "type": "string"
        },
        "destination": {
          "type": "string"
        },
        "expiry": {
          "format": "int64",
          "type": "string"
        },
        "fallback_addr": {
          "type": "string"
        },
        "features": {
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcFeature"
          },
          "type": "object"
        },
        "num_msat": {
          "format": "int64",
          "type": "string"
        },
        "num_satoshis": {
          "format": "int64",
          "type": "string"
        },
        "payment_addr": {
          "format": "byte",
          "type": "string"
        },
        "payment_hash": {
          "type": "string"
        },
        "route_hints": {
          "items": {
            "$ref": "#/definitions/lnrpcRouteHint"
          },
          "type": "array"
        },
        "timestamp": {
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcPayment": {
      "properties": {
        "creation_date": {
          "format": "int64",
          "title": "Deprecated, use creation_time_ns",
          "type": "string"
        },
        "creation_time_ns": {
          "description": "The time in UNIX nanoseconds at which the payment was created.",
          "format": "int64",
          "type": "string"
        },
        "failure_reason": {
          "$ref": "#/definitions/lnrpcPaymentFailureReason"
        },
        "fee": {
          "description": "Deprecated, use fee_sat or fee_msat.",
          "format": "int64",
          "type": "string"
        },
        "fee_msat": {
          "format": "int64",
          "title": "The fee paid for this payment in milli-satoshis",
          "type": "string"
        },
        "fee_sat": {
          "format": "int64",
          "title": "The fee paid for this payment in satoshis",
          "type": "string"
        },
        "htlcs": {
          "description": "The HTLCs made in attempt to settle the payment.",
          "items": {
            "$ref": "#/definitions/lnrpcHTLCAttempt"
          },
          "type": "array"
        },
        "payment_hash": {
          "title": "The payment hash",
          "type": "string"
        },
        "payment_index": {
          "description": "The creation index of this payment. Each payment can be uniquely identified\nby this index, which may not strictly increment by 1 for payments made in\nolder versions of lnd.",
          "format": "uint64",
          "type": "string"
        },
        "payment_preimage": {
          "title": "The payment preimage",
          "type": "string"
        },
        "payment_request": {
          "description": "The optional payment request being fulfilled.",
          "type": "string"
        },
        "status": {
          "$ref": "#/definitions/PaymentPaymentStatus",
          "description": "The status of the payment."
        },
        "value": {
          "description": "Deprecated, use value_sat or value_msat.",
          "format": "int64",
          "type": "string"
        },
        "value_msat": {
          "format": "int64",
          "title": "The value of the payment in milli-satoshis",
          "type": "string"
        },
        "value_sat": {
          "format": "int64",
          "title": "The value of the payment in satoshis",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcPaymentFailureReason": {
      "default": "FAILURE_REASON_NONE",
      "description": " - FAILURE_REASON_NONE: Payment isn't failed (yet).\n - FAILURE_REASON_TIMEOUT: There are more routes to try, but the payment timeout was exceeded.\n - FAILURE_REASON_NO_ROUTE: All possible routes were tried and failed permanently. Or were no\nroutes to the destination at all.\n - FAILURE_REASON_ERROR: A non-recoverable error has occured.\n - FAILURE_REASON_INCORRECT_PAYMENT_DETAILS: Payment details incorrect (unknown hash, invalid amt or\ninvalid final cltv delta)\n - FAILURE_REASON_INSUFFICIENT_BALANCE: Insufficient local balance.",
      "enum": [
        "FAILURE_REASON_NONE",
        "FAILURE_REASON_TIMEOUT",
        "FAILURE_REASON_NO_ROUTE",
        "FAILURE_REASON_ERROR",
        "FAILURE_REASON_INCORRECT_PAYMENT_DETAILS",
        "FAILURE_REASON_INSUFFICIENT_BALANCE"
      ],
      "type": "string"
    },
    "lnrpcPaymentPaymentStatus": {
      "default": "UNKNOWN",
      "enum": [
        "UNKNOWN",
        "IN_FLIGHT",
        "SUCCEEDED",
        "FAILED"
      ],
      "type": "string"
    },
    "lnrpcPeer": {
      "properties": {
        "address": {
          "title": "Network address of the peer; eg `127.0.0.1:10011`",
          "type": "string"
        },
        "bytes_recv": {
          "format": "uint64",
          "title": "Bytes of data transmitted from this peer",
          "type": "string"
        },
        "bytes_sent": {
          "format": "uint64",
          "title": "Bytes of data transmitted to this peer",
          "type": "string"
        },
        "errors": {
          "description": "The latest errors received from our peer with timestamps, limited to the 10\nmost recent errors. These errors are tracked across peer connections, but\nare not persisted across lnd restarts. Note that these errors are only\nstored for peers that we have channels open with, to prevent peers from\nspamming us with errors at no cost.",
          "items": {
            "$ref": "#/definitions/lnrpcTimestampedError"
          },
          "type": "array"
        },
        "features": {
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcFeature"
          },
          "description": "Features advertised by the remote peer in their init message.",
          "type": "object"
        },
        "flap_count": {
          "description": "The number of times we have recorded this peer going offline or coming\nonline, recorded across restarts. Note that this value is decreased over\ntime if the peer has not recently flapped, so that we can forgive peers\nwith historically high flap counts.",
          "format": "int32",
          "type": "integer"
        },
        "inbound": {
          "title": "A channel is inbound if the counterparty initiated the channel",
          "type": "boolean"
        },
        "last_flap_ns": {
          "description": "The timestamp of the last flap we observed for this peer. If this value is\nzero, we have not observed any flaps for this peer.",
          "format": "int64",
          "type": "string"
        },
        "last_ping_payload": {
          "description": "The last ping payload the peer has sent to us.",
          "format": "byte",
          "type": "string"
        },
        "ping_time": {
          "format": "int64",
          "title": "Ping time to this peer",
          "type": "string"
        },
        "pub_key": {
          "title": "The identity pubkey of the peer",
          "type": "string"
        },
        "sat_recv": {
          "format": "int64",
          "title": "Satoshis received from this peer",
          "type": "string"
        },
        "sat_sent": {
          "format": "int64",
          "title": "Satoshis sent to this peer",
          "type": "string"
        },
        "sync_type": {
          "$ref": "#/definitions/PeerSyncType",
          "description": "The type of sync we are currently performing with this peer."
        }
      },
      "type": "object"
    },
    "lnrpcPeerEvent": {
      "properties": {
        "pub_key": {
          "description": "The identity pubkey of the peer.",
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/PeerEventEventType"
        }
      },
      "type": "object"
    },
    "lnrpcPendingChannelsResponse": {
      "properties": {
        "pending_closing_channels": {
          "description": "Deprecated: Channels pending closing previously contained cooperatively\nclosed channels with a single confirmation. These channels are now\nconsidered closed from the time we see them on chain.",
          "items": {
            "$ref": "#/definitions/PendingChannelsResponseClosedChannel"
          },
          "type": "array"
        },
        "pending_force_closing_channels": {
          "items": {
            "$ref": "#/definitions/PendingChannelsResponseForceClosedChannel"
          },
          "title": "Channels pending force closing",
          "type": "array"
        },
        "pending_open_channels": {
          "items": {
            "$ref": "#/definitions/PendingChannelsResponsePendingOpenChannel"
          },
          "title": "Channels pending opening",
          "type": "array"
        },
        "total_limbo_balance": {
          "format": "int64",
          "title": "The balance in satoshis encumbered in pending channels",
          "type": "string"
        },
        "waiting_close_channels": {
          "items": {
            "$ref": "#/definitions/PendingChannelsResponseWaitingCloseChannel"
          },
          "title": "Channels waiting for closing tx to confirm",
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcPendingHTLC": {
      "properties": {
        "amount": {
          "format": "int64",
          "title": "The total value of the htlc",
          "type": "string"
        },
        "blocks_til_maturity": {
          "description": "The number of blocks remaining until the current stage can be swept.\nNegative values indicate how many blocks have passed since becoming\nmature.",
          "format": "int32",
          "type": "integer"
        },
        "incoming": {
          "title": "The direction within the channel that the htlc was sent",
          "type": "boolean"
        },
        "maturity_height": {
          "format": "int64",
          "title": "The next block height at which we can spend the current stage",
          "type": "integer"
        },
        "outpoint": {
          "title": "The final output to be swept back to the user's wallet",
          "type": "string"
        },
        "stage": {
          "format": "int64",
          "title": "Indicates whether the htlc is in its first or second stage of recovery",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcPendingUpdate": {
      "properties": {
        "output_index": {
          "format": "int64",
          "type": "integer"
        },
        "txid": {
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcPolicyUpdateRequest": {
      "properties": {
        "base_fee_msat": {
          "description": "The base fee charged regardless of the number of milli-satoshis sent.",
          "format": "int64",
          "type": "string"
        },
        "chan_point": {
          "$ref": "#/definitions/lnrpcChannelPoint",
          "description": "If set, this update will target a specific channel."
        },
        "fee_rate": {
          "description": "The effective fee rate in milli-satoshis. The precision of this value\ngoes up to 6 decimal places, so 1e-6.",
          "format": "double",
          "type": "number"
        },
        "fee_rate_ppm": {
          "description": "The effective fee rate in micro-satoshis (parts per million).",
          "format": "int64",
          "type": "integer"
        },
        "global": {
          "description": "If set, then this update applies to all currently active channels.",
          "type": "boolean"
        },
        "max_htlc_msat": {
          "description": "If set, the maximum HTLC size in milli-satoshis. If unset, the maximum\nHTLC will be unchanged.",
          "format": "uint64",
          "type": "string"
        },
        "min_htlc_msat": {
          "description": "The minimum HTLC size in milli-satoshis. Only applied if\nmin_htlc_msat_specified is true.",
          "format": "uint64",
          "type": "string"
        },
        "min_htlc_msat_specified": {
          "description": "If true, min_htlc_msat is applied.",
          "type": "boolean"
        },
        "time_lock_delta": {
          "description": "The required timelock delta for HTLCs forwarded over the channel.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcPolicyUpdateResponse": {
      "properties": {
        "failed_updates": {
          "description": "List of failed policy updates.",
          "items": {
            "$ref": "#/definitions/lnrpcFailedUpdate"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcPreviousOutPoint": {
      "properties": {
        "is_our_output": {
          "description": "Denotes if the outpoint is controlled by the internal wallet.\nThe flag will only detect p2wkh, np2wkh and p2tr inputs as its own.",
          "type": "boolean"
        },
        "outpoint": {
          "description": "The outpoint in format txid:n.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcPsbtShim": {
      "properties": {
        "base_psbt": {
          "description": "An optional base PSBT the new channel output will be added to. If this is\nnon-empty, it must be a binary serialized PSBT.",
          "format": "byte",
          "type": "string"
        },
        "no_publish": {
          "description": "If a channel should be part of a batch (multiple channel openings in one\ntransaction), it can be dangerous if the whole batch transaction is\npublished too early before all channel opening negotiations are completed.\nThis flag prevents this particular channel from broadcasting the transaction\nafter the negotiation with the remote peer. In a batch of channel openings\nthis flag should be set to true for every channel but the very last.",
          "type": "boolean"
        },
        "pending_chan_id": {
          "description": "A unique identifier of 32 random bytes that will be used as the pending\nchannel ID to identify the PSBT state machine when interacting with it and\non the wire protocol to initiate the funding request.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcQueryRoutesResponse": {
      "properties": {
        "routes": {
          "description": "The route that results from the path finding operation. This is still a\nrepeated field to retain backwards compatibility.",
          "items": {
            "$ref": "#/definitions/lnrpcRoute"
          },
          "type": "array"
        },
        "success_prob": {
          "format": "double",
          "title": "The success probability of the returned route based on the current mission\ncontrol state. [EXPERIMENTAL]",
          "type": "number"
        }
      },
      "type": "object"
    },
    "lnrpcRPCMessage": {
      "properties": {
        "is_error": {
          "description": "Indicates that the response from lnd was an error, not a gRPC response. If\nthis is set to true then the type_name contains the string \"error\" and\nserialized contains the error string.",
          "type": "boolean"
        },
        "method_full_uri": {
          "description": "The full URI (in the format /\u003crpcpackage\u003e.\u003cServiceName\u003e/MethodName, for\nexample /lnrpc.Lightning/GetInfo) of the RPC method the message was sent\nto/from.",
          "type": "string"
        },
        "serialized": {
          "description": "The full content of the gRPC message, serialized in the binary protobuf\nformat.",
          "format": "byte",
          "type": "string"
        },
        "stream_rpc": {
          "description": "Indicates whether the message was sent over a streaming RPC method or not.",
          "type": "boolean"
        },
        "type_name": {
          "description": "The full canonical gRPC name of the message type (in the format\n\u003crpcpackage\u003e.TypeName, for example lnrpc.GetInfoRequest). In case of an\nerror being returned from lnd, this simply contains the string \"error\".",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcRPCMiddlewareRequest": {
      "properties": {
        "custom_caveat_condition": {
          "title": "The parsed condition of the macaroon's custom caveat for convenient access.\nThis field only contains the value of the custom caveat that the handling\nmiddleware has registered itself for. The condition _must_ be validated for\nmessages of intercept_type stream_auth and request!",
          "type": "string"
        },
        "msg_id": {
          "description": "The unique message ID of this middleware intercept message. There can be\nmultiple middleware intercept messages per single gRPC request (one for the\nincoming request and one for the outgoing response) or gRPC stream (one for\neach incoming message and one for each outgoing response). This message ID\nmust be referenced when responding (accepting/rejecting/modifying) to an\nintercept message.",
          "format": "uint64",
          "type": "string"
        },
        "raw_macaroon": {
          "description": "The raw bytes of the complete macaroon as sent by the gRPC client in the\noriginal request. This might be empty for a request that doesn't require\nmacaroons such as the wallet unlocker RPCs.",
          "format": "byte",
          "type": "string"
        },
        "request": {
          "$ref": "#/definitions/lnrpcRPCMessage",
          "description": "Intercept incoming gRPC client request message: all incoming messages,\nboth on streaming and unary RPCs, are forwarded to the middleware for\ninspection. For unary RPC messages the middleware is also expected to\nvalidate the custom macaroon caveat of the request."
        },
        "request_id": {
          "description": "The unique ID of the intercepted original gRPC request. Useful for mapping\nrequest to response when implementing full duplex message interception. For\nstreaming requests, this will be the same ID for all incoming and outgoing\nmiddleware intercept messages of the _same_ stream.",
          "format": "uint64",
          "type": "string"
        },
        "response": {
          "$ref": "#/definitions/lnrpcRPCMessage",
          "description": "Intercept outgoing gRPC response message: all outgoing messages, both on\nstreaming and unary RPCs, are forwarded to the middleware for inspection\nand amendment. The response in this message is the original response as\nit was generated by the main RPC server. It can either be accepted\n(=forwarded to the client), replaced/overwritten with a new message of\nthe same type, or replaced by an error message."
        },
        "stream_auth": {
          "$ref": "#/definitions/lnrpcStreamAuth",
          "description": "Intercept stream authentication: each new streaming RPC call that is\ninitiated against lnd and contains the middleware's custom macaroon\ncaveat can be approved or denied based upon the macaroon in the stream\nheader. This message will only be sent for streaming RPCs, unary RPCs\nmust handle the macaroon authentication in the request interception to\navoid an additional message round trip between lnd and the middleware."
        }
      },
      "type": "object"
    },
    "lnrpcReadyForPsbtFunding": {
      "properties": {
        "funding_address": {
          "description": "The P2WSH address of the channel funding multisig address that the below\nspecified amount in satoshis needs to be sent to.",
          "type": "string"
        },
        "funding_amount": {
          "description": "The exact amount in satoshis that needs to be sent to the above address to\nfund the pending channel.",
          "format": "int64",
          "type": "string"
        },
        "psbt": {
          "description": "A raw PSBT that contains the pending channel output. If a base PSBT was\nprovided in the PsbtShim, this is the base PSBT with one additional output.\nIf no base PSBT was specified, this is an otherwise empty PSBT with exactly\none output.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcResolution": {
      "properties": {
        "amount_sat": {
          "description": "The amount that was claimed by the resolution.",
          "format": "uint64",
          "type": "string"
        },
        "outcome": {
          "$ref": "#/definitions/lnrpcResolutionOutcome",
          "description": "The outcome of our on chain action that resolved the outpoint."
        },
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "description": "The outpoint that was spent by the resolution."
        },
        "resolution_type": {
          "$ref": "#/definitions/lnrpcResolutionType",
          "description": "The type of output we are resolving."
        },
        "sweep_txid": {
          "description": "The hex-encoded transaction ID of the sweep transaction that spent the\noutput.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcResolutionOutcome": {
      "default": "OUTCOME_UNKNOWN",
      "description": " - OUTCOME_UNKNOWN: Outcome unknown.\n - CLAIMED: An output was claimed on chain.\n - UNCLAIMED: An output was left unclaimed on chain.\n - ABANDONED: ResolverOutcomeAbandoned indicates that an output that we did not\nclaim on chain, for example an anchor that we did not sweep and a\nthird party claimed on chain, or a htlc that we could not decode\nso left unclaimed.\n - FIRST_STAGE: If we force closed our channel, our htlcs need to be claimed in two\nstages. This outcome represents the broadcast of a timeout or success\ntransaction for this two stage htlc claim.\n - TIMEOUT: A htlc was timed out on chain.",
      "enum": [
        "OUTCOME_UNKNOWN",
        "CLAIMED",
        "UNCLAIMED",
        "ABANDONED",
        "FIRST_STAGE",
        "TIMEOUT"
      ],
      "type": "string"
    },
    "lnrpcResolutionType": {
      "default": "TYPE_UNKNOWN",
      "description": " - ANCHOR: We resolved an anchor output.\n - INCOMING_HTLC: We are resolving an incoming htlc on chain. This if this htlc is\nclaimed, we swept the incoming htlc with the preimage. If it is timed\nout, our peer swept the timeout path.\n - OUTGOING_HTLC: We are resolving an outgoing htlc on chain. If this htlc is claimed,\nthe remote party swept the htlc with the preimage. If it is timed out,\nwe swept it with the timeout path.\n - COMMIT: We force closed and need to sweep our time locked commitment output.",
      "enum": [
        "TYPE_UNKNOWN",
        "ANCHOR",
        "INCOMING_HTLC",
        "OUTGOING_HTLC",
        "COMMIT"
      ],
      "type": "string"
    },
    "lnrpcRestoreBackupResponse": {
      "type": "object"
    },
    "lnrpcRestoreChanBackupRequest": {
      "properties": {
        "chan_backups": {
          "$ref": "#/definitions/lnrpcChannelBackups",
          "description": "The channels to restore as a list of channel/backup pairs."
        },
        "multi_chan_backup": {
          "description": "The channels to restore in the packed multi backup format. When using\nREST, this field must be encoded as base64.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcRoute": {
      "description": "A path through the channel graph which runs over one or more channels in\nsuccession. This struct carries all the information required to craft the\nSphinx onion packet, and send the payment along the first hop in the path. A\nroute is only selected as valid if all the channels have sufficient capacity to\ncarry the initial payment amount after fees are accounted for.",
      "properties": {
        "hops": {
          "description": "Contains details concerning the specific forwarding details at each hop.",
          "items": {
            "$ref": "#/definitions/lnrpcHop"
          },
          "type": "array"
        },
        "total_amt": {
          "description": "The total amount of funds required to complete a payment over this route.\nThis value includes the cumulative fees at each hop. As a result, the HTLC\nextended to the first-hop in the route will need to have at least this many\nsatoshis, otherwise the route will fail at an intermediate node due to an\ninsufficient amount of fees.",
          "format": "int64",
          "type": "string"
        },
        "total_amt_msat": {
          "description": "The total amount in millisatoshis.",
          "format": "int64",
          "type": "string"
        },
        "total_fees": {
          "description": "The sum of the fees paid at each hop within the final route. In the case\nof a one-hop payment, this value will be zero as we don't need to pay a fee\nto ourselves.",
          "format": "int64",
          "type": "string"
        },
        "total_fees_msat": {
          "description": "The total fees in millisatoshis.",
          "format": "int64",
          "type": "string"
        },
        "total_time_lock": {
          "description": "The cumulative (final) time lock across the entire route. This is the CLTV\nvalue that should be extended to the first hop in the route. All other hops\nwill decrement the time-lock as advertised, leaving enough time for all\nhops to wait for or present the payment preimage to complete the payment.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcRouteHint": {
      "properties": {
        "hop_hints": {
          "description": "A list of hop hints that when chained together can assist in reaching a\nspecific destination.",
          "items": {
            "$ref": "#/definitions/lnrpcHopHint"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcRoutingPolicy": {
      "properties": {
        "disabled": {
          "type": "boolean"
        },
        "fee_base_msat": {
          "format": "int64",
          "type": "string"
        },
        "fee_rate_milli_msat": {
          "format": "int64",
          "type": "string"
        },
        "last_update": {
          "format": "int64",
          "type": "integer"
        },
        "max_htlc_msat": {
          "format": "uint64",
          "type": "string"
        },
        "min_htlc": {
          "format": "int64",
          "type": "string"
        },
        "time_lock_delta": {
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcSendCoinsRequest": {
      "properties": {
        "addr": {
          "title": "The address to send coins to",
          "type": "string"
        },
        "amount": {
          "format": "int64",
          "title": "The amount in satoshis to send",
          "type": "string"
        },
        "label": {
          "description": "An optional label for the transaction, limited to 500 characters.",
          "type": "string"
        },
        "min_confs": {
          "description": "The minimum number of confirmations each one of your outputs used for\nthe transaction must satisfy.",
          "format": "int32",
          "type": "integer"
        },
        "sat_per_byte": {
          "description": "Deprecated, use sat_per_vbyte.\nA manual fee rate set in sat/vbyte that should be used when crafting the\ntransaction.",
          "format": "int64",
          "type": "string"
        },
        "sat_per_vbyte": {
          "description": "A manual fee rate set in sat/vbyte that should be used when crafting the\ntransaction.",
          "format": "uint64",
          "type": "string"
        },
        "send_all": {
          "description": "If set, then the amount field will be ignored, and lnd will attempt to\nsend all the coins under control of the internal wallet to the specified\naddress.",
          "type": "boolean"
        },
        "spend_unconfirmed": {
          "description": "Whether unconfirmed outputs should be used as inputs for the transaction.",
          "type": "boolean"
        },
        "target_conf": {
          "description": "The target number of blocks that this transaction should be confirmed\nby.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcSendCoinsResponse": {
      "properties": {
        "txid": {
          "title": "The transaction ID of the transaction",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcSendCustomMessageRequest": {
      "properties": {
        "data": {
          "description": "Raw message data.",
          "format": "byte",
          "type": "string"
        },
        "peer": {
          "format": "byte",
          "title": "Peer to send the message to",
          "type": "string"
        },
        "type": {
          "description": "Message type. This value needs to be in the custom range (\u003e= 32768).",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcSendCustomMessageResponse": {
      "type": "object"
    },
    "lnrpcSendManyRequest": {
      "properties": {
        "AddrToAmount": {
          "additionalProperties": {
            "format": "int64",
            "type": "string"
          },
          "title": "The map from addresses to amounts",
          "type": "object"
        },
        "label": {
          "description": "An optional label for the transaction, limited to 500 characters.",
          "type": "string"
        },
        "min_confs": {
          "description": "The minimum number of confirmations each one of your outputs used for\nthe transaction must satisfy.",
          "format": "int32",
          "type": "integer"
        },
        "sat_per_byte": {
          "description": "Deprecated, use sat_per_vbyte.\nA manual fee rate set in sat/vbyte that should be used when crafting the\ntransaction.",
          "format": "int64",
          "type": "string"
        },
        "sat_per_vbyte": {
          "description": "A manual fee rate set in sat/vbyte that should be used when crafting the\ntransaction.",
          "format": "uint64",
          "type": "string"
        },
        "spend_unconfirmed": {
          "description": "Whether unconfirmed outputs should be used as inputs for the transaction.",
          "type": "boolean"
        },
        "target_conf": {
          "description": "The target number of blocks that this transaction should be confirmed\nby.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "lnrpcSendManyResponse": {
      "properties": {
        "txid": {
          "title": "The id of the transaction",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcSendRequest": {
      "properties": {
        "allow_self_payment": {
          "description": "If set, circular payments to self are permitted.",
          "type": "boolean"
        },
        "amt": {
          "description": "The amount to send expressed in satoshis.\n\nThe fields amt and amt_msat are mutually exclusive.",
          "format": "int64",
          "type": "string"
        },
        "amt_msat": {
          "description": "The amount to send expressed in millisatoshis.\n\nThe fields amt and amt_msat are mutually exclusive.",
          "format": "int64",
          "type": "string"
        },
        "cltv_limit": {
          "description": "An optional maximum total time lock for the route. This should not exceed\nlnd's `--max-cltv-expiry` setting. If zero, then the value of\n`--max-cltv-expiry` is enforced.",
          "format": "int64",
          "type": "integer"
        },
        "dest": {
          "description": "The identity pubkey of the payment recipient. When using REST, this field\nmust be encoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "dest_custom_records": {
          "additionalProperties": {
            "format": "byte",
            "type": "string"
          },
          "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto a peer which understands the new records. This can be used to pass\napplication specific data during the payment attempt. Record types are\nrequired to be in the custom range \u003e= 65536. When using REST, the values\nmust be encoded as base64.",
          "type": "object"
        },
        "dest_features": {
          "description": "Features assumed to be supported by the final node. All transitive feature\ndependencies must also be set properly. For a given feature bit pair, either\noptional or remote may be set, but not both. If this field is nil or empty,\nthe router will try to load destination features from the graph as a\nfallback.",
          "items": {
            "$ref": "#/definitions/lnrpcFeatureBit"
          },
          "type": "array"
        },
        "dest_string": {
          "description": "The hex-encoded identity pubkey of the payment recipient. Deprecated now\nthat the REST gateway supports base64 encoding of bytes fields.",
          "type": "string"
        },
        "fee_limit": {
          "$ref": "#/definitions/lnrpcFeeLimit",
          "description": "The maximum number of satoshis that will be paid as a fee of the payment.\nThis value can be represented either as a percentage of the amount being\nsent, or as a fixed amount of the maximum fee the user is willing the pay to\nsend the payment. If not specified, lnd will use a default value of 100%\nfees for small amounts (\u003c=1k sat) or 5% fees for larger amounts."
        },
        "final_cltv_delta": {
          "description": "The CLTV delta from the current height that should be used to set the\ntimelock for the final hop.",
          "format": "int32",
          "type": "integer"
        },
        "last_hop_pubkey": {
          "description": "The pubkey of the last hop of the route. If empty, any hop may be used.",
          "format": "byte",
          "type": "string"
        },
        "outgoing_chan_id": {
          "description": "The channel id of the channel that must be taken to the first hop. If zero,\nany channel may be used.",
          "format": "uint64",
          "type": "string"
        },
        "payment_addr": {
          "description": "The payment address of the generated invoice.",
          "format": "byte",
          "type": "string"
        },
        "payment_hash": {
          "description": "The hash to use within the payment's HTLC. When using REST, this field\nmust be encoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "payment_hash_string": {
          "description": "The hex-encoded hash to use within the payment's HTLC. Deprecated now\nthat the REST gateway supports base64 encoding of bytes fields.",
          "type": "string"
        },
        "payment_request": {
          "description": "A bare-bones invoice for a payment within the Lightning Network. With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcSendResponse": {
      "properties": {
        "payment_error": {
          "type": "string"
        },
        "payment_hash": {
          "format": "byte",
          "type": "string"
        },
        "payment_preimage": {
          "format": "byte",
          "type": "string"
        },
        "payment_route": {
          "$ref": "#/definitions/lnrpcRoute"
        }
      },
      "type": "object"
    },
    "lnrpcSendToRouteRequest": {
      "properties": {
        "payment_hash": {
          "description": "The payment hash to use for the HTLC. When using REST, this field must be\nencoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "payment_hash_string": {
          "description": "An optional hex-encoded payment hash to be used for the HTLC. Deprecated now\nthat the REST gateway supports base64 encoding of bytes fields.",
          "type": "string"
        },
        "route": {
          "$ref": "#/definitions/lnrpcRoute",
          "description": "Route that should be used to attempt to complete the payment."
        }
      },
      "type": "object"
    },
    "lnrpcSignMessageRequest": {
      "properties": {
        "msg": {
          "description": "The message to be signed. When using REST, this field must be encoded as\nbase64.",
          "format": "byte",
          "type": "string"
        },
        "single_hash": {
          "description": "Instead of the default double-SHA256 hashing of the message before signing,\nonly use one round of hashing instead.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcSignMessageResponse": {
      "properties": {
        "signature": {
          "title": "The signature for the given message",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcStopRequest": {
      "type": "object"
    },
    "lnrpcStopResponse": {
      "type": "object"
    },
    "lnrpcStreamAuth": {
      "properties": {
        "method_full_uri": {
          "description": "The full URI (in the format /\u003crpcpackage\u003e.\u003cServiceName\u003e/MethodName, for\nexample /lnrpc.Lightning/GetInfo) of the streaming RPC method that was just\nestablished.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcSubscribeStateResponse": {
      "properties": {
        "state": {
          "$ref": "#/definitions/lnrpcWalletState"
        }
      },
      "type": "object"
    },
    "lnrpcTimestampedError": {
      "properties": {
        "error": {
          "description": "The string representation of the error sent by our peer.",
          "type": "string"
        },
        "timestamp": {
          "description": "The unix timestamp in seconds when the error occurred.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcTransaction": {
      "properties": {
        "amount": {
          "format": "int64",
          "title": "The transaction amount, denominated in satoshis",
          "type": "string"
        },
        "block_hash": {
          "title": "The hash of the block this transaction was included in",
          "type": "string"
        },
        "block_height": {
          "format": "int32",
          "title": "The height of the block this transaction was included in",
          "type": "integer"
        },
        "dest_addresses": {
          "description": "Addresses that received funds for this transaction. Deprecated as it is\nnow incorporated in the output_details field.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "label": {
          "description": "A label that was optionally set on transaction broadcast.",
          "type": "string"
        },
        "num_confirmations": {
          "format": "int32",
          "title": "The number of confirmations",
          "type": "integer"
        },
        "output_details": {
          "items": {
            "$ref": "#/definitions/lnrpcOutputDetail"
          },
          "title": "Outputs that received funds for this transaction",
          "type": "array"
        },
        "previous_outpoints": {
          "description": "PreviousOutpoints/Inputs of this transaction.",
          "items": {
            "$ref": "#/definitions/lnrpcPreviousOutPoint"
          },
          "type": "array"
        },
        "raw_tx_hex": {
          "description": "The raw transaction hex.",
          "type": "string"
        },
        "time_stamp": {
          "format": "int64",
          "title": "Timestamp of this transaction",
          "type": "string"
        },
        "total_fees": {
          "format": "int64",
          "title": "Fees paid for this transaction",
          "type": "string"
        },
        "tx_hash": {
          "title": "The transaction hash",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcTransactionDetails": {
      "properties": {
        "transactions": {
          "description": "The list of transactions relevant to the wallet.",
          "items": {
            "$ref": "#/definitions/lnrpcTransaction"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "lnrpcUnlockWalletRequest": {
      "properties": {
        "channel_backups": {
          "$ref": "#/definitions/lnrpcChanBackupSnapshot",
          "description": "channel_backups is an optional argument that allows clients to recover the\nsettled funds within a set of channels. This should be populated if the\nuser was unable to close out all channels and sweep funds before partial or\ntotal data loss occurred. If specified, then after on-chain recovery of\nfunds, lnd begin to carry out the data loss recovery protocol in order to\nrecover the funds in each channel from a remote force closed transaction."
        },
        "recovery_window": {
          "description": "recovery_window is an optional argument specifying the address lookahead\nwhen restoring a wallet seed. The recovery window applies to each\nindividual branch of the BIP44 derivation paths. Supplying a recovery\nwindow of zero indicates that no addresses should be recovered, such after\nthe first initialization of the wallet.",
          "format": "int32",
          "type": "integer"
        },
        "stateless_init": {
          "description": "stateless_init is an optional argument instructing the daemon NOT to create\nany *.macaroon files in its file system.",
          "type": "boolean"
        },
        "wallet_password": {
          "description": "wallet_password should be the current valid passphrase for the daemon. This\nwill be required to decrypt on-disk material that the daemon requires to\nfunction properly. When using REST, this field must be encoded as base64.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcUnlockWalletResponse": {
      "type": "object"
    },
    "lnrpcUpdateFailure": {
      "default": "UPDATE_FAILURE_UNKNOWN",
      "enum": [
        "UPDATE_FAILURE_UNKNOWN",
        "UPDATE_FAILURE_PENDING",
        "UPDATE_FAILURE_NOT_FOUND",
        "UPDATE_FAILURE_INTERNAL_ERR",
        "UPDATE_FAILURE_INVALID_PARAMETER"
      ],
      "type": "string"
    },
    "lnrpcUtxo": {
      "properties": {
        "address": {
          "title": "The address",
          "type": "string"
        },
        "address_type": {
          "$ref": "#/definitions/lnrpcAddressType",
          "title": "The type of address"
        },
        "amount_sat": {
          "format": "int64",
          "title": "The value of the unspent coin in satoshis",
          "type": "string"
        },
        "confirmations": {
          "format": "int64",
          "title": "The number of confirmations for the Utxo",
          "type": "string"
        },
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "title": "The outpoint in format txid:n"
        },
        "pk_script": {
          "title": "The pkscript in hex",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcVerifyChanBackupResponse": {
      "type": "object"
    },
    "lnrpcVerifyMessageRequest": {
      "properties": {
        "msg": {
          "description": "The message over which the signature is to be verified. When using REST,\nthis field must be encoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "signature": {
          "title": "The signature to be verified over the given message",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcVerifyMessageResponse": {
      "properties": {
        "pubkey": {
          "title": "The pubkey recovered from the signature",
          "type": "string"
        },
        "valid": {
          "title": "Whether the signature was valid over the given message",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "lnrpcWalletAccountBalance": {
      "properties": {
        "confirmed_balance": {
          "description": "The confirmed balance of the account (with \u003e= 1 confirmations).",
          "format": "int64",
          "type": "string"
        },
        "unconfirmed_balance": {
          "description": "The unconfirmed balance of the account (with 0 confirmations).",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcWalletBalanceResponse": {
      "properties": {
        "account_balance": {
          "additionalProperties": {
            "$ref": "#/definitions/lnrpcWalletAccountBalance"
          },
          "description": "A mapping of each wallet account's name to its balance.",
          "type": "object"
        },
        "confirmed_balance": {
          "format": "int64",
          "title": "The confirmed balance of a wallet(with \u003e= 1 confirmations)",
          "type": "string"
        },
        "locked_balance": {
          "description": "The total amount of wallet UTXOs held in outputs that are locked for\nother usage.",
          "format": "int64",
          "type": "string"
        },
        "reserved_balance_anchor_chan": {
          "description": "The amount of reserve required.",
          "format": "int64",
          "type": "string"
        },
        "total_balance": {
          "format": "int64",
          "title": "The balance of the wallet",
          "type": "string"
        },
        "unconfirmed_balance": {
          "format": "int64",
          "title": "The unconfirmed balance of a wallet(with 0 confirmations)",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcWalletState": {
      "default": "NON_EXISTING",
      "description": " - SERVER_ACTIVE: SERVER_ACTIVE means that the lnd server is ready to accept calls.",
      "enum": [
        "NON_EXISTING",
        "LOCKED",
        "UNLOCKED",
        "RPC_ACTIVE",
        "SERVER_ACTIVE",
        "WAITING_TO_START"
      ],
      "type": "string"
    },
    "lnrpcWatchOnly": {
      "properties": {
        "accounts": {
          "description": "The list of accounts to import. There _must_ be an account for all of lnd's\nmain key scopes: BIP49/BIP84 (m/49'/0'/0', m/84'/0'/0', note that the\ncoin type is always 0, even for testnet/regtest) and lnd's internal key\nscope (m/1017'/\u003ccoin_type\u003e'/\u003caccount\u003e'), where account is the key family as\ndefined in `keychain/derivation.go` (currently indices 0 to 9).",
          "items": {
            "$ref": "#/definitions/lnrpcWatchOnlyAccount"
          },
          "type": "array"
        },
        "master_key_birthday_timestamp": {
          "description": "The unix timestamp in seconds of when the master key was created. lnd will\nonly start scanning for funds in blocks that are after the birthday which\ncan speed up the process significantly. If the birthday is not known, this\nshould be left at its default value of 0 in which case lnd will start\nscanning from the first SegWit block (481824 on mainnet).",
          "format": "uint64",
          "type": "string"
        },
        "master_key_fingerprint": {
          "description": "The fingerprint of the root key (also known as the key with derivation path\nm/) from which the account public keys were derived from. This may be\nrequired by some hardware wallets for proper identification and signing. The\nbytes must be in big-endian order.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "lnrpcWatchOnlyAccount": {
      "properties": {
        "account": {
          "format": "int64",
          "title": "Account is the third number in the derivation path. For purposes 49 and 84\nat least the default account (index 0) needs to be created but optional\nadditional accounts are allowed. For purpose 1017 there needs to be exactly\none account for each of the key families defined in `keychain/derivation.go`\n(currently indices 0 to 9)",
          "type": "integer"
        },
        "coin_type": {
          "description": "Coin type is the second number in the derivation path, this is _always_ 0\nfor purposes 49 and 84. It only needs to be set to 1 for purpose 1017 on\ntestnet or regtest.",
          "format": "int64",
          "type": "integer"
        },
        "purpose": {
          "description": "Purpose is the first number in the derivation path, must be either 49, 84\nor 1017.",
          "format": "int64",
          "type": "integer"
        },
        "xpub": {
          "description": "The extended public key at depth 3 for the given account.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "neutrinorpcAddPeerRequest": {
      "properties": {
        "peer_addrs": {
          "description": "Peer to add.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "neutrinorpcAddPeerResponse": {
      "type": "object"
    },
    "neutrinorpcDisconnectPeerRequest": {
      "properties": {
        "peer_addrs": {
          "description": "Peer to disconnect.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "neutrinorpcDisconnectPeerResponse": {
      "type": "object"
    },
    "neutrinorpcGetBlockHeaderResponse": {
      "properties": {
        "bits": {
          "description": "The bits in hex notation.",
          "type": "string"
        },
        "confirmations": {
          "description": "The number of confirmations.",
          "format": "int64",
          "type": "string"
        },
        "hash": {
          "description": "The block hash (same as provided).",
          "type": "string"
        },
        "height": {
          "description": "The block height or index.",
          "format": "int32",
          "type": "integer"
        },
        "merkleroot": {
          "description": "The merkle root.",
          "type": "string"
        },
        "nonce": {
          "description": "The nonce.",
          "format": "int64",
          "type": "integer"
        },
        "ntx": {
          "description": "The number of transactions in the block.",
          "format": "int32",
          "type": "integer"
        },
        "previous_block_hash": {
          "description": "The hash of the previous block.",
          "type": "string"
        },
        "raw_hex": {
          "description": "The raw hex of the block.",
          "format": "byte",
          "type": "string"
        },
        "size": {
          "description": "The block size (bytes).",
          "format": "int64",
          "type": "string"
        },
        "stripped_size": {
          "description": "The block size excluding witness data.",
          "format": "int64",
          "type": "string"
        },
        "time": {
          "description": "The block time in seconds since epoch (Jan 1 1970 GMT).",
          "format": "int64",
          "type": "string"
        },
        "version": {
          "description": "The block version.",
          "format": "int32",
          "type": "integer"
        },
        "version_hex": {
          "description": "The block version.",
          "type": "string"
        },
        "weight": {
          "description": "The block weight as defined in BIP 141.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "neutrinorpcGetBlockResponse": {
      "properties": {
        "bits": {
          "description": "The bits in hex notation.",
          "type": "string"
        },
        "confirmations": {
          "description": "The number of confirmations.",
          "format": "int64",
          "type": "string"
        },
        "hash": {
          "description": "The block hash (same as provided).",
          "type": "string"
        },
        "height": {
          "description": "The block height or index.",
          "format": "int32",
          "type": "integer"
        },
        "merkleroot": {
          "description": "The merkle root.",
          "type": "string"
        },
        "nonce": {
          "description": "The nonce.",
          "format": "int64",
          "type": "integer"
        },
        "ntx": {
          "description": "The number of transactions in the block.",
          "format": "int32",
          "type": "integer"
        },
        "previous_block_hash": {
          "description": "The hash of the previous block.",
          "type": "string"
        },
        "raw_hex": {
          "description": "The raw hex of the block.",
          "format": "byte",
          "type": "string"
        },
        "size": {
          "description": "The block size (bytes).",
          "format": "int64",
          "type": "string"
        },
        "stripped_size": {
          "description": "The block size excluding witness data.",
          "format": "int64",
          "type": "string"
        },
        "time": {
          "description": "The block time in seconds since epoch (Jan 1 1970 GMT).",
          "format": "int64",
          "type": "string"
        },
        "tx": {
          "description": "List of transaction ids.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "version": {
          "description": "The block version.",
          "format": "int32",
          "type": "integer"
        },
        "version_hex": {
          "description": "The block version.",
          "type": "string"
        },
        "weight": {
          "description": "The block weight as defined in BIP 141.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "neutrinorpcGetCFilterResponse": {
      "properties": {
        "filter": {
          "description": "GCS filter.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "neutrinorpcIsBannedResponse": {
      "properties": {
        "banned": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "neutrinorpcStatusResponse": {
      "properties": {
        "active": {
          "description": "Indicates whether the neutrino backend is active or not.",
          "type": "boolean"
        },
        "block_hash": {
          "description": "Best block hash.",
          "type": "string"
        },
        "block_height": {
          "description": "Best block height.",
          "format": "int32",
          "type": "integer"
        },
        "peers": {
          "description": "Connected peers.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "synced": {
          "description": "Is fully synced.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "peersrpcNodeAnnouncementUpdateRequest": {
      "properties": {
        "address_updates": {
          "description": "Set of changes for the node's known addresses.",
          "items": {
            "$ref": "#/definitions/peersrpcUpdateAddressAction"
          },
          "type": "array"
        },
        "alias": {
          "description": "Alias or nick name of the node.",
          "type": "string"
        },
        "color": {
          "description": "Color is the node's color in hex code format.",
          "type": "string"
        },
        "feature_updates": {
          "description": "Set of changes for the features that the node supports.",
          "items": {
            "$ref": "#/definitions/peersrpcUpdateFeatureAction"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "peersrpcNodeAnnouncementUpdateResponse": {
      "properties": {
        "ops": {
          "items": {
            "$ref": "#/definitions/lnrpcOp"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "peersrpcUpdateAction": {
      "default": "ADD",
      "description": "UpdateAction is used to determine the kind of action we are referring to.\n\n - ADD: ADD indicates this is an \"insertion\" kind of action.\n - REMOVE: REMOVE indicates this is a \"deletion\" kind of action.",
      "enum": [
        "ADD",
        "REMOVE"
      ],
      "type": "string"
    },
    "peersrpcUpdateAddressAction": {
      "properties": {
        "action": {
          "$ref": "#/definitions/peersrpcUpdateAction",
          "description": "Determines the kind of action."
        },
        "address": {
          "description": "The address used to apply the update action.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "peersrpcUpdateFeatureAction": {
      "properties": {
        "action": {
          "$ref": "#/definitions/peersrpcUpdateAction",
          "description": "Determines the kind of action."
        },
        "feature_bit": {
          "$ref": "#/definitions/lnrpcFeatureBit",
          "description": "The feature bit used to apply the update action."
        }
      },
      "type": "object"
    },
    "protobufAny": {
      "properties": {
        "type_url": {
          "type": "string"
        },
        "value": {
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "routerrpcBuildRouteRequest": {
      "properties": {
        "amt_msat": {
          "description": "The amount to send expressed in msat. If set to zero, the minimum routable\namount is used.",
          "format": "int64",
          "type": "string"
        },
        "final_cltv_delta": {
          "format": "int32",
          "title": "CLTV delta from the current height that should be used for the timelock\nof the final hop",
          "type": "integer"
        },
        "hop_pubkeys": {
          "description": "A list of hops that defines the route. This does not include the source hop\npubkey.",
          "items": {
            "format": "byte",
            "type": "string"
          },
          "type": "array"
        },
        "outgoing_chan_id": {
          "description": "The channel id of the channel that must be taken to the first hop. If zero,\nany channel may be used.",
          "format": "uint64",
          "type": "string"
        },
        "payment_addr": {
          "description": "An optional payment addr to be included within the last hop of the route.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "routerrpcBuildRouteResponse": {
      "properties": {
        "route": {
          "$ref": "#/definitions/lnrpcRoute",
          "description": "Fully specified route that can be used to execute the payment."
        }
      },
      "type": "object"
    },
    "routerrpcChanStatusAction": {
      "default": "ENABLE",
      "enum": [
        "ENABLE",
        "DISABLE",
        "AUTO"
      ],
      "type": "string"
    },
    "routerrpcCircuitKey": {
      "properties": {
        "chan_id": {
          "description": "/ The id of the channel that the is part of this circuit.",
          "format": "uint64",
          "type": "string"
        },
        "htlc_id": {
          "description": "/ The index of the incoming htlc in the incoming channel.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "routerrpcFailureDetail": {
      "default": "UNKNOWN",
      "enum": [
        "UNKNOWN",
        "NO_DETAIL",
        "ONION_DECODE",
        "LINK_NOT_ELIGIBLE",
        "ON_CHAIN_TIMEOUT",
        "HTLC_EXCEEDS_MAX",
        "INSUFFICIENT_BALANCE",
        "INCOMPLETE_FORWARD",
        "HTLC_ADD_FAILED",
        "FORWARDS_DISABLED",
        "INVOICE_CANCELED",
        "INVOICE_UNDERPAID",
        "INVOICE_EXPIRY_TOO_SOON",
        "INVOICE_NOT_OPEN",
        "MPP_INVOICE_TIMEOUT",
        "ADDRESS_MISMATCH",
        "SET_TOTAL_MISMATCH",
        "SET_TOTAL_TOO_LOW",
        "SET_OVERPAID",
        "UNKNOWN_INVOICE",
        "INVALID_KEYSEND",
        "MPP_IN_PROGRESS",
        "CIRCULAR_ROUTE"
      ],
      "type": "string"
    },
    "routerrpcForwardEvent": {
      "properties": {
        "info": {
          "$ref": "#/definitions/routerrpcHtlcInfo",
          "description": "Info contains details about the htlc that was forwarded."
        }
      },
      "type": "object"
    },
    "routerrpcForwardFailEvent": {
      "type": "object"
    },
    "routerrpcForwardHtlcInterceptRequest": {
      "properties": {
        "custom_records": {
          "additionalProperties": {
            "format": "byte",
            "type": "string"
          },
          "description": "Any custom records that were present in the payload.",
          "type": "object"
        },
        "incoming_amount_msat": {
          "description": "The incoming htlc amount.",
          "format": "uint64",
          "type": "string"
        },
        "incoming_circuit_key": {
          "$ref": "#/definitions/routerrpcCircuitKey",
          "description": "The key of this forwarded htlc. It defines the incoming channel id and\nthe index in this channel."
        },
        "incoming_expiry": {
          "description": "The incoming htlc expiry.",
          "format": "int64",
          "type": "integer"
        },
        "onion_blob": {
          "format": "byte",
          "title": "The onion blob for the next hop",
          "type": "string"
        },
        "outgoing_amount_msat": {
          "description": "The outgoing htlc amount.",
          "format": "uint64",
          "type": "string"
        },
        "outgoing_expiry": {
          "description": "The outgoing htlc expiry.",
          "format": "int64",
          "type": "integer"
        },
        "outgoing_requested_chan_id": {
          "description": "The requested outgoing channel id for this forwarded htlc. Because of\nnon-strict forwarding, this isn't necessarily the channel over which the\npacket will be forwarded eventually. A different channel to the same peer\nmay be selected as well.",
          "format": "uint64",
          "type": "string"
        },
        "payment_hash": {
          "description": "The htlc payment hash. This value is not guaranteed to be unique per\nrequest.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "routerrpcForwardHtlcInterceptResponse": {
      "description": "*\nForwardHtlcInterceptResponse enables the caller to resolve a previously hold\nforward. The caller can choose either to:\n- `Resume`: Execute the default behavior (usually forward).\n- `Reject`: Fail the htlc backwards.\n- `Settle`: Settle this htlc with a given preimage.",
      "properties": {
        "action": {
          "$ref": "#/definitions/routerrpcResolveHoldForwardAction",
          "description": "The resolve action for this intercepted htlc."
        },
        "failure_code": {
          "$ref": "#/definitions/FailureFailureCode",
          "description": "Return the specified failure code in case the resolve action is Fail. The\nmessage data fields are populated automatically.\n\nIf a non-zero failure_code is specified, failure_message must not be set.\n\nFor backwards-compatibility reasons, TEMPORARY_CHANNEL_FAILURE is the\ndefault value for this field."
        },
        "failure_message": {
          "description": "Encrypted failure message in case the resolve action is Fail.\n\nIf failure_message is specified, the failure_code field must be set\nto zero.",
          "format": "byte",
          "type": "string"
        },
        "incoming_circuit_key": {
          "$ref": "#/definitions/routerrpcCircuitKey",
          "description": "*\nThe key of this forwarded htlc. It defines the incoming channel id and\nthe index in this channel."
        },
        "preimage": {
          "description": "The preimage in case the resolve action is Settle.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "routerrpcGetMissionControlConfigResponse": {
      "properties": {
        "config": {
          "$ref": "#/definitions/routerrpcMissionControlConfig",
          "description": "Mission control's currently active config."
        }
      },
      "type": "object"
    },
    "routerrpcHtlcEvent": {
      "properties": {
        "event_type": {
          "$ref": "#/definitions/routerrpcHtlcEventEventType",
          "description": "The event type indicates whether the htlc was part of a send, receive or\nforward."
        },
        "forward_event": {
          "$ref": "#/definitions/routerrpcForwardEvent"
        },
        "forward_fail_event": {
          "$ref": "#/definitions/routerrpcForwardFailEvent"
        },
        "incoming_channel_id": {
          "description": "The short channel id that the incoming htlc arrived at our node on. This\nvalue is zero for sends.",
          "format": "uint64",
          "type": "string"
        },
        "incoming_htlc_id": {
          "description": "Incoming id is the index of the incoming htlc in the incoming channel.\nThis value is zero for sends.",
          "format": "uint64",
          "type": "string"
        },
        "link_fail_event": {
          "$ref": "#/definitions/routerrpcLinkFailEvent"
        },
        "outgoing_channel_id": {
          "description": "The short channel id that the outgoing htlc left our node on. This value\nis zero for receives.",
          "format": "uint64",
          "type": "string"
        },
        "outgoing_htlc_id": {
          "description": "Outgoing id is the index of the outgoing htlc in the outgoing channel.\nThis value is zero for receives.",
          "format": "uint64",
          "type": "string"
        },
        "settle_event": {
          "$ref": "#/definitions/routerrpcSettleEvent"
        },
        "timestamp_ns": {
          "description": "The time in unix nanoseconds that the event occurred.",
          "format": "uint64",
          "type": "string"
        }
      },
      "title": "HtlcEvent contains the htlc event that was processed. These are served on a\nbest-effort basis; events are not persisted, delivery is not guaranteed\n(in the event of a crash in the switch, forward events may be lost) and\nsome events may be replayed upon restart. Events consumed from this package\nshould be de-duplicated by the htlc's unique combination of incoming and\noutgoing channel id and htlc id. [EXPERIMENTAL]",
      "type": "object"
    },
    "routerrpcHtlcEventEventType": {
      "default": "UNKNOWN",
      "enum": [
        "UNKNOWN",
        "SEND",
        "RECEIVE",
        "FORWARD"
      ],
      "type": "string"
    },
    "routerrpcHtlcInfo": {
      "properties": {
        "incoming_amt_msat": {
          "description": "The amount of the incoming htlc.",
          "format": "uint64",
          "type": "string"
        },
        "incoming_timelock": {
          "description": "The timelock on the incoming htlc.",
          "format": "int64",
          "type": "integer"
        },
        "outgoing_amt_msat": {
          "description": "The amount of the outgoing htlc.",
          "format": "uint64",
          "type": "string"
        },
        "outgoing_timelock": {
          "description": "The timelock on the outgoing htlc.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "routerrpcLinkFailEvent": {
      "properties": {
        "failure_detail": {
          "$ref": "#/definitions/routerrpcFailureDetail",
          "description": "FailureDetail provides additional information about the reason for the\nfailure. This detail enriches the information provided by the wire message\nand may be 'no detail' if the wire message requires no additional metadata."
        },
        "failure_string": {
          "description": "A string representation of the link failure.",
          "type": "string"
        },
        "info": {
          "$ref": "#/definitions/routerrpcHtlcInfo",
          "description": "Info contains details about the htlc that we failed."
        },
        "wire_failure": {
          "$ref": "#/definitions/FailureFailureCode",
          "description": "FailureCode is the BOLT error code for the failure."
        }
      },
      "type": "object"
    },
    "routerrpcMissionControlConfig": {
      "properties": {
        "half_life_seconds": {
          "description": "The amount of time mission control will take to restore a penalized node\nor channel back to 50% success probability, expressed in seconds. Setting\nthis value to a higher value will penalize failures for longer, making\nmission control less likely to route through nodes and channels that we\nhave previously recorded failures for.",
          "format": "uint64",
          "type": "string"
        },
        "hop_probability": {
          "description": "The probability of success mission control should assign to hop in a route\nwhere it has no other information available. Higher values will make mission\ncontrol more willing to try hops that we have no information about, lower\nvalues will discourage trying these hops.",
          "format": "float",
          "type": "number"
        },
        "maximum_payment_results": {
          "description": "The maximum number of payment results that mission control will store.",
          "format": "int64",
          "type": "integer"
        },
        "minimum_failure_relax_interval": {
          "description": "The minimum time that must have passed since the previously recorded failure\nbefore we raise the failure amount.",
          "format": "uint64",
          "type": "string"
        },
        "weight": {
          "description": "The importance that mission control should place on historical results,\nexpressed as a value in [0;1]. Setting this value to 1 will ignore all\nhistorical payments and just use the hop probability to assess the\nprobability of success for each hop. A zero value ignores hop probability\ncompletely and relies entirely on historical results, unless none are\navailable.",
          "format": "float",
          "type": "number"
        }
      },
      "type": "object"
    },
    "routerrpcPairData": {
      "properties": {
        "fail_amt_msat": {
          "description": "Lowest amount that failed to forward in millisats. This may be\nset to zero if the failure is independent of amount.",
          "format": "int64",
          "type": "string"
        },
        "fail_amt_sat": {
          "description": "Lowest amount that failed to forward rounded to whole sats. This may be\nset to zero if the failure is independent of amount.",
          "format": "int64",
          "type": "string"
        },
        "fail_time": {
          "description": "Time of last failure.",
          "format": "int64",
          "type": "string"
        },
        "success_amt_msat": {
          "description": "Highest amount that we could successfully forward in millisats.",
          "format": "int64",
          "type": "string"
        },
        "success_amt_sat": {
          "description": "Highest amount that we could successfully forward rounded to whole sats.",
          "format": "int64",
          "type": "string"
        },
        "success_time": {
          "description": "Time of last success.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "routerrpcPairHistory": {
      "description": "PairHistory contains the mission control state for a particular node pair.",
      "properties": {
        "history": {
          "$ref": "#/definitions/routerrpcPairData"
        },
        "node_from": {
          "description": "The source node pubkey of the pair.",
          "format": "byte",
          "type": "string"
        },
        "node_to": {
          "description": "The destination node pubkey of the pair.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "routerrpcPaymentState": {
      "default": "IN_FLIGHT",
      "description": " - IN_FLIGHT: Payment is still in flight.\n - SUCCEEDED: Payment completed successfully.\n - FAILED_TIMEOUT: There are more routes to try, but the payment timeout was exceeded.\n - FAILED_NO_ROUTE: All possible routes were tried and failed permanently. Or were no\nroutes to the destination at all.\n - FAILED_ERROR: A non-recoverable error has occurred.\n - FAILED_INCORRECT_PAYMENT_DETAILS: Payment details incorrect (unknown hash, invalid amt or\ninvalid final cltv delta)\n - FAILED_INSUFFICIENT_BALANCE: Insufficient local balance.",
      "enum": [
        "IN_FLIGHT",
        "SUCCEEDED",
        "FAILED_TIMEOUT",
        "FAILED_NO_ROUTE",
        "FAILED_ERROR",
        "FAILED_INCORRECT_PAYMENT_DETAILS",
        "FAILED_INSUFFICIENT_BALANCE"
      ],
      "type": "string"
    },
    "routerrpcPaymentStatus": {
      "properties": {
        "htlcs": {
          "description": "The HTLCs made in attempt to settle the payment [EXPERIMENTAL].",
          "items": {
            "$ref": "#/definitions/lnrpcHTLCAttempt"
          },
          "type": "array"
        },
        "preimage": {
          "description": "The pre-image of the payment when state is SUCCEEDED.",
          "format": "byte",
          "type": "string"
        },
        "state": {
          "$ref": "#/definitions/routerrpcPaymentState",
          "description": "Current state the payment is in."
        }
      },
      "type": "object"
    },
    "routerrpcQueryMissionControlResponse": {
      "description": "QueryMissionControlResponse contains mission control state.",
      "properties": {
        "pairs": {
          "description": "Node pair-level mission control state.",
          "items": {
            "$ref": "#/definitions/routerrpcPairHistory"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "routerrpcQueryProbabilityResponse": {
      "properties": {
        "history": {
          "$ref": "#/definitions/routerrpcPairData",
          "description": "The historical data for the requested pair."
        },
        "probability": {
          "description": "The success probability for the requested pair.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "routerrpcResetMissionControlRequest": {
      "type": "object"
    },
    "routerrpcResetMissionControlResponse": {
      "type": "object"
    },
    "routerrpcResolveHoldForwardAction": {
      "default": "SETTLE",
      "enum": [
        "SETTLE",
        "FAIL",
        "RESUME"
      ],
      "type": "string"
    },
    "routerrpcRouteFeeRequest": {
      "properties": {
        "amt_sat": {
          "description": "The amount one wishes to send to the target destination.",
          "format": "int64",
          "type": "string"
        },
        "dest": {
          "description": "The destination once wishes to obtain a routing fee quote to.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "routerrpcRouteFeeResponse": {
      "properties": {
        "routing_fee_msat": {
          "description": "A lower bound of the estimated fee to the target destination within the\nnetwork, expressed in milli-satoshis.",
          "format": "int64",
          "type": "string"
        },
        "time_lock_delay": {
          "description": "An estimate of the worst case time delay that can occur. Note that callers\nwill still need to factor in the final CLTV delta of the last hop into this\nvalue.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "routerrpcSendPaymentRequest": {
      "properties": {
        "allow_self_payment": {
          "description": "If set, circular payments to self are permitted.",
          "type": "boolean"
        },
        "amp": {
          "description": "If set, an AMP-payment will be attempted.",
          "type": "boolean"
        },
        "amt": {
          "description": "Number of satoshis to send.\n\nThe fields amt and amt_msat are mutually exclusive.",
          "format": "int64",
          "type": "string"
        },
        "amt_msat": {
          "description": "Number of millisatoshis to send.\n\nThe fields amt and amt_msat are mutually exclusive.",
          "format": "int64",
          "type": "string"
        },
        "cltv_limit": {
          "description": "An optional maximum total time lock for the route. This should not exceed\nlnd's `--max-cltv-expiry` setting. If zero, then the value of\n`--max-cltv-expiry` is enforced.",
          "format": "int32",
          "type": "integer"
        },
        "dest": {
          "format": "byte",
          "title": "The identity pubkey of the payment recipient",
          "type": "string"
        },
        "dest_custom_records": {
          "additionalProperties": {
            "format": "byte",
            "type": "string"
          },
          "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto a peer which understands the new records. This can be used to pass\napplication specific data during the payment attempt. Record types are\nrequired to be in the custom range \u003e= 65536. When using REST, the values\nmust be encoded as base64.",
          "type": "object"
        },
        "dest_features": {
          "description": "Features assumed to be supported by the final node. All transitive feature\ndependencies must also be set properly. For a given feature bit pair, either\noptional or remote may be set, but not both. If this field is nil or empty,\nthe router will try to load destination features from the graph as a\nfallback.",
          "items": {
            "$ref": "#/definitions/lnrpcFeatureBit"
          },
          "type": "array"
        },
        "fee_limit_msat": {
          "description": "The maximum number of millisatoshis that will be paid as a fee of the\npayment. If this field is left to the default value of 0, only zero-fee\nroutes will be considered. This usually means single hop routes connecting\ndirectly to the destination. To send the payment without a fee limit, use\nmax int here.\n\nThe fields fee_limit_sat and fee_limit_msat are mutually exclusive.",
          "format": "int64",
          "type": "string"
        },
        "fee_limit_sat": {
          "description": "The maximum number of satoshis that will be paid as a fee of the payment.\nIf this field is left to the default value of 0, only zero-fee routes will\nbe considered. This usually means single hop routes connecting directly to\nthe destination. To send the payment without a fee limit, use max int here.\n\nThe fields fee_limit_sat and fee_limit_msat are mutually exclusive.",
          "format": "int64",
          "type": "string"
        },
        "final_cltv_delta": {
          "description": "The CLTV delta from the current height that should be used to set the\ntimelock for the final hop.",
          "format": "int32",
          "type": "integer"
        },
        "last_hop_pubkey": {
          "description": "The pubkey of the last hop of the route. If empty, any hop may be used.",
          "format": "byte",
          "type": "string"
        },
        "max_parts": {
          "description": "The maximum number of partial payments that may be use to complete the full\namount.",
          "format": "int64",
          "type": "integer"
        },
        "max_shard_size_msat": {
          "description": "The largest payment split that should be attempted when making a payment if\nsplitting is necessary. Setting this value will effectively cause lnd to\nsplit more aggressively, vs only when it thinks it needs to. Note that this\nvalue is in milli-satoshis.",
          "format": "uint64",
          "type": "string"
        },
        "no_inflight_updates": {
          "description": "If set, only the final payment update is streamed back. Intermediate updates\nthat show which htlcs are still in flight are suppressed.",
          "type": "boolean"
        },
        "outgoing_chan_id": {
          "description": "Deprecated, use outgoing_chan_ids. The channel id of the channel that must\nbe taken to the first hop. If zero, any channel may be used (unless\noutgoing_chan_ids are set).",
          "format": "uint64",
          "type": "string"
        },
        "outgoing_chan_ids": {
          "description": "The channel ids of the channels are allowed for the first hop. If empty,\nany channel may be used.",
          "items": {
            "format": "uint64",
            "type": "string"
          },
          "type": "array"
        },
        "payment_addr": {
          "description": "An optional payment addr to be included within the last hop of the route.",
          "format": "byte",
          "type": "string"
        },
        "payment_hash": {
          "format": "byte",
          "title": "The hash to use within the payment's HTLC",
          "type": "string"
        },
        "payment_request": {
          "description": "A bare-bones invoice for a payment within the Lightning Network.  With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient. The amount in the payment request may be zero. In\nthat case it is required to set the amt field as well. If no payment request\nis specified, the following fields are required: dest, amt and payment_hash.",
          "type": "string"
        },
        "route_hints": {
          "description": "Optional route hints to reach the destination through private channels.",
          "items": {
            "$ref": "#/definitions/lnrpcRouteHint"
          },
          "type": "array"
        },
        "time_pref": {
          "description": "The time preference for this payment. Set to -1 to optimize for fees\nonly, to 1 to optimize for reliability only or a value inbetween for a mix.",
          "format": "double",
          "type": "number"
        },
        "timeout_seconds": {
          "description": "An upper limit on the amount of time we should spend when attempting to\nfulfill the payment. This is expressed in seconds. If we cannot make a\nsuccessful payment within this time frame, an error will be returned.\nThis field must be non-zero.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "routerrpcSendToRouteRequest": {
      "properties": {
        "payment_hash": {
          "description": "The payment hash to use for the HTLC.",
          "format": "byte",
          "type": "string"
        },
        "route": {
          "$ref": "#/definitions/lnrpcRoute",
          "description": "Route that should be used to attempt to complete the payment."
        },
        "skip_temp_err": {
          "description": "Whether the payment should be marked as failed when a temporary error is\nreturned from the given route. Set it to true so the payment won't be\nfailed unless a terminal error is occurred, such as payment timeout, no\nroutes, incorrect payment details, or insufficient funds.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "routerrpcSendToRouteResponse": {
      "properties": {
        "failure": {
          "$ref": "#/definitions/lnrpcFailure",
          "description": "The failure message in case the payment failed."
        },
        "preimage": {
          "description": "The preimage obtained by making the payment.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "routerrpcSetMissionControlConfigRequest": {
      "properties": {
        "config": {
          "$ref": "#/definitions/routerrpcMissionControlConfig",
          "description": "The config to set for mission control. Note that all values *must* be set,\nbecause the full config will be applied."
        }
      },
      "type": "object"
    },
    "routerrpcSetMissionControlConfigResponse": {
      "type": "object"
    },
    "routerrpcSettleEvent": {
      "properties": {
        "preimage": {
          "description": "The revealed preimage.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "routerrpcUpdateChanStatusRequest": {
      "properties": {
        "action": {
          "$ref": "#/definitions/routerrpcChanStatusAction"
        },
        "chan_point": {
          "$ref": "#/definitions/lnrpcChannelPoint"
        }
      },
      "type": "object"
    },
    "routerrpcUpdateChanStatusResponse": {
      "type": "object"
    },
    "routerrpcXImportMissionControlRequest": {
      "properties": {
        "force": {
          "description": "Whether to force override MC pair history. Note that even with force\noverride the failure pair is imported before the success pair and both\nstill clamp existing failure/success amounts.",
          "type": "boolean"
        },
        "pairs": {
          "description": "Node pair-level mission control state to be imported.",
          "items": {
            "$ref": "#/definitions/routerrpcPairHistory"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "routerrpcXImportMissionControlResponse": {
      "type": "object"
    },
    "rpcStatus": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "details": {
          "items": {
            "$ref": "#/definitions/protobufAny"
          },
          "type": "array"
        },
        "message": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcInputScript": {
      "properties": {
        "sig_script": {
          "description": "The optional sig script for the specified witness that will only be set if\nthe input specified is a nested p2sh witness program.",
          "format": "byte",
          "type": "string"
        },
        "witness": {
          "description": "The serializes witness stack for the specified input.",
          "items": {
            "format": "byte",
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "signrpcInputScriptResp": {
      "properties": {
        "input_scripts": {
          "description": "The set of fully valid input scripts requested.",
          "items": {
            "$ref": "#/definitions/signrpcInputScript"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "signrpcKeyDescriptor": {
      "properties": {
        "key_loc": {
          "$ref": "#/definitions/signrpcKeyLocator",
          "description": "The key locator that identifies which private key to use for signing.\nEither this or the raw bytes of the target public key must be specified."
        },
        "raw_key_bytes": {
          "description": "The raw bytes of the public key in the key pair being identified. Either\nthis or the KeyLocator must be specified.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcKeyLocator": {
      "properties": {
        "key_family": {
          "description": "The family of key being identified.",
          "format": "int32",
          "type": "integer"
        },
        "key_index": {
          "description": "The precise index of the key being identified.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "signrpcMuSig2CleanupRequest": {
      "properties": {
        "session_id": {
          "description": "The unique ID of the signing session that should be removed/cleaned up.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcMuSig2CleanupResponse": {
      "type": "object"
    },
    "signrpcMuSig2CombineKeysRequest": {
      "properties": {
        "all_signer_pubkeys": {
          "description": "A list of all public keys (serialized in 32-byte x-only format!)\nparticipating in the signing session. The list will always be sorted\nlexicographically internally. This must include the local key which is\ndescribed by the above key_loc.",
          "items": {
            "format": "byte",
            "type": "string"
          },
          "type": "array"
        },
        "taproot_tweak": {
          "$ref": "#/definitions/signrpcTaprootTweakDesc",
          "description": "An optional taproot specific tweak that must be specified if the MuSig2\ncombined key will be used as the main taproot key of a taproot output\non-chain."
        },
        "tweaks": {
          "description": "A series of optional generic tweaks to be applied to the the aggregated\npublic key.",
          "items": {
            "$ref": "#/definitions/signrpcTweakDesc"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "signrpcMuSig2CombineKeysResponse": {
      "properties": {
        "combined_key": {
          "description": "The combined public key (in the 32-byte x-only format) with all tweaks\napplied to it. If a taproot tweak is specified, this corresponds to the\ntaproot key that can be put into the on-chain output.",
          "format": "byte",
          "type": "string"
        },
        "taproot_internal_key": {
          "description": "The raw combined public key (in the 32-byte x-only format) before any tweaks\nare applied to it. If a taproot tweak is specified, this corresponds to the\ninternal key that needs to be put into the witness if the script spend path\nis used.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcMuSig2CombineSigRequest": {
      "properties": {
        "other_partial_signatures": {
          "description": "The list of all other participants' partial signatures to add to the current\nsession.",
          "items": {
            "format": "byte",
            "type": "string"
          },
          "type": "array"
        },
        "session_id": {
          "description": "The unique ID of the signing session to combine the signatures for.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcMuSig2CombineSigResponse": {
      "properties": {
        "final_signature": {
          "description": "The final, full signature that is valid for the combined public key.",
          "format": "byte",
          "type": "string"
        },
        "have_all_signatures": {
          "description": "Indicates whether all partial signatures required to create a final, full\nsignature are known yet. If this is true, then the final_signature field is\nset, otherwise it is empty.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "signrpcMuSig2RegisterNoncesRequest": {
      "properties": {
        "other_signer_public_nonces": {
          "description": "A list of all public nonces of other signing participants that should be\nregistered.",
          "items": {
            "format": "byte",
            "type": "string"
          },
          "type": "array"
        },
        "session_id": {
          "description": "The unique ID of the signing session those nonces should be registered with.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcMuSig2RegisterNoncesResponse": {
      "properties": {
        "have_all_nonces": {
          "description": "Indicates whether all nonces required to start the signing process are known\nnow.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "signrpcMuSig2SessionRequest": {
      "properties": {
        "all_signer_pubkeys": {
          "description": "A list of all public keys (serialized in 32-byte x-only format!)\nparticipating in the signing session. The list will always be sorted\nlexicographically internally. This must include the local key which is\ndescribed by the above key_loc.",
          "items": {
            "format": "byte",
            "type": "string"
          },
          "type": "array"
        },
        "key_loc": {
          "$ref": "#/definitions/signrpcKeyLocator",
          "description": "The key locator that identifies which key to use for signing."
        },
        "other_signer_public_nonces": {
          "description": "An optional list of all public nonces of other signing participants that\nmight already be known.",
          "items": {
            "format": "byte",
            "type": "string"
          },
          "type": "array"
        },
        "taproot_tweak": {
          "$ref": "#/definitions/signrpcTaprootTweakDesc",
          "description": "An optional taproot specific tweak that must be specified if the MuSig2\ncombined key will be used as the main taproot key of a taproot output\non-chain."
        },
        "tweaks": {
          "description": "A series of optional generic tweaks to be applied to the the aggregated\npublic key.",
          "items": {
            "$ref": "#/definitions/signrpcTweakDesc"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "signrpcMuSig2SessionResponse": {
      "properties": {
        "combined_key": {
          "description": "The combined public key (in the 32-byte x-only format) with all tweaks\napplied to it. If a taproot tweak is specified, this corresponds to the\ntaproot key that can be put into the on-chain output.",
          "format": "byte",
          "type": "string"
        },
        "have_all_nonces": {
          "description": "Indicates whether all nonces required to start the signing process are known\nnow.",
          "type": "boolean"
        },
        "local_public_nonces": {
          "description": "The two public nonces the local signer uses, combined into a single value\nof 66 bytes. Can be split into the two 33-byte points to get the individual\nnonces.",
          "format": "byte",
          "type": "string"
        },
        "session_id": {
          "description": "The unique ID that represents this signing session. A session can be used\nfor producing a signature a single time. If the signing fails for any\nreason, a new session with the same participants needs to be created.",
          "format": "byte",
          "type": "string"
        },
        "taproot_internal_key": {
          "description": "The raw combined public key (in the 32-byte x-only format) before any tweaks\nare applied to it. If a taproot tweak is specified, this corresponds to the\ninternal key that needs to be put into the witness if the script spend path\nis used.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcMuSig2SignRequest": {
      "properties": {
        "cleanup": {
          "description": "Cleanup indicates that after signing, the session state can be cleaned up,\nsince another participant is going to be responsible for combining the\npartial signatures.",
          "type": "boolean"
        },
        "message_digest": {
          "description": "The 32-byte SHA256 digest of the message to sign.",
          "format": "byte",
          "type": "string"
        },
        "session_id": {
          "description": "The unique ID of the signing session to use for signing.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcMuSig2SignResponse": {
      "properties": {
        "local_partial_signature": {
          "description": "The partial signature created by the local signer.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcSharedKeyRequest": {
      "properties": {
        "ephemeral_pubkey": {
          "description": "The ephemeral public key to use for the DH key derivation.",
          "format": "byte",
          "type": "string"
        },
        "key_desc": {
          "$ref": "#/definitions/signrpcKeyDescriptor",
          "description": "A key descriptor describes the key used for performing ECDH. Either a key\nlocator or a raw public key is expected, if neither is supplied, defaults to\nthe node's identity private key."
        },
        "key_loc": {
          "$ref": "#/definitions/signrpcKeyLocator",
          "description": "Deprecated. The optional key locator of the local key that should be used.\nIf this parameter is not set then the node's identity private key will be\nused."
        }
      },
      "type": "object"
    },
    "signrpcSharedKeyResponse": {
      "properties": {
        "shared_key": {
          "description": "The shared public key, hashed with sha256.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcSignDescriptor": {
      "properties": {
        "double_tweak": {
          "description": "A private key that will be used in combination with its corresponding\nprivate key to derive the private key that is to be used to sign the target\ninput. Within the Lightning protocol, this value is typically the\ncommitment secret from a previously revoked commitment transaction. This\nvalue is in combination with two hash values, and the original private key\nto derive the private key to be used when signing.\n\nk = (privKey*sha256(pubKey || tweakPub) +\ntweakPriv*sha256(tweakPub || pubKey)) mod N",
          "format": "byte",
          "type": "string"
        },
        "input_index": {
          "description": "The target input within the transaction that should be signed.",
          "format": "int32",
          "type": "integer"
        },
        "key_desc": {
          "$ref": "#/definitions/signrpcKeyDescriptor",
          "description": "A descriptor that precisely describes *which* key to use for signing. This\nmay provide the raw public key directly, or require the Signer to re-derive\nthe key according to the populated derivation path.\n\nNote that if the key descriptor was obtained through walletrpc.DeriveKey,\nthen the key locator MUST always be provided, since the derived keys are not\npersisted unlike with DeriveNextKey."
        },
        "output": {
          "$ref": "#/definitions/signrpcTxOut",
          "description": "A description of the output being spent. The value and script MUST be\nprovided."
        },
        "sighash": {
          "description": "The target sighash type that should be used when generating the final\nsighash, and signature.",
          "format": "int64",
          "type": "integer"
        },
        "sign_method": {
          "$ref": "#/definitions/signrpcSignMethod",
          "description": "The sign method specifies how the input should be signed. Depending on the\nmethod, either the tap_tweak, witness_script or both need to be specified.\nDefaults to SegWit v0 signing to be backward compatible with older RPC\nclients."
        },
        "single_tweak": {
          "description": "derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N",
          "format": "byte",
          "title": "A scalar value that will be added to the private key corresponding to the\nabove public key to obtain the private key to be used to sign this input.\nThis value is typically derived via the following computation:",
          "type": "string"
        },
        "tap_tweak": {
          "description": "The 32 byte input to the taproot tweak derivation that is used to derive\nthe output key from an internal key: outputKey = internalKey +\ntagged_hash(\"tapTweak\", internalKey || tapTweak).\n\nWhen doing a BIP 86 spend, this field can be an empty byte slice.\n\nWhen doing a normal key path spend, with the output key committing to an\nactual script root, then this field should be: the tapscript root hash.",
          "format": "byte",
          "type": "string"
        },
        "witness_script": {
          "description": "The full script required to properly redeem the output. This field will\nonly be populated if a p2tr, p2wsh or a p2sh output is being signed. If a\ntaproot script path spend is being attempted, then this should be the raw\nleaf script.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcSignMessageReq": {
      "properties": {
        "compact_sig": {
          "description": "Use the compact (pubkey recoverable) format instead of the raw lnwire\nformat. This option cannot be used with Schnorr signatures.",
          "type": "boolean"
        },
        "double_hash": {
          "description": "Double-SHA256 hash instead of just the default single round.",
          "type": "boolean"
        },
        "key_loc": {
          "$ref": "#/definitions/signrpcKeyLocator",
          "description": "The key locator that identifies which key to use for signing."
        },
        "msg": {
          "description": "The message to be signed. When using REST, this field must be encoded as\nbase64.",
          "format": "byte",
          "type": "string"
        },
        "schnorr_sig": {
          "description": "Use Schnorr signature. This option cannot be used with compact format.",
          "type": "boolean"
        },
        "schnorr_sig_tap_tweak": {
          "format": "byte",
          "title": "The optional Taproot tweak bytes to apply to the private key before creating\na Schnorr signature. The private key is tweaked as described in BIP-341:\nprivKey + h_tapTweak(internalKey || tapTweak)",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcSignMessageResp": {
      "properties": {
        "signature": {
          "description": "The signature for the given message in the fixed-size LN wire format.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcSignMethod": {
      "default": "SIGN_METHOD_WITNESS_V0",
      "description": " - SIGN_METHOD_WITNESS_V0: Specifies that a SegWit v0 (p2wkh, np2wkh, p2wsh) input script should be\nsigned.\n - SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086: Specifies that a SegWit v1 (p2tr) input should be signed by using the\nBIP0086 method (commit to internal key only).\n - SIGN_METHOD_TAPROOT_KEY_SPEND: Specifies that a SegWit v1 (p2tr) input should be signed by using a given\ntaproot hash to commit to in addition to the internal key.\n - SIGN_METHOD_TAPROOT_SCRIPT_SPEND: Specifies that a SegWit v1 (p2tr) input should be spent using the script\npath and that a specific leaf script should be signed for.",
      "enum": [
        "SIGN_METHOD_WITNESS_V0",
        "SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086",
        "SIGN_METHOD_TAPROOT_KEY_SPEND",
        "SIGN_METHOD_TAPROOT_SCRIPT_SPEND"
      ],
      "type": "string"
    },
    "signrpcSignReq": {
      "properties": {
        "prev_outputs": {
          "description": "The full list of UTXO information for each of the inputs being spent. This\nis required when spending one or more taproot (SegWit v1) outputs.",
          "items": {
            "$ref": "#/definitions/signrpcTxOut"
          },
          "type": "array"
        },
        "raw_tx_bytes": {
          "description": "The raw bytes of the transaction to be signed.",
          "format": "byte",
          "type": "string"
        },
        "sign_descs": {
          "description": "A set of sign descriptors, for each input to be signed.",
          "items": {
            "$ref": "#/definitions/signrpcSignDescriptor"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "signrpcSignResp": {
      "properties": {
        "raw_sigs": {
          "description": "A set of signatures realized in a fixed 64-byte format ordered in ascending\ninput order.",
          "items": {
            "format": "byte",
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "signrpcTaprootTweakDesc": {
      "properties": {
        "key_spend_only": {
          "description": "Indicates that the above script_root is expected to be empty because this\nis a BIP-0086 key spend only commitment where only the internal key is\ncommitted to instead of also including a script root hash.",
          "type": "boolean"
        },
        "script_root": {
          "description": "The root hash of the tapscript tree if a script path is committed to. If\nthe MuSig2 key put on chain doesn't also commit to a script path (BIP-0086\nkey spend only), then this needs to be empty and the key_spend_only field\nbelow must be set to true. This is required because gRPC cannot\ndifferentiate between a zero-size byte slice and a nil byte slice (both\nwould be serialized the same way). So the extra boolean is required.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcTweakDesc": {
      "properties": {
        "is_x_only": {
          "description": "Specifies if the target key should be converted to an x-only public key\nbefore tweaking. If true, then the public key will be mapped to an x-only\nkey before the tweaking operation is applied.",
          "type": "boolean"
        },
        "tweak": {
          "description": "Tweak is the 32-byte value that will modify the public key.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcTxOut": {
      "properties": {
        "pk_script": {
          "description": "The script of the output being spent.",
          "format": "byte",
          "type": "string"
        },
        "value": {
          "description": "The value of the output being spent.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcVerifyMessageReq": {
      "properties": {
        "is_schnorr_sig": {
          "description": "Specifies if the signature is a Schnorr signature.",
          "type": "boolean"
        },
        "msg": {
          "description": "The message over which the signature is to be verified. When using\nREST, this field must be encoded as base64.",
          "format": "byte",
          "type": "string"
        },
        "pubkey": {
          "description": "The public key the signature has to be valid for. When using REST, this\nfield must be encoded as base64. If the is_schnorr_sig option is true, then\nthe public key is expected to be in the 32-byte x-only serialization\naccording to BIP-340.",
          "format": "byte",
          "type": "string"
        },
        "signature": {
          "description": "The fixed-size LN wire encoded signature to be verified over the given\nmessage. When using REST, this field must be encoded as base64.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "signrpcVerifyMessageResp": {
      "properties": {
        "valid": {
          "description": "Whether the signature was valid over the given message.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "verrpcVersion": {
      "properties": {
        "app_major": {
          "description": "The major application version.",
          "format": "int64",
          "type": "integer"
        },
        "app_minor": {
          "description": "The minor application version.",
          "format": "int64",
          "type": "integer"
        },
        "app_patch": {
          "description": "The application patch number.",
          "format": "int64",
          "type": "integer"
        },
        "app_pre_release": {
          "description": "The application pre-release modifier, possibly empty.",
          "type": "string"
        },
        "build_tags": {
          "description": "The list of build tags that were supplied during compilation.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "commit": {
          "description": "A verbose description of the daemon's commit.",
          "type": "string"
        },
        "commit_hash": {
          "description": "The SHA1 commit hash that the daemon is compiled with.",
          "type": "string"
        },
        "go_version": {
          "description": "The version of go that compiled the executable.",
          "type": "string"
        },
        "version": {
          "description": "The semantic version.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcAccount": {
      "properties": {
        "address_type": {
          "$ref": "#/definitions/walletrpcAddressType",
          "title": "The type of addresses the account supports.\nAddressType                       | External Branch | Internal Branch\n---------------------------------------------------------------------\nWITNESS_PUBKEY_HASH               | P2WPKH          | P2WPKH\nNESTED_WITNESS_PUBKEY_HASH        | NP2WPKH         | NP2WPKH\nHYBRID_NESTED_WITNESS_PUBKEY_HASH | NP2WPKH         | P2WPKH"
        },
        "derivation_path": {
          "description": "The derivation path corresponding to the account public key. This will\nalways be empty for the default imported account in which single public keys\nare imported into.",
          "type": "string"
        },
        "extended_public_key": {
          "description": "The public key backing the account that all keys are derived from\nrepresented as an extended key. This will always be empty for the default\nimported account in which single public keys are imported into.",
          "type": "string"
        },
        "external_key_count": {
          "description": "The number of keys derived from the external branch of the account public\nkey. This will always be zero for the default imported account in which\nsingle public keys are imported into.",
          "format": "int64",
          "type": "integer"
        },
        "internal_key_count": {
          "description": "The number of keys derived from the internal branch of the account public\nkey. This will always be zero for the default imported account in which\nsingle public keys are imported into.",
          "format": "int64",
          "type": "integer"
        },
        "master_key_fingerprint": {
          "description": "The fingerprint of the root key from which the account public key was\nderived from. This will always be zero for the default imported account in\nwhich single public keys are imported into. The bytes are in big-endian\norder.",
          "format": "byte",
          "type": "string"
        },
        "name": {
          "description": "The name used to identify the account.",
          "type": "string"
        },
        "watch_only": {
          "description": "Whether the wallet stores private keys for the account.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "walletrpcAddrRequest": {
      "properties": {
        "account": {
          "description": "The name of the account to retrieve the next address of. If empty, the\ndefault wallet account is used.",
          "type": "string"
        },
        "change": {
          "description": "Whether a change address should be derived.",
          "type": "boolean"
        },
        "type": {
          "$ref": "#/definitions/walletrpcAddressType",
          "description": "The type of address to derive."
        }
      },
      "type": "object"
    },
    "walletrpcAddrResponse": {
      "properties": {
        "addr": {
          "description": "The address encoded using a bech32 format.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcAddressType": {
      "default": "UNKNOWN",
      "enum": [
        "UNKNOWN",
        "WITNESS_PUBKEY_HASH",
        "NESTED_WITNESS_PUBKEY_HASH",
        "HYBRID_NESTED_WITNESS_PUBKEY_HASH",
        "TAPROOT_PUBKEY"
      ],
      "type": "string"
    },
    "walletrpcBumpFeeRequest": {
      "properties": {
        "force": {
          "description": "Whether this input must be force-swept. This means that it is swept even\nif it has a negative yield.",
          "type": "boolean"
        },
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "description": "The input we're attempting to bump the fee of."
        },
        "sat_per_byte": {
          "description": "Deprecated, use sat_per_vbyte.\nThe fee rate, expressed in sat/vbyte, that should be used to spend the input\nwith.",
          "format": "int64",
          "type": "integer"
        },
        "sat_per_vbyte": {
          "description": "The fee rate, expressed in sat/vbyte, that should be used to spend the input\nwith.",
          "format": "uint64",
          "type": "string"
        },
        "target_conf": {
          "description": "The target number of blocks that the input should be spent within.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "walletrpcBumpFeeResponse": {
      "type": "object"
    },
    "walletrpcEstimateFeeResponse": {
      "properties": {
        "sat_per_kw": {
          "description": "The amount of satoshis per kw that should be used in order to reach the\nconfirmation target in the request.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcFinalizePsbtRequest": {
      "properties": {
        "account": {
          "description": "The name of the account to finalize the PSBT with. If empty, the default\nwallet account is used.",
          "type": "string"
        },
        "funded_psbt": {
          "description": "A PSBT that should be signed and finalized. The PSBT must contain all\nrequired inputs, outputs, UTXO data and partial signatures of all other\nsigners.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcFinalizePsbtResponse": {
      "properties": {
        "raw_final_tx": {
          "description": "The fully signed and finalized transaction in the raw wire format.",
          "format": "byte",
          "type": "string"
        },
        "signed_psbt": {
          "description": "The fully signed and finalized transaction in PSBT format.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcFundPsbtRequest": {
      "properties": {
        "account": {
          "description": "The name of the account to fund the PSBT with. If empty, the default wallet\naccount is used.",
          "type": "string"
        },
        "min_confs": {
          "description": "The minimum number of confirmations each one of your outputs used for\nthe transaction must satisfy.",
          "format": "int32",
          "type": "integer"
        },
        "psbt": {
          "description": "Use an existing PSBT packet as the template for the funded PSBT.\n\nThe packet must contain at least one non-dust output. If one or more\ninputs are specified, no coin selection is performed. In that case every\ninput must be an UTXO known to the wallet that has not been locked\nbefore. The sum of all inputs must be sufficiently greater than the sum\nof all outputs to pay a miner fee with the specified fee rate. A change\noutput is added to the PSBT if necessary.",
          "format": "byte",
          "type": "string"
        },
        "raw": {
          "$ref": "#/definitions/walletrpcTxTemplate",
          "description": "Use the outputs and optional inputs from this raw template."
        },
        "sat_per_vbyte": {
          "description": "The fee rate, expressed in sat/vbyte, that should be used to spend the\ninput with.",
          "format": "uint64",
          "type": "string"
        },
        "spend_unconfirmed": {
          "description": "Whether unconfirmed outputs should be used as inputs for the transaction.",
          "type": "boolean"
        },
        "target_conf": {
          "description": "The target number of blocks that the transaction should be confirmed in.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "walletrpcFundPsbtResponse": {
      "properties": {
        "change_output_index": {
          "description": "The index of the added change output or -1 if no change was left over.",
          "format": "int32",
          "type": "integer"
        },
        "funded_psbt": {
          "description": "The funded but not yet signed PSBT packet.",
          "format": "byte",
          "type": "string"
        },
        "locked_utxos": {
          "description": "The list of lock leases that were acquired for the inputs in the funded PSBT\npacket.",
          "items": {
            "$ref": "#/definitions/walletrpcUtxoLease"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "walletrpcImportAccountRequest": {
      "properties": {
        "address_type": {
          "$ref": "#/definitions/walletrpcAddressType",
          "description": "An address type is only required when the extended account public key has a\nlegacy version (xpub, tpub, etc.), such that the wallet cannot detect what\naddress scheme it belongs to."
        },
        "dry_run": {
          "description": "Whether a dry run should be attempted when importing the account. This\nserves as a way to confirm whether the account is being imported correctly\nby returning the first N addresses for the external and internal branches of\nthe account. If these addresses match as expected, then it should be safe to\nimport the account as is.",
          "type": "boolean"
        },
        "extended_public_key": {
          "description": "A public key that corresponds to a wallet account represented as an extended\nkey. It must conform to a derivation path of the form\nm/purpose'/coin_type'/account'.",
          "type": "string"
        },
        "master_key_fingerprint": {
          "description": "The fingerprint of the root key (also known as the key with derivation path\nm/) from which the account public key was derived from. This may be required\nby some hardware wallets for proper identification and signing. The bytes\nmust be in big-endian order.",
          "format": "byte",
          "type": "string"
        },
        "name": {
          "description": "A name to identify the account with.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcImportAccountResponse": {
      "properties": {
        "account": {
          "$ref": "#/definitions/walletrpcAccount",
          "description": "The details of the imported account."
        },
        "dry_run_external_addrs": {
          "description": "The first N addresses that belong to the external branch of the account.\nThe external branch is typically used for external non-change addresses.\nThese are only returned if a dry run was specified within the request.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "dry_run_internal_addrs": {
          "description": "The first N addresses that belong to the internal branch of the account.\nThe internal branch is typically used for change addresses. These are only\nreturned if a dry run was specified within the request.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "walletrpcImportPublicKeyRequest": {
      "properties": {
        "address_type": {
          "$ref": "#/definitions/walletrpcAddressType",
          "description": "The type of address that will be generated from the public key."
        },
        "public_key": {
          "description": "A compressed public key represented as raw bytes.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcImportPublicKeyResponse": {
      "type": "object"
    },
    "walletrpcKeyReq": {
      "properties": {
        "key_family": {
          "description": "The target key family to derive a key from. In other contexts, this is\nknown as the \"account\".",
          "format": "int32",
          "type": "integer"
        },
        "key_finger_print": {
          "description": "Is the key finger print of the root pubkey that this request is targeting.\nThis allows the WalletKit to possibly serve out keys for multiple HD chains\nvia public derivation.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "walletrpcLabelTransactionRequest": {
      "properties": {
        "label": {
          "description": "The label to add to the transaction, limited to 500 characters.",
          "type": "string"
        },
        "overwrite": {
          "description": "Whether to overwrite the existing label, if it is present.",
          "type": "boolean"
        },
        "txid": {
          "description": "The txid of the transaction to label.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcLabelTransactionResponse": {
      "type": "object"
    },
    "walletrpcLeaseOutputRequest": {
      "properties": {
        "expiration_seconds": {
          "description": "The time in seconds before the lock expires. If set to zero, the default\nlock duration is used.",
          "format": "uint64",
          "type": "string"
        },
        "id": {
          "description": "An ID of 32 random bytes that must be unique for each distinct application\nusing this RPC which will be used to bound the output lease to.",
          "format": "byte",
          "type": "string"
        },
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "description": "The identifying outpoint of the output being leased."
        }
      },
      "type": "object"
    },
    "walletrpcLeaseOutputResponse": {
      "properties": {
        "expiration": {
          "description": "The absolute expiration of the output lease represented as a unix timestamp.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcListAccountsResponse": {
      "properties": {
        "accounts": {
          "items": {
            "$ref": "#/definitions/walletrpcAccount"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "walletrpcListLeasesResponse": {
      "properties": {
        "locked_utxos": {
          "description": "The list of currently leased utxos.",
          "items": {
            "$ref": "#/definitions/walletrpcUtxoLease"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "walletrpcListSweepsResponse": {
      "properties": {
        "transaction_details": {
          "$ref": "#/definitions/lnrpcTransactionDetails"
        },
        "transaction_ids": {
          "$ref": "#/definitions/ListSweepsResponseTransactionIDs"
        }
      },
      "type": "object"
    },
    "walletrpcListUnspentRequest": {
      "properties": {
        "account": {
          "description": "An optional filter to only include outputs belonging to an account.",
          "type": "string"
        },
        "max_confs": {
          "description": "The maximum number of confirmations to be included.",
          "format": "int32",
          "type": "integer"
        },
        "min_confs": {
          "description": "The minimum number of confirmations to be included.",
          "format": "int32",
          "type": "integer"
        },
        "unconfirmed_only": {
          "title": "When min_confs and max_confs are zero, setting false implicitly\noverrides max_confs to be MaxInt32, otherwise max_confs remains\nzero. An error is returned if the value is true and both min_confs\nand max_confs are non-zero. (default: false)",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "walletrpcListUnspentResponse": {
      "properties": {
        "utxos": {
          "description": "A list of utxos satisfying the specified number of confirmations.",
          "items": {
            "$ref": "#/definitions/lnrpcUtxo"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "walletrpcPendingSweep": {
      "properties": {
        "amount_sat": {
          "description": "The value of the output we're attempting to sweep.",
          "format": "int64",
          "type": "integer"
        },
        "broadcast_attempts": {
          "description": "The number of broadcast attempts we've made to sweep the output.",
          "format": "int64",
          "type": "integer"
        },
        "force": {
          "description": "Whether this input must be force-swept. This means that it is swept even\nif it has a negative yield.",
          "type": "boolean"
        },
        "next_broadcast_height": {
          "description": "The next height of the chain at which we'll attempt to broadcast the\nsweep transaction of the output.",
          "format": "int64",
          "type": "integer"
        },
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "description": "The outpoint of the output we're attempting to sweep."
        },
        "requested_conf_target": {
          "description": "The requested confirmation target for this output.",
          "format": "int64",
          "type": "integer"
        },
        "requested_sat_per_byte": {
          "description": "Deprecated, use requested_sat_per_vbyte.\nThe requested fee rate, expressed in sat/vbyte, for this output.",
          "format": "int64",
          "type": "integer"
        },
        "requested_sat_per_vbyte": {
          "description": "The requested fee rate, expressed in sat/vbyte, for this output.",
          "format": "uint64",
          "type": "string"
        },
        "sat_per_byte": {
          "description": "Deprecated, use sat_per_vbyte.\nThe fee rate we'll use to sweep the output, expressed in sat/vbyte. The fee\nrate is only determined once a sweeping transaction for the output is\ncreated, so it's possible for this to be 0 before this.",
          "format": "int64",
          "type": "integer"
        },
        "sat_per_vbyte": {
          "description": "The fee rate we'll use to sweep the output, expressed in sat/vbyte. The fee\nrate is only determined once a sweeping transaction for the output is\ncreated, so it's possible for this to be 0 before this.",
          "format": "uint64",
          "type": "string"
        },
        "witness_type": {
          "$ref": "#/definitions/walletrpcWitnessType",
          "description": "The witness type of the output we're attempting to sweep."
        }
      },
      "type": "object"
    },
    "walletrpcPendingSweepsResponse": {
      "properties": {
        "pending_sweeps": {
          "description": "The set of outputs currently being swept by lnd's central batching engine.",
          "items": {
            "$ref": "#/definitions/walletrpcPendingSweep"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "walletrpcPublishResponse": {
      "properties": {
        "publish_error": {
          "description": "If blank, then no error occurred and the transaction was successfully\npublished. If not the empty string, then a string representation of the\nbroadcast error.\n\nTODO(roasbeef): map to a proper enum type",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcReleaseOutputRequest": {
      "properties": {
        "id": {
          "description": "The unique ID that was used to lock the output.",
          "format": "byte",
          "type": "string"
        },
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "description": "The identifying outpoint of the output being released."
        }
      },
      "type": "object"
    },
    "walletrpcReleaseOutputResponse": {
      "type": "object"
    },
    "walletrpcRequiredReserveResponse": {
      "properties": {
        "required_reserve": {
          "description": "The amount of reserve required.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcSendOutputsRequest": {
      "properties": {
        "label": {
          "description": "An optional label for the transaction, limited to 500 characters.",
          "type": "string"
        },
        "min_confs": {
          "description": "The minimum number of confirmations each one of your outputs used for\nthe transaction must satisfy.",
          "format": "int32",
          "type": "integer"
        },
        "outputs": {
          "description": "A slice of the outputs that should be created in the transaction produced.",
          "items": {
            "$ref": "#/definitions/signrpcTxOut"
          },
          "type": "array"
        },
        "sat_per_kw": {
          "description": "The number of satoshis per kilo weight that should be used when crafting\nthis transaction.",
          "format": "int64",
          "type": "string"
        },
        "spend_unconfirmed": {
          "description": "Whether unconfirmed outputs should be used as inputs for the transaction.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "walletrpcSendOutputsResponse": {
      "properties": {
        "raw_tx": {
          "description": "The serialized transaction sent out on the network.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcSignPsbtRequest": {
      "properties": {
        "funded_psbt": {
          "description": "The PSBT that should be signed. The PSBT must contain all required inputs,\noutputs, UTXO data and custom fields required to identify the signing key.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcSignPsbtResponse": {
      "properties": {
        "signed_psbt": {
          "description": "The signed transaction in PSBT format.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcTransaction": {
      "properties": {
        "label": {
          "description": "An optional label to save with the transaction. Limited to 500 characters.",
          "type": "string"
        },
        "tx_hex": {
          "description": "The raw serialized transaction.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcTxTemplate": {
      "properties": {
        "inputs": {
          "description": "An optional list of inputs to use. Every input must be an UTXO known to the\nwallet that has not been locked before. The sum of all inputs must be\nsufficiently greater than the sum of all outputs to pay a miner fee with the\nfee rate specified in the parent message.\n\nIf no inputs are specified, coin selection will be performed instead and\ninputs of sufficient value will be added to the resulting PSBT.",
          "items": {
            "$ref": "#/definitions/lnrpcOutPoint"
          },
          "type": "array"
        },
        "outputs": {
          "additionalProperties": {
            "format": "uint64",
            "type": "string"
          },
          "description": "A map of all addresses and the amounts to send to in the funded PSBT.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "walletrpcUtxoLease": {
      "properties": {
        "expiration": {
          "description": "The absolute expiration of the output lease represented as a unix timestamp.",
          "format": "uint64",
          "type": "string"
        },
        "id": {
          "description": "A 32 byte random ID that identifies the lease.",
          "format": "byte",
          "type": "string"
        },
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "description": "The identifying outpoint of the output being leased."
        },
        "pk_script": {
          "description": "The public key script of the leased output.",
          "format": "byte",
          "type": "string"
        },
        "value": {
          "description": "The value of the leased output in satoshis.",
          "format": "uint64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "walletrpcWitnessType": {
      "default": "UNKNOWN_WITNESS",
      "description": " - COMMITMENT_TIME_LOCK: A witness that allows us to spend the output of a commitment transaction\nafter a relative lock-time lockout.\n - COMMITMENT_NO_DELAY: A witness that allows us to spend a settled no-delay output immediately on a\ncounterparty's commitment transaction.\n - COMMITMENT_REVOKE: A witness that allows us to sweep the settled output of a malicious\ncounterparty's who broadcasts a revoked commitment transaction.\n - HTLC_OFFERED_REVOKE: A witness that allows us to sweep an HTLC which we offered to the remote\nparty in the case that they broadcast a revoked commitment state.\n - HTLC_ACCEPTED_REVOKE: A witness that allows us to sweep an HTLC output sent to us in the case that\nthe remote party broadcasts a revoked commitment state.\n - HTLC_OFFERED_TIMEOUT_SECOND_LEVEL: A witness that allows us to sweep an HTLC output that we extended to a\nparty, but was never fulfilled.  This HTLC output isn't directly on the\ncommitment transaction, but is the result of a confirmed second-level HTLC\ntransaction. As a result, we can only spend this after a CSV delay.\n - HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL: A witness that allows us to sweep an HTLC output that was offered to us, and\nfor which we have a payment preimage. This HTLC output isn't directly on our\ncommitment transaction, but is the result of confirmed second-level HTLC\ntransaction. As a result, we can only spend this after a CSV delay.\n - HTLC_OFFERED_REMOTE_TIMEOUT: A witness that allows us to sweep an HTLC that we offered to the remote\nparty which lies in the commitment transaction of the remote party. We can\nspend this output after the absolute CLTV timeout of the HTLC as passed.\n - HTLC_ACCEPTED_REMOTE_SUCCESS: A witness that allows us to sweep an HTLC that was offered to us by the\nremote party. We use this witness in the case that the remote party goes to\nchain, and we know the pre-image to the HTLC. We can sweep this without any\nadditional timeout.\n - HTLC_SECOND_LEVEL_REVOKE: A witness that allows us to sweep an HTLC from the remote party's commitment\ntransaction in the case that the broadcast a revoked commitment, but then\nalso immediately attempt to go to the second level to claim the HTLC.\n - WITNESS_KEY_HASH: A witness type that allows us to spend a regular p2wkh output that's sent to\nan output which is under complete control of the backing wallet.\n - NESTED_WITNESS_KEY_HASH: A witness type that allows us to sweep an output that sends to a nested P2SH\nscript that pays to a key solely under our control.\n - COMMITMENT_ANCHOR: A witness type that allows us to spend our anchor on the commitment\ntransaction.",
      "enum": [
        "UNKNOWN_WITNESS",
        "COMMITMENT_TIME_LOCK",
        "COMMITMENT_NO_DELAY",
        "COMMITMENT_REVOKE",
        "HTLC_OFFERED_REVOKE",
        "HTLC_ACCEPTED_REVOKE",
        "HTLC_OFFERED_TIMEOUT_SECOND_LEVEL",
        "HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL",
        "HTLC_OFFERED_REMOTE_TIMEOUT",
        "HTLC_ACCEPTED_REMOTE_SUCCESS",
        "HTLC_SECOND_LEVEL_REVOKE",
        "WITNESS_KEY_HASH",
        "NESTED_WITNESS_KEY_HASH",
        "COMMITMENT_ANCHOR"
      ],
      "type": "string"
    },
    "watchtowerrpcGetInfoResponse": {
      "properties": {
        "listeners": {
          "description": "The listening addresses of the watchtower.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "pubkey": {
          "description": "The public key of the watchtower.",
          "format": "byte",
          "type": "string"
        },
        "uris": {
          "description": "The URIs of the watchtower.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "wtclientrpcAddTowerRequest": {
      "properties": {
        "address": {
          "description": "A network address the watchtower is reachable over.",
          "type": "string"
        },
        "pubkey": {
          "description": "The identifying public key of the watchtower to add.",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "wtclientrpcAddTowerResponse": {
      "type": "object"
    },
    "wtclientrpcListTowersResponse": {
      "properties": {
        "towers": {
          "description": "The list of watchtowers available for new backups.",
          "items": {
            "$ref": "#/definitions/wtclientrpcTower"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "wtclientrpcPolicyResponse": {
      "properties": {
        "max_updates": {
          "description": "The maximum number of updates each session we negotiate with watchtowers\nshould allow.",
          "format": "int64",
          "type": "integer"
        },
        "sweep_sat_per_byte": {
          "description": "Deprecated, use sweep_sat_per_vbyte.\nThe fee rate, in satoshis per vbyte, that will be used by watchtowers for\njustice transactions in response to channel breaches.",
          "format": "int64",
          "type": "integer"
        },
        "sweep_sat_per_vbyte": {
          "description": "The fee rate, in satoshis per vbyte, that will be used by watchtowers for\njustice transactions in response to channel breaches.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "wtclientrpcPolicyType": {
      "default": "LEGACY",
      "description": " - LEGACY: Selects the policy from the legacy tower client.\n - ANCHOR: Selects the policy from the anchor tower client.",
      "enum": [
        "LEGACY",
        "ANCHOR"
      ],
      "type": "string"
    },
    "wtclientrpcRemoveTowerResponse": {
      "type": "object"
    },
    "wtclientrpcStatsResponse": {
      "properties": {
        "num_backups": {
          "description": "The total number of backups made to all active and exhausted watchtower\nsessions.",
          "format": "int64",
          "type": "integer"
        },
        "num_failed_backups": {
          "description": "The total number of backups that all active and exhausted watchtower\nsessions have failed to acknowledge.",
          "format": "int64",
          "type": "integer"
        },
        "num_pending_backups": {
          "description": "The total number of backups that are pending to be acknowledged by all\nactive and exhausted watchtower sessions.",
          "format": "int64",
          "type": "integer"
        },
        "num_sessions_acquired": {
          "description": "The total number of new sessions made to watchtowers.",
          "format": "int64",
          "type": "integer"
        },
        "num_sessions_exhausted": {
          "description": "The total number of watchtower sessions that have been exhausted.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "wtclientrpcTower": {
      "properties": {
        "active_session_candidate": {
          "description": "Whether the watchtower is currently a candidate for new sessions.",
          "type": "boolean"
        },
        "addresses": {
          "description": "The list of addresses the watchtower is reachable over.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "num_sessions": {
          "description": "The number of sessions that have been negotiated with the watchtower.",
          "format": "int64",
          "type": "integer"
        },
        "pubkey": {
          "description": "The identifying public key of the watchtower.",
          "format": "byte",
          "type": "string"
        },
        "sessions": {
          "description": "The list of sessions that have been negotiated with the watchtower.",
          "items": {
            "$ref": "#/definitions/wtclientrpcTowerSession"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "wtclientrpcTowerSession": {
      "properties": {
        "max_backups": {
          "description": "The maximum number of backups allowed by the watchtower session.",
          "format": "int64",
          "type": "integer"
        },
        "num_backups": {
          "description": "The total number of successful backups that have been made to the\nwatchtower session.",
          "format": "int64",
          "type": "integer"
        },
        "num_pending_backups": {
          "description": "The total number of backups in the session that are currently pending to be\nacknowledged by the watchtower.",
          "format": "int64",
          "type": "integer"
        },
        "sweep_sat_per_byte": {
          "description": "Deprecated, use sweep_sat_per_vbyte.\nThe fee rate, in satoshis per vbyte, that will be used by the watchtower for\nthe justice transaction in the event of a channel breach.",
          "format": "int64",
          "type": "integer"
        },
        "sweep_sat_per_vbyte": {
          "description": "The fee rate, in satoshis per vbyte, that will be used by the watchtower for\nthe justice transaction in the event of a channel breach.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    }
  }
}